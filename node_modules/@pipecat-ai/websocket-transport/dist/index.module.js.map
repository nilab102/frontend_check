{"mappings":"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AC,MAAM,CAAC,UAAU;QACtB,IAAI,CAAC,IAAI,CAAC,UAAU;QACpB,IAAI,CAAC,QAAQ,CAAC,UAAU;QACxB,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,IAAI,GAAG;QAEZ,MAAM,SAAS,IAAI,CAAA,GAAA,yCAAQ;QAC3B,MAAM,SAAS,OAAO,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,KAAK;QAC5D,OAAO;IACT;IAEA;;;;GAIC,GACD,MAAM,OAAO;QACX,IAAI,CAAC,qBAAqB,CAAC;QAC3B,IAAI,IAAI,CAAC,SAAS,EAChB,MAAM,IAAI,CAAC,GAAG;QAEhB,OAAO;IACT;AACF;AAEA,WAAW,WAAW,GAAG;;;;;A,I,kC,a,U,S,I,A;I,I,gB,S,C,E,C;Q,gB,O,c,I,C;Y,W,E;Q,C,a,S,S,C,E,C;Y,E,S,G;Q,K,S,C,E,C;Y,I,I,K,E,I,O,S,C,c,C,I,C,G,I,C,C,E,G,C,C,E;Q;Q,O,c,G;I;I,O,S,C,E,C;Q,I,O,M,c,M,M,M,I,U,yB,O,K;Q,c,G;Q,S;Y,I,C,W,G;Q;Q,E,S,G,M,O,O,M,C,K,C,G,S,G,E,S,E,I,I;I;A;A,I,kC,a,U,S,I,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,I,C;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,I,G,Q,O,K,I,M,O,K,E,I,C,W;Q;Q,K,A,C,Y,U,K,C,S,c,E,C,E,I;I;A;A,I,oC,a,U,W,I,S,O,E,I;I,I,I;Q,O;Q,M;Y,I,C,C,E,G,G,M,C,C,E;Y,O,C,C,E;Q;Q,M,E;Q,K,E;I,G,G,G,G,I,O,M,C,A,C,O,a,a,W,M,E,S;I,O,E,I,G,K,I,C,C,Q,G,K,I,C,C,S,G,K,I,O,W,c,C,C,C,O,Q,C,G;Q,O,I;I,C,G;I,S,K,C;Q,O,S,C;Y,O,K;gB;gB;a;Q;I;I,S,K,E;Q,I,G,M,I,U;Q,M,K,C,I,G,E,C,E,I,C,I,C,C,G,E,I;Y,I,I,G,K,C,I,E,C,E,G,I,C,C,S,G,E,C,E,G,C,C,Q,I,C,A,C,I,C,C,S,A,K,E,I,C,I,C,I,E,I,A,K,C,A,C,I,E,I,C,G,E,C,E,C,E,I,E,O;Y,I,I,G,G,K;gB,E,C,E,G;gB,E,K;a;Y,O,E,C,E;gB,K;gB,K;oB,I;oB;gB,K;oB,E,K;oB,O;wB,O,E,C,E;wB,M;oB;gB,K;oB,E,K;oB,I,E,C,E;oB,K;wB;qB;oB;gB,K;oB,K,E,G,C,G;oB,E,I,C,G;oB;gB;oB,I,C,C,I,E,I,E,I,E,M,G,K,C,C,E,M,G,E,A,K,C,E,C,E,K,K,E,C,E,K,C,G;wB,I;wB;oB;oB,I,E,C,E,K,K,C,C,K,E,C,E,G,C,C,E,I,E,C,E,G,C,C,E,G;wB,E,K,G,E,C,E;wB;oB;oB,I,E,C,E,K,K,E,K,G,C,C,E,E;wB,E,K,G,C,C,E;wB,I;wB;oB;oB,I,K,E,K,G,C,C,E,E;wB,E,K,G,C,C,E;wB,E,G,C,I,C;wB;oB;oB,I,C,C,E,E,E,G,C,G;oB,E,I,C,G;oB;Y;Y,K,K,I,C,S;Q,E,O,G;Y,K;gB;gB;a;Y,I;Q,S;Y,I,I;Q;Q,I,E,C,E,G,G,M,E,C,E;Q,O;Y,O,E,C,E,G,E,C,E,G,K;Y,M;Q;I;A;AT/VzB,IAAA,4CAAA,WAAA,GAAA;IAQE,SAAA;QALU,IAAA,CAAA,UAAU,GAAuB,CAAA;QAMzC,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,WAAW,GAAG;IACrB;IAEA,aAAA,SAAA,CAAA,oBAAoB,GAApB,SAAqB,iBAA8C;QACjE,IAAI,CAAC,kBAAkB,GAAG;IAC5B;IACA,aAAA,SAAA,CAAA,cAAc,GAAd,SAAe,OAA0B,EAAE,QAAyB;Q,I,I,I;QAAzB,IAAA,aAAA,KAAA,GAAA,WAAA;QACzC,IAAI,IAAI,CAAC,QAAQ,IAAI,CAAC,UAAU;QAChC,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,UAAU,GAAG,AAAA,CAAA,KAAA,QAAQ,SAAS,AAAT,MAAS,QAAA,OAAA,KAAA,IAAA,KAAI,CAAA;QACvC,IAAI,CAAC,WAAW,GAAG,AAAA,CAAA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AK,OAAA,EAAE,QAAQ,KAAK,cAAc,QAAQ;QAArC,MACnB,cAAc,QAAQ,KAAK,aAC1B,cAAc,KAAK,KAAK,CAAA,kBAAa,QAAb,kBAAa,KAAA,IAAA,KAAA,IAAb,cAAe,KAAK,AAAL,CAAK,GAEhD,IAAI,CAAC,SAAS,CAAC;IAEnB;IACF,OAAA;AAAA,EAlKqC;AAoKrC,IAAM,yCAAmB;IACvB,OAAO;QACL,IAAI;QACJ,MAAM;QACN,OAAO;IACR;AACH;;;;;;A,I,kC,a,U,S,I,A;I,I,gB,S,C,E,C;Q,gB,O,c,I,C;Y,W,E;Q,C,a,S,S,C,E,C;Y,E,S,G;Q,K,S,C,E,C;Y,I,I,K,E,I,O,S,C,c,C,I,C,G,I,C,C,E,G,C,C,E;Q;Q,O,c,G;I;I,O,S,C,E,C;Q,I,O,M,c,M,M,M,I,U,yB,O,K;Q,c,G;Q,S;Y,I,C,W,G;Q;Q,E,S,G,M,O,O,M,C,K,C,G,S,G,E,S,E,I,I;I;A;A,I,kC,a,U,S,I,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,I,C;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,I,G,Q,O,K,I,M,O,K,E,I,C,W;Q;Q,K,A,C,Y,U,K,C,S,c,E,C,E,I;I;A;A,I,oC,a,U,W,I,S,O,E,I;I,I,I;Q,O;Q,M;Y,I,C,C,E,G,G,M,C,C,E;Y,O,C,C,E;Q;Q,M,E;Q,K,E;I,G,G,G,G,I,O,M,C,A,C,O,a,a,W,M,E,S;I,O,E,I,G,K,I,C,C,Q,G,K,I,C,C,S,G,K,I,O,W,c,C,C,C,O,Q,C,G;Q,O,I;I,C,G;I,S,K,C;Q,O,S,C;Y,O,K;gB;gB;a;Q;I;I,S,K,E;Q,I,G,M,I,U;Q,M,K,C,I,G,E,C,E,I,C,I,C,C,G,E,I;Y,I,I,G,K,C,I,E,C,E,G,I,C,C,S,G,E,C,E,G,C,C,Q,I,C,A,C,I,C,C,S,A,K,E,I,C,I,C,I,E,I,A,K,C,A,C,I,E,I,C,G,E,C,E,C,E,I,E,O;Y,I,I,G,G,K;gB,E,C,E,G;gB,E,K;a;Y,O,E,C,E;gB,K;gB,K;oB,I;oB;gB,K;oB,E,K;oB,O;wB,O,E,C,E;wB,M;oB;gB,K;oB,E,K;oB,I,E,C,E;oB,K;wB;qB;oB;gB,K;oB,K,E,G,C,G;oB,E,I,C,G;oB;gB;oB,I,C,C,I,E,I,E,I,E,M,G,K,C,C,E,M,G,E,A,K,C,E,C,E,K,K,E,C,E,K,C,G;wB,I;wB;oB;oB,I,E,C,E,K,K,C,C,K,E,C,E,G,C,C,E,I,E,C,E,G,C,C,E,G;wB,E,K,G,E,C,E;wB;oB;oB,I,E,C,E,K,K,E,K,G,C,C,E,E;wB,E,K,G,C,C,E;wB,I;wB;oB;oB,I,K,E,K,G,C,C,E,E;wB,E,K,G,C,C,E;wB,E,G,C,I,C;wB;oB;oB,I,C,C,E,E,E,G,C,G;oB,E,I,C,G;oB;Y;Y,K,K,I,C,S;Q,E,O,G;Y,K;gB;gB;a;Y,I;Q,S;Y,I,I;Q;Q,I,E,C,E,G,G,M,E,C,E;Q,O;Y,O,E,C,E,G,E,C,E,G,K;Y,M;Q;I;A;AU3NA,IAAA,4CAAA,WAAA,GAAA,SAAA,MAAA;IAAuC,gCAAA,mBAAA;IAqBrC,SAAA,kBACE,YAA4B,EAC5B,eAA+B,EAC/B,sBAA+D,EAC/D,sBAA+D,EAC/D,iBAAiD,EACjD,kBAAkC,EAClC,gBAAgC;QANhC,IAAA,iBAAA,KAAA,GAAA,eAAA;QACA,IAAA,oBAAA,KAAA,GAAA,kBAAA;QAGA,IAAA,sBAAA,KAAA,GAAA,oBAAA;QACA,IAAA,uBAAA,KAAA,GAAA,qBAAA;QACA,IAAA,qBAAA,KAAA,GAAA,mBAAA;Q,I;QAEA,IAAA,QAAA,OAAK,IAAA,CAAA,IAAA,KAAE,IAAA;QApBD,MAAA,YAAY,GAA4C,CAAA;QACxD,MAAA,YAAY,GAA4C,CAAA;QACxD,MAAA,gBAAgB,GAA4C,CAAA;QAE5D,MAAA,yBAAyB,GAA0B;QAKnD,MAAA,kBAAkB,GAAuB;QAY/C,MAAK,YAAY,GAAG;QACpB,MAAK,UAAU,GAAG;QAClB,MAAK,kBAAkB,GAAG;QAC1B,MAAK,eAAe,GAAG;QACvB,MAAK,sBAAsB,GAAG;QAC9B,MAAK,sBAAsB,GAAG;QAC9B,MAAK,kBAAkB,GAAG;QAE1B,MAAK,MAAM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AAA,GAAA,yCAAA;AA+WvC,IAAM,sDAAgC,SAAC,CAAmB;IAAkB,OAAC;QAC3E,IAAI,EAAE,OAAO;QACb,OAAO,EAAE,KAAK;QACd,MAAM,EAAE,SAAS;IAClB;AAJ2E;AAM5E,IAAM,uCAAiB;IAAM,OAAC;QAC5B,IAAI;QACJ,OAAO;QACP,MAAM;IACP;AAJ4B;;;;;A,I,kC,a,U,S,I,A;I,I,gB,S,C,E,C;Q,gB,O,c,I,C;Y,W,E;Q,C,a,S,S,C,E,C;Y,E,S,G;Q,K,S,C,E,C;Y,I,I,K,E,I,O,S,C,c,C,I,C,G,I,C,C,E,G,C,C,E;Q;Q,O,c,G;I;I,O,S,C,E,C;Q,I,O,M,c,M,M,M,I,U,yB,O,K;Q,c,G;Q,S;Y,I,C,W,G;Q;Q,E,S,G,M,O,O,M,C,K,C,G,S,G,E,S,E,I,I;I;A;A,I,kC,a,U,S,I,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,I,C;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,I,G,Q,O,K,I,M,O,K,E,I,C,W;Q;Q,K,A,C,Y,U,K,C,S,c,E,C,E,I;I;A;A,I,oC,a,U,W,I,S,O,E,I;I,I,I;Q,O;Q,M;Y,I,C,C,E,G,G,M,C,C,E;Y,O,C,C,E;Q;Q,M,E;Q,K,E;I,G,G,G,G,I,O,M,C,A,C,O,a,a,W,M,E,S;I,O,E,I,G,K,I,C,C,Q,G,K,I,C,C,S,G,K,I,O,W,c,C,C,C,O,Q,C,G;Q,O,I;I,C,G;I,S,K,C;Q,O,S,C;Y,O,K;gB;gB;a;Q;I;I,S,K,E;Q,I,G,M,I,U;Q,M,K,C,I,G,E,C,E,I,C,I,C,C,G,E,I;Y,I,I,G,K,C,I,E,C,E,G,I,C,C,S,G,E,C,E,G,C,C,Q,I,C,A,C,I,C,C,S,A,K,E,I,C,I,C,I,E,I,A,K,C,A,C,I,E,I,C,G,E,C,E,C,E,I,E,O;Y,I,I,G,G,K;gB,E,C,E,G;gB,E,K;a;Y,O,E,C,E;gB,K;gB,K;oB,I;oB;gB,K;oB,E,K;oB,O;wB,O,E,C,E;wB,M;oB;gB,K;oB,E,K;oB,I,E,C,E;oB,K;wB;qB;oB;gB,K;oB,K,E,G,C,G;oB,E,I,C,G;oB;gB;oB,I,C,C,I,E,I,E,I,E,M,G,K,C,C,E,M,G,E,A,K,C,E,C,E,K,K,E,C,E,K,C,G;wB,I;wB;oB;oB,I,E,C,E,K,K,C,C,K,E,C,E,G,C,C,E,I,E,C,E,G,C,C,E,G;wB,E,K,G,E,C,E;wB;oB;oB,I,E,C,E,K,K,E,K,G,C,C,E,E;wB,E,K,G,C,C,E;wB,I;wB;oB;oB,I,K,E,K,G,C,C,E,E;wB,E,K,G,C,C,E;wB,E,G,C,I,C;wB;oB;oB,I,C,C,E,E,E,G,C,G;oB,E,I,C,G;oB;Y;Y,K,K,I,C,S;Q,E,O,G;Y,K;gB;gB;a;Y,I;Q,S;Y,I,I;Q;Q,I,E,C,E,G,G,M,E,C,E;Q,O;Y,O,E,C,E,G,E,C,E,G,K;Y,M;Q;I;A;A,I,sC,a,U,a,I,S,E,E,I,E,I;I,I,Q,U,M,K,G;Q,I,I,I,G,I,K,M,E,I,I,G,I,I,M,C,C,K,I,G;Y,I,C,I,K,M,S,C,K,C,I,C,M,G;Y,E,C,E,G,I,C,E;Q;I;I,O,G,M,C,M,M,S,C,K,C,I,C;A;AEjY7B,IAAM,oCAAc;IAAC;IAAc;IAAQ;IAAW;CAAS;AAC/D,IAAM,4CAAsB;AAC5B,IAAM,2CAAqB;AAC3B,+EAA+E;AAC/E,uEAAuE;AACvE,IAAM,qDAA+B;AACrC,IAAM,mDAA6B;AACnC,IAAM,+CAAyB;AAC/B,IAAM,mDAA6B;AACnC,IAAM,+CAAyB;AAC/B,IAAM,gDAA0B;AAEhC,IAAM,+CAAyB;AAE/B,IAAM,gDAA0B;AAChC,IAAM,wCAAkB;AAExB,IAAK;AAAL,CAAA,SAAK,SAAS;IACZ,SAAA,CAAA,SAAA,CAAA,QAAA,GAAA,EAAA,GAAA;IACA,SAAA,CAAA,SAAA,CAAA,QAAA,GAAA,EAAA,GAAA;IACA,SAAA,CAAA,SAAA,CAAA,OAAA,GAAA,EAAA,GAAA;IACA,SAAA,CAAA,SAAA,CAAA,OAAA,GAAA,EAAA,GAAA;AACF,CAAA,EALK,mCAAA,CAAA,kCAAS,CAAA,CAAA;AAOd,IAAA,mCAAA,WAAA,GAAA;IAQE,SAAA,WAAY,GAAW,EAAE,SAA6B;Q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","sources":["transports/websocket-transport/src/index.ts","lib/media-mgmt/mediaManager.ts","lib/wavtools/index.js","lib/wavtools/lib/wav_packer.js","lib/wavtools/lib/analysis/audio_analysis.js","lib/wavtools/lib/analysis/constants.js","lib/wavtools/lib/wav_stream_player.js","lib/wavtools/lib/worklets/stream_processor.js","lib/wavtools/lib/wav_recorder.js","lib/wavtools/lib/worklets/audio_processor.js","lib/wavtools/lib/mediastream_recorder.js","lib/media-mgmt/dailyMediaManager.ts","transports/websocket-transport/src/webSocketTransport.ts","lib/websocket-utils/reconnectingWebSocket.ts","transports/websocket-transport/src/serializers/protobufSerializer.ts","transports/websocket-transport/src/generated/proto/frames.ts","transports/websocket-transport/src/serializers/twilioSerializer.ts"],"sourcesContent":["// export * from \"./realTimeWebSocketTransport\";\n// export * from \"../../../lib/wavtools/dist/index.d.ts\";\n\nimport { WavMediaManager } from \"../../../lib/media-mgmt/mediaManager\";\nimport { DailyMediaManager } from \"../../../lib/media-mgmt/dailyMediaManager\";\nimport { WebSocketTransport } from \"./webSocketTransport.ts\";\nimport { ProtobufFrameSerializer } from \"./serializers/protobufSerializer.ts\";\nimport { TwilioSerializer } from \"./serializers/twilioSerializer.ts\";\n\nexport {\n  WavMediaManager,\n  DailyMediaManager,\n  WebSocketTransport,\n  ProtobufFrameSerializer,\n  TwilioSerializer,\n};\n","import { WavRecorder, WavStreamPlayer } from \"../wavtools\";\n\nimport {\n  RTVIClientOptions,\n  RTVIEventCallbacks,\n  Tracks,\n} from \"@pipecat-ai/client-js\";\n\nexport abstract class MediaManager {\n  declare protected _userAudioCallback: (data: ArrayBuffer) => void;\n  declare protected _options: RTVIClientOptions;\n  protected _callbacks: RTVIEventCallbacks = {};\n\n  protected _micEnabled: boolean;\n  protected _camEnabled: boolean;\n\n  constructor() {\n    this._micEnabled = true;\n    this._camEnabled = false;\n  }\n\n  setUserAudioCallback(userAudioCallback: (data: ArrayBuffer) => void) {\n    this._userAudioCallback = userAudioCallback;\n  }\n  setRTVIOptions(options: RTVIClientOptions, override: boolean = false) {\n    if (this._options && !override) return;\n    this._options = options;\n    this._callbacks = options.callbacks ?? {};\n    this._micEnabled = options.enableMic ?? true;\n    this._camEnabled = options.enableCam ?? false;\n  }\n\n  abstract initialize(): Promise<void>;\n  abstract connect(): Promise<void>;\n  abstract disconnect(): Promise<void>;\n\n  abstract userStartedSpeaking(): Promise<unknown>;\n  abstract bufferBotAudio(\n    data: ArrayBuffer | Int16Array,\n    id?: string,\n  ): Int16Array | undefined;\n\n  abstract getAllMics(): Promise<MediaDeviceInfo[]>;\n  abstract getAllCams(): Promise<MediaDeviceInfo[]>;\n  abstract getAllSpeakers(): Promise<MediaDeviceInfo[]>;\n\n  abstract updateMic(micId: string): void;\n  abstract updateCam(camId: string): void;\n  abstract updateSpeaker(speakerId: string): void;\n\n  abstract get selectedMic(): MediaDeviceInfo | Record<string, never>;\n  abstract get selectedCam(): MediaDeviceInfo | Record<string, never>;\n  abstract get selectedSpeaker(): MediaDeviceInfo | Record<string, never>;\n\n  abstract enableMic(enable: boolean): void;\n  abstract enableCam(enable: boolean): void;\n\n  abstract get isCamEnabled(): boolean;\n  abstract get isMicEnabled(): boolean;\n\n  abstract tracks(): Tracks;\n}\n\nexport class WavMediaManager extends MediaManager {\n  private _wavRecorder;\n  private _wavStreamPlayer;\n\n  private _initialized = false;\n  private _recorderChunkSize: number | undefined = undefined;\n\n  constructor(\n    recorderChunkSize: number | undefined = undefined,\n    recorderSampleRate: number | undefined = 24000,\n  ) {\n    super();\n    this._recorderChunkSize = recorderChunkSize;\n    this._wavRecorder = new WavRecorder({ sampleRate: recorderSampleRate });\n    this._wavStreamPlayer = new WavStreamPlayer({ sampleRate: 24000 });\n  }\n\n  async initialize(): Promise<void> {\n    await this._wavRecorder.begin();\n    this._wavRecorder.listenForDeviceChange(null);\n    this._wavRecorder.listenForDeviceChange(\n      this._handleAvailableDevicesUpdated.bind(this),\n    );\n    await this._wavStreamPlayer.connect();\n    this._initialized = true;\n  }\n\n  async connect(): Promise<void> {\n    if (!this._initialized) {\n      await this.initialize();\n    }\n    const isAlreadyRecording = this._wavRecorder.getStatus() == \"recording\";\n    if (this._micEnabled && !isAlreadyRecording) {\n      await this._startRecording();\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    if (!this._initialized) {\n      return;\n    }\n    await this._wavRecorder.end();\n    await this._wavStreamPlayer.interrupt();\n    this._initialized = false;\n  }\n\n  async userStartedSpeaking(): Promise<unknown> {\n    return this._wavStreamPlayer.interrupt();\n  }\n\n  bufferBotAudio(data: ArrayBuffer | Int16Array, id?: string): Int16Array {\n    return this._wavStreamPlayer.add16BitPCM(data, id);\n  }\n\n  getAllMics(): Promise<MediaDeviceInfo[]> {\n    return this._wavRecorder.listDevices();\n  }\n  getAllCams(): Promise<MediaDeviceInfo[]> {\n    // TODO: Video not supported yet\n    return Promise.resolve([]);\n  }\n  getAllSpeakers(): Promise<MediaDeviceInfo[]> {\n    // TODO: Implement speaker support\n    return Promise.resolve([]);\n  }\n\n  async updateMic(micId: string): Promise<void> {\n    const prevMic = this._wavRecorder.deviceSelection;\n    await this._wavRecorder.end();\n    await this._wavRecorder.begin(micId);\n    if (this._micEnabled) {\n      await this._startRecording();\n    }\n    const curMic = this._wavRecorder.deviceSelection;\n    if (curMic && prevMic && prevMic.label !== curMic.label) {\n      this._callbacks.onMicUpdated?.(curMic);\n    }\n  }\n\n  updateCam(camId: string): void {\n    // TODO: Video not supported yet\n  }\n  updateSpeaker(speakerId: string): void {\n    // TODO: Implement speaker support\n  }\n\n  get selectedMic(): MediaDeviceInfo | Record<string, never> {\n    return this._wavRecorder.deviceSelection ?? {};\n  }\n  get selectedCam(): MediaDeviceInfo | Record<string, never> {\n    // TODO: Video not supported yet\n    return {};\n  }\n  get selectedSpeaker(): MediaDeviceInfo | Record<string, never> {\n    // TODO: Implement speaker support\n    return {};\n  }\n\n  async enableMic(enable: boolean): Promise<void> {\n    this._micEnabled = enable;\n    if (!this._wavRecorder.stream) return;\n    this._wavRecorder.stream\n      .getAudioTracks()\n      .forEach((track: MediaStreamTrack) => {\n        track.enabled = enable;\n        if (!enable) {\n          this._callbacks.onTrackStopped?.(track, localParticipant());\n        }\n      });\n    if (enable) {\n      await this._startRecording();\n    } else {\n      await this._wavRecorder.pause();\n    }\n  }\n  enableCam(enable: boolean): void {\n    // TODO: Video not supported yet\n  }\n\n  get isCamEnabled(): boolean {\n    // TODO: Video not supported yet\n    return false;\n  }\n  get isMicEnabled(): boolean {\n    return this._micEnabled;\n  }\n\n  tracks(): Tracks {\n    const tracks = this._wavRecorder.stream?.getTracks()[0];\n    return { local: tracks ? { audio: tracks } : {} };\n  }\n\n  private async _startRecording() {\n    await this._wavRecorder.record((data) => {\n      this._userAudioCallback(data.mono);\n    }, this._recorderChunkSize);\n    const track = this._wavRecorder.stream?.getAudioTracks()[0];\n    if (track) {\n      this._callbacks.onTrackStarted?.(track, localParticipant());\n    }\n  }\n\n  private _handleAvailableDevicesUpdated(devices: MediaDeviceInfo[]) {\n    this._callbacks.onAvailableCamsUpdated?.(\n      devices.filter((d) => d.kind === \"videoinput\"),\n    );\n    this._callbacks.onAvailableMicsUpdated?.(\n      devices.filter((d) => d.kind === \"audioinput\"),\n    );\n    // if the current device went away or we're using the default and\n    // the default changed, reset the mic.\n    const defaultDevice = devices.find((d) => d.deviceId === \"default\");\n    const currentDevice = this._wavRecorder.deviceSelection;\n    if (\n      currentDevice &&\n      (!devices.some((d) => d.deviceId === currentDevice.deviceId) ||\n        (currentDevice.deviceId === \"default\" &&\n          currentDevice.label !== defaultDevice?.label))\n    ) {\n      this.updateMic(\"\");\n    }\n  }\n}\n\nconst localParticipant = () => {\n  return {\n    id: \"local\",\n    name: \"\",\n    local: true,\n  };\n};\n","import { WavPacker } from './lib/wav_packer.js';\nimport { AudioAnalysis } from './lib/analysis/audio_analysis.js';\nimport { WavStreamPlayer } from './lib/wav_stream_player.js';\nimport { WavRecorder } from './lib/wav_recorder.js';\nimport { MediaStreamRecorder } from './lib/mediastream_recorder.js';\n\nexport {\n  AudioAnalysis,\n  MediaStreamRecorder,\n  WavPacker,\n  WavStreamPlayer,\n  WavRecorder,\n};\n","/**\n * Raw wav audio file contents\n * @typedef {Object} WavPackerAudioType\n * @property {Blob} blob\n * @property {string} url\n * @property {number} channelCount\n * @property {number} sampleRate\n * @property {number} duration\n */\n\n/**\n * Utility class for assembling PCM16 \"audio/wav\" data\n * @class\n */\nexport class WavPacker {\n  /**\n   * Converts Float32Array of amplitude data to ArrayBuffer in Int16Array format\n   * @param {Float32Array} float32Array\n   * @returns {ArrayBuffer}\n   */\n  static floatTo16BitPCM(float32Array) {\n    const buffer = new ArrayBuffer(float32Array.length * 2);\n    const view = new DataView(buffer);\n    let offset = 0;\n    for (let i = 0; i < float32Array.length; i++, offset += 2) {\n      let s = Math.max(-1, Math.min(1, float32Array[i]));\n      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n    }\n    return buffer;\n  }\n\n  /**\n   * Concatenates two ArrayBuffers\n   * @param {ArrayBuffer} leftBuffer\n   * @param {ArrayBuffer} rightBuffer\n   * @returns {ArrayBuffer}\n   */\n  static mergeBuffers(leftBuffer, rightBuffer) {\n    const tmpArray = new Uint8Array(\n      leftBuffer.byteLength + rightBuffer.byteLength\n    );\n    tmpArray.set(new Uint8Array(leftBuffer), 0);\n    tmpArray.set(new Uint8Array(rightBuffer), leftBuffer.byteLength);\n    return tmpArray.buffer;\n  }\n\n  /**\n   * Packs data into an Int16 format\n   * @private\n   * @param {number} size 0 = 1x Int16, 1 = 2x Int16\n   * @param {number} arg value to pack\n   * @returns\n   */\n  _packData(size, arg) {\n    return [\n      new Uint8Array([arg, arg >> 8]),\n      new Uint8Array([arg, arg >> 8, arg >> 16, arg >> 24]),\n    ][size];\n  }\n\n  /**\n   * Packs audio into \"audio/wav\" Blob\n   * @param {number} sampleRate\n   * @param {{bitsPerSample: number, channels: Array<Float32Array>, data: Int16Array}} audio\n   * @returns {WavPackerAudioType}\n   */\n  pack(sampleRate, audio) {\n    if (!audio?.bitsPerSample) {\n      throw new Error(`Missing \"bitsPerSample\"`);\n    } else if (!audio?.channels) {\n      throw new Error(`Missing \"channels\"`);\n    } else if (!audio?.data) {\n      throw new Error(`Missing \"data\"`);\n    }\n    const { bitsPerSample, channels, data } = audio;\n    const output = [\n      // Header\n      'RIFF',\n      this._packData(\n        1,\n        4 + (8 + 24) /* chunk 1 length */ + (8 + 8) /* chunk 2 length */\n      ), // Length\n      'WAVE',\n      // chunk 1\n      'fmt ', // Sub-chunk identifier\n      this._packData(1, 16), // Chunk length\n      this._packData(0, 1), // Audio format (1 is linear quantization)\n      this._packData(0, channels.length),\n      this._packData(1, sampleRate),\n      this._packData(1, (sampleRate * channels.length * bitsPerSample) / 8), // Byte rate\n      this._packData(0, (channels.length * bitsPerSample) / 8),\n      this._packData(0, bitsPerSample),\n      // chunk 2\n      'data', // Sub-chunk identifier\n      this._packData(\n        1,\n        (channels[0].length * channels.length * bitsPerSample) / 8\n      ), // Chunk length\n      data,\n    ];\n    const blob = new Blob(output, { type: 'audio/mpeg' });\n    const url = URL.createObjectURL(blob);\n    return {\n      blob,\n      url,\n      channelCount: channels.length,\n      sampleRate,\n      duration: data.byteLength / (channels.length * sampleRate * 2),\n    };\n  }\n}\n\nglobalThis.WavPacker = WavPacker;\n","import {\n  noteFrequencies,\n  noteFrequencyLabels,\n  voiceFrequencies,\n  voiceFrequencyLabels,\n} from './constants.js';\n\n/**\n * Output of AudioAnalysis for the frequency domain of the audio\n * @typedef {Object} AudioAnalysisOutputType\n * @property {Float32Array} values Amplitude of this frequency between {0, 1} inclusive\n * @property {number[]} frequencies Raw frequency bucket values\n * @property {string[]} labels Labels for the frequency bucket values\n */\n\n/**\n * Analyzes audio for visual output\n * @class\n */\nexport class AudioAnalysis {\n  /**\n   * Retrieves frequency domain data from an AnalyserNode adjusted to a decibel range\n   * returns human-readable formatting and labels\n   * @param {AnalyserNode} analyser\n   * @param {number} sampleRate\n   * @param {Float32Array} [fftResult]\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {AudioAnalysisOutputType}\n   */\n  static getFrequencies(\n    analyser,\n    sampleRate,\n    fftResult,\n    analysisType = 'frequency',\n    minDecibels = -100,\n    maxDecibels = -30,\n  ) {\n    if (!fftResult) {\n      fftResult = new Float32Array(analyser.frequencyBinCount);\n      analyser.getFloatFrequencyData(fftResult);\n    }\n    const nyquistFrequency = sampleRate / 2;\n    const frequencyStep = (1 / fftResult.length) * nyquistFrequency;\n    let outputValues;\n    let frequencies;\n    let labels;\n    if (analysisType === 'music' || analysisType === 'voice') {\n      const useFrequencies =\n        analysisType === 'voice' ? voiceFrequencies : noteFrequencies;\n      const aggregateOutput = Array(useFrequencies.length).fill(minDecibels);\n      for (let i = 0; i < fftResult.length; i++) {\n        const frequency = i * frequencyStep;\n        const amplitude = fftResult[i];\n        for (let n = useFrequencies.length - 1; n >= 0; n--) {\n          if (frequency > useFrequencies[n]) {\n            aggregateOutput[n] = Math.max(aggregateOutput[n], amplitude);\n            break;\n          }\n        }\n      }\n      outputValues = aggregateOutput;\n      frequencies =\n        analysisType === 'voice' ? voiceFrequencies : noteFrequencies;\n      labels =\n        analysisType === 'voice' ? voiceFrequencyLabels : noteFrequencyLabels;\n    } else {\n      outputValues = Array.from(fftResult);\n      frequencies = outputValues.map((_, i) => frequencyStep * i);\n      labels = frequencies.map((f) => `${f.toFixed(2)} Hz`);\n    }\n    // We normalize to {0, 1}\n    const normalizedOutput = outputValues.map((v) => {\n      return Math.max(\n        0,\n        Math.min((v - minDecibels) / (maxDecibels - minDecibels), 1),\n      );\n    });\n    const values = new Float32Array(normalizedOutput);\n    return {\n      values,\n      frequencies,\n      labels,\n    };\n  }\n\n  /**\n   * Creates a new AudioAnalysis instance for an HTMLAudioElement\n   * @param {HTMLAudioElement} audioElement\n   * @param {AudioBuffer|null} [audioBuffer] If provided, will cache all frequency domain data from the buffer\n   * @returns {AudioAnalysis}\n   */\n  constructor(audioElement, audioBuffer = null) {\n    this.fftResults = [];\n    if (audioBuffer) {\n      /**\n       * Modified from\n       * https://stackoverflow.com/questions/75063715/using-the-web-audio-api-to-analyze-a-song-without-playing\n       *\n       * We do this to populate FFT values for the audio if provided an `audioBuffer`\n       * The reason to do this is that Safari fails when using `createMediaElementSource`\n       * This has a non-zero RAM cost so we only opt-in to run it on Safari, Chrome is better\n       */\n      const { length, sampleRate } = audioBuffer;\n      const offlineAudioContext = new OfflineAudioContext({\n        length,\n        sampleRate,\n      });\n      const source = offlineAudioContext.createBufferSource();\n      source.buffer = audioBuffer;\n      const analyser = offlineAudioContext.createAnalyser();\n      analyser.fftSize = 8192;\n      analyser.smoothingTimeConstant = 0.1;\n      source.connect(analyser);\n      // limit is :: 128 / sampleRate;\n      // but we just want 60fps - cuts ~1s from 6MB to 1MB of RAM\n      const renderQuantumInSeconds = 1 / 60;\n      const durationInSeconds = length / sampleRate;\n      const analyze = (index) => {\n        const suspendTime = renderQuantumInSeconds * index;\n        if (suspendTime < durationInSeconds) {\n          offlineAudioContext.suspend(suspendTime).then(() => {\n            const fftResult = new Float32Array(analyser.frequencyBinCount);\n            analyser.getFloatFrequencyData(fftResult);\n            this.fftResults.push(fftResult);\n            analyze(index + 1);\n          });\n        }\n        if (index === 1) {\n          offlineAudioContext.startRendering();\n        } else {\n          offlineAudioContext.resume();\n        }\n      };\n      source.start(0);\n      analyze(1);\n      this.audio = audioElement;\n      this.context = offlineAudioContext;\n      this.analyser = analyser;\n      this.sampleRate = sampleRate;\n      this.audioBuffer = audioBuffer;\n    } else {\n      const audioContext = new AudioContext();\n      const track = audioContext.createMediaElementSource(audioElement);\n      const analyser = audioContext.createAnalyser();\n      analyser.fftSize = 8192;\n      analyser.smoothingTimeConstant = 0.1;\n      track.connect(analyser);\n      analyser.connect(audioContext.destination);\n      this.audio = audioElement;\n      this.context = audioContext;\n      this.analyser = analyser;\n      this.sampleRate = this.context.sampleRate;\n      this.audioBuffer = null;\n    }\n  }\n\n  /**\n   * Gets the current frequency domain data from the playing audio track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {AudioAnalysisOutputType}\n   */\n  getFrequencies(\n    analysisType = 'frequency',\n    minDecibels = -100,\n    maxDecibels = -30,\n  ) {\n    let fftResult = null;\n    if (this.audioBuffer && this.fftResults.length) {\n      const pct = this.audio.currentTime / this.audio.duration;\n      const index = Math.min(\n        (pct * this.fftResults.length) | 0,\n        this.fftResults.length - 1,\n      );\n      fftResult = this.fftResults[index];\n    }\n    return AudioAnalysis.getFrequencies(\n      this.analyser,\n      this.sampleRate,\n      fftResult,\n      analysisType,\n      minDecibels,\n      maxDecibels,\n    );\n  }\n\n  /**\n   * Resume the internal AudioContext if it was suspended due to the lack of\n   * user interaction when the AudioAnalysis was instantiated.\n   * @returns {Promise<true>}\n   */\n  async resumeIfSuspended() {\n    if (this.context.state === 'suspended') {\n      await this.context.resume();\n    }\n    return true;\n  }\n}\n\nglobalThis.AudioAnalysis = AudioAnalysis;\n","/**\n * Constants for help with visualization\n * Helps map frequency ranges from Fast Fourier Transform\n * to human-interpretable ranges, notably music ranges and\n * human vocal ranges.\n */\n\n// Eighth octave frequencies\nconst octave8Frequencies = [\n  4186.01, 4434.92, 4698.63, 4978.03, 5274.04, 5587.65, 5919.91, 6271.93,\n  6644.88, 7040.0, 7458.62, 7902.13,\n];\n\n// Labels for each of the above frequencies\nconst octave8FrequencyLabels = [\n  'C',\n  'C#',\n  'D',\n  'D#',\n  'E',\n  'F',\n  'F#',\n  'G',\n  'G#',\n  'A',\n  'A#',\n  'B',\n];\n\n/**\n * All note frequencies from 1st to 8th octave\n * in format \"A#8\" (A#, 8th octave)\n */\nexport const noteFrequencies = [];\nexport const noteFrequencyLabels = [];\nfor (let i = 1; i <= 8; i++) {\n  for (let f = 0; f < octave8Frequencies.length; f++) {\n    const freq = octave8Frequencies[f];\n    noteFrequencies.push(freq / Math.pow(2, 8 - i));\n    noteFrequencyLabels.push(octave8FrequencyLabels[f] + i);\n  }\n}\n\n/**\n * Subset of the note frequencies between 32 and 2000 Hz\n * 6 octave range: C1 to B6\n */\nconst voiceFrequencyRange = [32.0, 2000.0];\nexport const voiceFrequencies = noteFrequencies.filter((_, i) => {\n  return (\n    noteFrequencies[i] > voiceFrequencyRange[0] &&\n    noteFrequencies[i] < voiceFrequencyRange[1]\n  );\n});\nexport const voiceFrequencyLabels = noteFrequencyLabels.filter((_, i) => {\n  return (\n    noteFrequencies[i] > voiceFrequencyRange[0] &&\n    noteFrequencies[i] < voiceFrequencyRange[1]\n  );\n});\n","import { StreamProcessorSrc } from \"./worklets/stream_processor.js\";\nimport { AudioAnalysis } from \"./analysis/audio_analysis.js\";\n\n/**\n * Plays audio streams received in raw PCM16 chunks from the browser\n * @class\n */\nexport class WavStreamPlayer {\n  /**\n   * Creates a new WavStreamPlayer instance\n   * @param {{sampleRate?: number}} options\n   * @returns {WavStreamPlayer}\n   */\n  constructor({ sampleRate = 44100 } = {}) {\n    this.scriptSrc = StreamProcessorSrc;\n    this.sampleRate = sampleRate;\n    this.context = null;\n    this.stream = null;\n    this.analyser = null;\n    this.trackSampleOffsets = {};\n    this.interruptedTrackIds = {};\n  }\n\n  /**\n   * Connects the audio context and enables output to speakers\n   * @returns {Promise<true>}\n   */\n  async connect() {\n    this.context = new AudioContext({ sampleRate: this.sampleRate });\n    if (this._speakerID) {\n      this.context.setSinkId(this._speakerID);\n    }\n    if (this.context.state === \"suspended\") {\n      await this.context.resume();\n    }\n    try {\n      await this.context.audioWorklet.addModule(this.scriptSrc);\n    } catch (e) {\n      console.error(e);\n      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);\n    }\n    const analyser = this.context.createAnalyser();\n    analyser.fftSize = 8192;\n    analyser.smoothingTimeConstant = 0.1;\n    this.analyser = analyser;\n    return true;\n  }\n\n  /**\n   * Gets the current frequency domain data from the playing track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}\n   */\n  getFrequencies(\n    analysisType = \"frequency\",\n    minDecibels = -100,\n    maxDecibels = -30\n  ) {\n    if (!this.analyser) {\n      throw new Error(\"Not connected, please call .connect() first\");\n    }\n    return AudioAnalysis.getFrequencies(\n      this.analyser,\n      this.sampleRate,\n      null,\n      analysisType,\n      minDecibels,\n      maxDecibels\n    );\n  }\n\n  /**\n   * @param {string} speaker deviceId\n   */\n  async updateSpeaker(speaker) {\n    const _prevSpeaker = this._speakerID;\n    this._speakerID = speaker;\n    if (this.context) {\n      try {\n        if (speaker === \"default\") {\n          await this.context.setSinkId();\n        } else {\n          await this.context.setSinkId(speaker);\n        }\n      } catch (e) {\n        console.error(`Could not set sinkId to ${speaker}: ${e}`);\n        this._speakerID = _prevSpeaker;\n      }\n    }\n  }\n\n  /**\n   * Starts audio streaming\n   * @private\n   * @returns {Promise<true>}\n   */\n  _start() {\n    const streamNode = new AudioWorkletNode(this.context, \"stream_processor\");\n    streamNode.connect(this.context.destination);\n    streamNode.port.onmessage = (e) => {\n      const { event } = e.data;\n      if (event === \"stop\") {\n        streamNode.disconnect();\n        this.stream = null;\n      } else if (event === \"offset\") {\n        const { requestId, trackId, offset } = e.data;\n        const currentTime = offset / this.sampleRate;\n        this.trackSampleOffsets[requestId] = { trackId, offset, currentTime };\n      }\n    };\n    this.analyser.disconnect();\n    streamNode.connect(this.analyser);\n    this.stream = streamNode;\n    return true;\n  }\n\n  /**\n   * Adds 16BitPCM data to the currently playing audio stream\n   * You can add chunks beyond the current play point and they will be queued for play\n   * @param {ArrayBuffer|Int16Array} arrayBuffer\n   * @param {string} [trackId]\n   * @returns {Int16Array}\n   */\n  add16BitPCM(arrayBuffer, trackId = \"default\") {\n    if (typeof trackId !== \"string\") {\n      throw new Error(`trackId must be a string`);\n    } else if (this.interruptedTrackIds[trackId]) {\n      return;\n    }\n    if (!this.stream) {\n      this._start();\n    }\n    let buffer;\n    if (arrayBuffer instanceof Int16Array) {\n      buffer = arrayBuffer;\n    } else if (arrayBuffer instanceof ArrayBuffer) {\n      buffer = new Int16Array(arrayBuffer);\n    } else {\n      throw new Error(`argument must be Int16Array or ArrayBuffer`);\n    }\n    this.stream.port.postMessage({ event: \"write\", buffer, trackId });\n    return buffer;\n  }\n\n  /**\n   * Gets the offset (sample count) of the currently playing stream\n   * @param {boolean} [interrupt]\n   * @returns {{trackId: string|null, offset: number, currentTime: number}}\n   */\n  async getTrackSampleOffset(interrupt = false) {\n    if (!this.stream) {\n      return null;\n    }\n    const requestId = crypto.randomUUID();\n    this.stream.port.postMessage({\n      event: interrupt ? \"interrupt\" : \"offset\",\n      requestId,\n    });\n    let trackSampleOffset;\n    while (!trackSampleOffset) {\n      trackSampleOffset = this.trackSampleOffsets[requestId];\n      await new Promise((r) => setTimeout(() => r(), 1));\n    }\n    const { trackId } = trackSampleOffset;\n    if (interrupt && trackId) {\n      this.interruptedTrackIds[trackId] = true;\n    }\n    return trackSampleOffset;\n  }\n\n  /**\n   * Strips the current stream and returns the sample offset of the audio\n   * @param {boolean} [interrupt]\n   * @returns {{trackId: string|null, offset: number, currentTime: number}}\n   */\n  async interrupt() {\n    return this.getTrackSampleOffset(true);\n  }\n}\n\nglobalThis.WavStreamPlayer = WavStreamPlayer;\n","export const StreamProcessorWorklet = `\nclass StreamProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.hasStarted = false;\n    this.hasInterrupted = false;\n    this.outputBuffers = [];\n    this.bufferLength = 128;\n    this.write = { buffer: new Float32Array(this.bufferLength), trackId: null };\n    this.writeOffset = 0;\n    this.trackSampleOffsets = {};\n    this.port.onmessage = (event) => {\n      if (event.data) {\n        const payload = event.data;\n        if (payload.event === 'write') {\n          const int16Array = payload.buffer;\n          const float32Array = new Float32Array(int16Array.length);\n          for (let i = 0; i < int16Array.length; i++) {\n            float32Array[i] = int16Array[i] / 0x8000; // Convert Int16 to Float32\n          }\n          this.writeData(float32Array, payload.trackId);\n        } else if (\n          payload.event === 'offset' ||\n          payload.event === 'interrupt'\n        ) {\n          const requestId = payload.requestId;\n          const trackId = this.write.trackId;\n          const offset = this.trackSampleOffsets[trackId] || 0;\n          this.port.postMessage({\n            event: 'offset',\n            requestId,\n            trackId,\n            offset,\n          });\n          if (payload.event === 'interrupt') {\n            this.hasInterrupted = true;\n          }\n        } else {\n          throw new Error(\\`Unhandled event \"\\${payload.event}\"\\`);\n        }\n      }\n    };\n  }\n\n  writeData(float32Array, trackId = null) {\n    let { buffer } = this.write;\n    let offset = this.writeOffset;\n    for (let i = 0; i < float32Array.length; i++) {\n      buffer[offset++] = float32Array[i];\n      if (offset >= buffer.length) {\n        this.outputBuffers.push(this.write);\n        this.write = { buffer: new Float32Array(this.bufferLength), trackId };\n        buffer = this.write.buffer;\n        offset = 0;\n      }\n    }\n    this.writeOffset = offset;\n    return true;\n  }\n\n  process(inputs, outputs, parameters) {\n    const output = outputs[0];\n    const outputChannelData = output[0];\n    const outputBuffers = this.outputBuffers;\n    if (this.hasInterrupted) {\n      this.port.postMessage({ event: 'stop' });\n      return false;\n    } else if (outputBuffers.length) {\n      this.hasStarted = true;\n      const { buffer, trackId } = outputBuffers.shift();\n      for (let i = 0; i < outputChannelData.length; i++) {\n        outputChannelData[i] = buffer[i] || 0;\n      }\n      if (trackId) {\n        this.trackSampleOffsets[trackId] =\n          this.trackSampleOffsets[trackId] || 0;\n        this.trackSampleOffsets[trackId] += buffer.length;\n      }\n      return true;\n    } else if (this.hasStarted) {\n      this.port.postMessage({ event: 'stop' });\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n\nregisterProcessor('stream_processor', StreamProcessor);\n`;\n\nconst script = new Blob([StreamProcessorWorklet], {\n  type: 'application/javascript',\n});\nconst src = URL.createObjectURL(script);\nexport const StreamProcessorSrc = src;\n","import { AudioProcessorSrc } from './worklets/audio_processor.js';\nimport { AudioAnalysis } from './analysis/audio_analysis.js';\nimport { WavPacker } from './wav_packer.js';\n\n/**\n * Decodes audio into a wav file\n * @typedef {Object} DecodedAudioType\n * @property {Blob} blob\n * @property {string} url\n * @property {Float32Array} values\n * @property {AudioBuffer} audioBuffer\n */\n\n/**\n * Records live stream of user audio as PCM16 \"audio/wav\" data\n * @class\n */\nexport class WavRecorder {\n  /**\n   * Create a new WavRecorder instance\n   * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]\n   * @returns {WavRecorder}\n   */\n  constructor({\n    sampleRate = 44100,\n    outputToSpeakers = false,\n    debug = false,\n  } = {}) {\n    // Script source\n    this.scriptSrc = AudioProcessorSrc;\n    // Config\n    this.sampleRate = sampleRate;\n    this.outputToSpeakers = outputToSpeakers;\n    this.debug = !!debug;\n    this._deviceChangeCallback = null;\n    this._devices = [];\n    this.deviceSelection = null;\n    // State variables\n    this.stream = null;\n    this.processor = null;\n    this.source = null;\n    this.node = null;\n    this.recording = false;\n    // Event handling with AudioWorklet\n    this._lastEventId = 0;\n    this.eventReceipts = {};\n    this.eventTimeout = 5000;\n    // Process chunks of audio\n    this._chunkProcessor = () => {};\n    this._chunkProcessorSize = void 0;\n    this._chunkProcessorBuffer = {\n      raw: new ArrayBuffer(0),\n      mono: new ArrayBuffer(0),\n    };\n  }\n\n  /**\n   * Decodes audio data from multiple formats to a Blob, url, Float32Array and AudioBuffer\n   * @param {Blob|Float32Array|Int16Array|ArrayBuffer|number[]} audioData\n   * @param {number} sampleRate\n   * @param {number} fromSampleRate\n   * @returns {Promise<DecodedAudioType>}\n   */\n  static async decode(audioData, sampleRate = 44100, fromSampleRate = -1) {\n    const context = new AudioContext({ sampleRate });\n    let arrayBuffer;\n    let blob;\n    if (audioData instanceof Blob) {\n      if (fromSampleRate !== -1) {\n        throw new Error(\n          `Can not specify \"fromSampleRate\" when reading from Blob`\n        );\n      }\n      blob = audioData;\n      arrayBuffer = await blob.arrayBuffer();\n    } else if (audioData instanceof ArrayBuffer) {\n      if (fromSampleRate !== -1) {\n        throw new Error(\n          `Can not specify \"fromSampleRate\" when reading from ArrayBuffer`\n        );\n      }\n      arrayBuffer = audioData;\n      blob = new Blob([arrayBuffer], { type: 'audio/wav' });\n    } else {\n      let float32Array;\n      let data;\n      if (audioData instanceof Int16Array) {\n        data = audioData;\n        float32Array = new Float32Array(audioData.length);\n        for (let i = 0; i < audioData.length; i++) {\n          float32Array[i] = audioData[i] / 0x8000;\n        }\n      } else if (audioData instanceof Float32Array) {\n        float32Array = audioData;\n      } else if (audioData instanceof Array) {\n        float32Array = new Float32Array(audioData);\n      } else {\n        throw new Error(\n          `\"audioData\" must be one of: Blob, Float32Arrray, Int16Array, ArrayBuffer, Array<number>`\n        );\n      }\n      if (fromSampleRate === -1) {\n        throw new Error(\n          `Must specify \"fromSampleRate\" when reading from Float32Array, In16Array or Array`\n        );\n      } else if (fromSampleRate < 3000) {\n        throw new Error(`Minimum \"fromSampleRate\" is 3000 (3kHz)`);\n      }\n      if (!data) {\n        data = WavPacker.floatTo16BitPCM(float32Array);\n      }\n      const audio = {\n        bitsPerSample: 16,\n        channels: [float32Array],\n        data,\n      };\n      const packer = new WavPacker();\n      const result = packer.pack(fromSampleRate, audio);\n      blob = result.blob;\n      arrayBuffer = await blob.arrayBuffer();\n    }\n    const audioBuffer = await context.decodeAudioData(arrayBuffer);\n    const values = audioBuffer.getChannelData(0);\n    const url = URL.createObjectURL(blob);\n    return {\n      blob,\n      url,\n      values,\n      audioBuffer,\n    };\n  }\n\n  /**\n   * Logs data in debug mode\n   * @param {...any} arguments\n   * @returns {true}\n   */\n  log() {\n    if (this.debug) {\n      this.log(...arguments);\n    }\n    return true;\n  }\n\n  /**\n   * Retrieves the current sampleRate for the recorder\n   * @returns {number}\n   */\n  getSampleRate() {\n    return this.sampleRate;\n  }\n\n  /**\n   * Retrieves the current status of the recording\n   * @returns {\"ended\"|\"paused\"|\"recording\"}\n   */\n  getStatus() {\n    if (!this.processor) {\n      return 'ended';\n    } else if (!this.recording) {\n      return 'paused';\n    } else {\n      return 'recording';\n    }\n  }\n\n  /**\n   * Sends an event to the AudioWorklet\n   * @private\n   * @param {string} name\n   * @param {{[key: string]: any}} data\n   * @param {AudioWorkletNode} [_processor]\n   * @returns {Promise<{[key: string]: any}>}\n   */\n  async _event(name, data = {}, _processor = null) {\n    _processor = _processor || this.processor;\n    if (!_processor) {\n      throw new Error('Can not send events without recording first');\n    }\n    const message = {\n      event: name,\n      id: this._lastEventId++,\n      data,\n    };\n    _processor.port.postMessage(message);\n    const t0 = new Date().valueOf();\n    while (!this.eventReceipts[message.id]) {\n      if (new Date().valueOf() - t0 > this.eventTimeout) {\n        throw new Error(`Timeout waiting for \"${name}\" event`);\n      }\n      await new Promise((res) => setTimeout(() => res(true), 1));\n    }\n    const payload = this.eventReceipts[message.id];\n    delete this.eventReceipts[message.id];\n    return payload;\n  }\n\n  /**\n   * Sets device change callback, remove if callback provided is `null`\n   * @param {(Array<MediaDeviceInfo & {default: boolean}>): void|null} callback\n   * @returns {true}\n   */\n  listenForDeviceChange(callback) {\n    if (callback === null && this._deviceChangeCallback) {\n      navigator.mediaDevices.removeEventListener(\n        'devicechange',\n        this._deviceChangeCallback\n      );\n      this._deviceChangeCallback = null;\n    } else if (callback !== null) {\n      // Basically a debounce; we only want this called once when devices change\n      // And we only want the most recent callback() to be executed\n      // if a few are operating at the same time\n      let lastId = 0;\n      let lastDevices = [];\n      const serializeDevices = (devices) =>\n        devices\n          .map((d) => d.deviceId)\n          .sort()\n          .join(',');\n      const cb = async () => {\n        let id = ++lastId;\n        const devices = await this.listDevices();\n        if (id === lastId) {\n          if (serializeDevices(lastDevices) !== serializeDevices(devices)) {\n            lastDevices = devices;\n            callback(devices.slice());\n          }\n        }\n      };\n      navigator.mediaDevices.addEventListener('devicechange', cb);\n      cb();\n      this._deviceChangeCallback = cb;\n    }\n    return true;\n  }\n\n  /**\n   * Manually request permission to use the microphone\n   * @returns {Promise<true>}\n   */\n  async requestPermission() {\n    const permissionStatus = await navigator.permissions.query({\n      name: 'microphone',\n    });\n    if (permissionStatus.state === 'denied') {\n      window.alert('You must grant microphone access to use this feature.');\n    } else if (permissionStatus.state === 'prompt') {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: true,\n        });\n        const tracks = stream.getTracks();\n        tracks.forEach((track) => track.stop());\n      } catch (e) {\n        window.alert('You must grant microphone access to use this feature.');\n      }\n    }\n    return true;\n  }\n\n  /**\n   * List all eligible devices for recording, will request permission to use microphone\n   * @returns {Promise<Array<MediaDeviceInfo & {default: boolean}>>}\n   */\n  async listDevices() {\n    if (\n      !navigator.mediaDevices ||\n      !('enumerateDevices' in navigator.mediaDevices)\n    ) {\n      throw new Error('Could not request user devices');\n    }\n    await this.requestPermission();\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const audioDevices = devices.filter(\n      (device) => device.kind === 'audioinput'\n    );\n    return audioDevices;\n    // const defaultDeviceIndex = audioDevices.findIndex(\n    //   (device) => device.deviceId === 'default'\n    // );\n    // const deviceList = [];\n    // if (defaultDeviceIndex !== -1) {\n    //   let defaultDevice = audioDevices.splice(defaultDeviceIndex, 1)[0];\n    //   let existingIndex = audioDevices.findIndex(\n    //     (device) => device.groupId === defaultDevice.groupId\n    //   );\n    //   if (existingIndex !== -1) {\n    //     defaultDevice = audioDevices.splice(existingIndex, 1)[0];\n    //   }\n    //   defaultDevice.default = true;\n    //   deviceList.push(defaultDevice);\n    // }\n    // return deviceList.concat(audioDevices);\n  }\n\n  /**\n   * Begins a recording session and requests microphone permissions if not already granted\n   * Microphone recording indicator will appear on browser tab but status will be \"paused\"\n   * @param {string} [deviceId] if no device provided, default device will be used\n   * @returns {Promise<true>}\n   */\n  async begin(deviceId) {\n    if (this.processor) {\n      throw new Error(\n        `Already connected: please call .end() to start a new session`\n      );\n    }\n\n    if (\n      !navigator.mediaDevices ||\n      !('getUserMedia' in navigator.mediaDevices)\n    ) {\n      throw new Error('Could not request user media');\n    }\n    deviceId = deviceId ?? this.deviceSelection?.deviceId;\n    try {\n      const config = { audio: true };\n      if (deviceId) {\n        config.audio = { deviceId: { exact: deviceId } };\n      }\n      this.stream = await navigator.mediaDevices.getUserMedia(config);\n    } catch (err) {\n      throw new Error('Could not start media stream');\n    }\n\n    this.listDevices().then((devices) => {\n      deviceId = this.stream.getAudioTracks()[0].getSettings().deviceId;\n      console.log(\n        'find current device',\n        devices,\n        deviceId,\n        this.stream.getAudioTracks()[0].getSettings()\n      );\n      this.deviceSelection = devices.find((d) => d.deviceId === deviceId);\n      console.log('current device', this.deviceSelection);\n    });\n    const context = new AudioContext({ sampleRate: this.sampleRate });\n    const source = context.createMediaStreamSource(this.stream);\n    // Load and execute the module script.\n    try {\n      await context.audioWorklet.addModule(this.scriptSrc);\n    } catch (e) {\n      console.error(e);\n      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);\n    }\n    const processor = new AudioWorkletNode(context, 'audio_processor');\n    processor.port.onmessage = (e) => {\n      const { event, id, data } = e.data;\n      if (event === 'receipt') {\n        this.eventReceipts[id] = data;\n      } else if (event === 'chunk') {\n        if (this._chunkProcessorSize) {\n          const buffer = this._chunkProcessorBuffer;\n          this._chunkProcessorBuffer = {\n            raw: WavPacker.mergeBuffers(buffer.raw, data.raw),\n            mono: WavPacker.mergeBuffers(buffer.mono, data.mono),\n          };\n          if (\n            this._chunkProcessorBuffer.mono.byteLength >=\n            this._chunkProcessorSize\n          ) {\n            this._chunkProcessor(this._chunkProcessorBuffer);\n            this._chunkProcessorBuffer = {\n              raw: new ArrayBuffer(0),\n              mono: new ArrayBuffer(0),\n            };\n          }\n        } else {\n          this._chunkProcessor(data);\n        }\n      }\n    };\n\n    const node = source.connect(processor);\n    const analyser = context.createAnalyser();\n    analyser.fftSize = 8192;\n    analyser.smoothingTimeConstant = 0.1;\n    node.connect(analyser);\n    if (this.outputToSpeakers) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'Warning: Output to speakers may affect sound quality,\\n' +\n          'especially due to system audio feedback preventative measures.\\n' +\n          'use only for debugging'\n      );\n      analyser.connect(context.destination);\n    }\n\n    this.source = source;\n    this.node = node;\n    this.analyser = analyser;\n    this.processor = processor;\n    console.log('begin completed');\n    return true;\n  }\n\n  /**\n   * Gets the current frequency domain data from the recording track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}\n   */\n  getFrequencies(\n    analysisType = 'frequency',\n    minDecibels = -100,\n    maxDecibels = -30\n  ) {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    return AudioAnalysis.getFrequencies(\n      this.analyser,\n      this.sampleRate,\n      null,\n      analysisType,\n      minDecibels,\n      maxDecibels\n    );\n  }\n\n  /**\n   * Pauses the recording\n   * Keeps microphone stream open but halts storage of audio\n   * @returns {Promise<true>}\n   */\n  async pause() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    } else if (!this.recording) {\n      throw new Error('Already paused: please call .record() first');\n    }\n    if (this._chunkProcessorBuffer.raw.byteLength) {\n      this._chunkProcessor(this._chunkProcessorBuffer);\n    }\n    this.log('Pausing ...');\n    await this._event('stop');\n    this.recording = false;\n    return true;\n  }\n\n  /**\n   * Start recording stream and storing to memory from the connected audio source\n   * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]\n   * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio\n   * @returns {Promise<true>}\n   */\n  async record(chunkProcessor = () => {}, chunkSize = 8192) {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    } else if (this.recording) {\n      throw new Error('Already recording: please call .pause() first');\n    } else if (typeof chunkProcessor !== 'function') {\n      throw new Error(`chunkProcessor must be a function`);\n    }\n    this._chunkProcessor = chunkProcessor;\n    this._chunkProcessorSize = chunkSize;\n    this._chunkProcessorBuffer = {\n      raw: new ArrayBuffer(0),\n      mono: new ArrayBuffer(0),\n    };\n    this.log('Recording ...');\n    await this._event('start');\n    this.recording = true;\n    return true;\n  }\n\n  /**\n   * Clears the audio buffer, empties stored recording\n   * @returns {Promise<true>}\n   */\n  async clear() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    await this._event('clear');\n    return true;\n  }\n\n  /**\n   * Reads the current audio stream data\n   * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}\n   */\n  async read() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    this.log('Reading ...');\n    const result = await this._event('read');\n    return result;\n  }\n\n  /**\n   * Saves the current audio stream to a file\n   * @param {boolean} [force] Force saving while still recording\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */\n  async save(force = false) {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    if (!force && this.recording) {\n      throw new Error(\n        'Currently recording: please call .pause() first, or call .save(true) to force'\n      );\n    }\n    this.log('Exporting ...');\n    const exportData = await this._event('export');\n    const packer = new WavPacker();\n    const result = packer.pack(this.sampleRate, exportData.audio);\n    return result;\n  }\n\n  /**\n   * Ends the current recording session and saves the result\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */\n  async end() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n\n    const _processor = this.processor;\n\n    this.log('Stopping ...');\n    await this._event('stop');\n    this.recording = false;\n    const tracks = this.stream.getTracks();\n    tracks.forEach((track) => track.stop());\n\n    this.log('Exporting ...');\n    const exportData = await this._event('export', {}, _processor);\n\n    this.processor.disconnect();\n    this.source.disconnect();\n    this.node.disconnect();\n    this.analyser.disconnect();\n    this.stream = null;\n    this.processor = null;\n    this.source = null;\n    this.node = null;\n\n    const packer = new WavPacker();\n    const result = packer.pack(this.sampleRate, exportData.audio);\n    return result;\n  }\n\n  /**\n   * Performs a full cleanup of WavRecorder instance\n   * Stops actively listening via microphone and removes existing listeners\n   * @returns {Promise<true>}\n   */\n  async quit() {\n    this.listenForDeviceChange(null);\n    // we do not reset this on end so that selections persist across starts\n    this.deviceSelection = null;\n    if (this.processor) {\n      await this.end();\n    }\n    return true;\n  }\n}\n\nglobalThis.WavRecorder = WavRecorder;\n","const AudioProcessorWorklet = `\nclass AudioProcessor extends AudioWorkletProcessor {\n\n  constructor() {\n    super();\n    this.port.onmessage = this.receive.bind(this);\n    this.initialize();\n  }\n\n  initialize() {\n    this.foundAudio = false;\n    this.recording = false;\n    this.chunks = [];\n  }\n\n  /**\n   * Concatenates sampled chunks into channels\n   * Format is chunk[Left[], Right[]]\n   */\n  readChannelData(chunks, channel = -1, maxChannels = 9) {\n    let channelLimit;\n    if (channel !== -1) {\n      if (chunks[0] && chunks[0].length - 1 < channel) {\n        throw new Error(\n          \\`Channel \\${channel} out of range: max \\${chunks[0].length}\\`\n        );\n      }\n      channelLimit = channel + 1;\n    } else {\n      channel = 0;\n      channelLimit = Math.min(chunks[0] ? chunks[0].length : 1, maxChannels);\n    }\n    const channels = [];\n    for (let n = channel; n < channelLimit; n++) {\n      const length = chunks.reduce((sum, chunk) => {\n        return sum + chunk[n].length;\n      }, 0);\n      const buffers = chunks.map((chunk) => chunk[n]);\n      const result = new Float32Array(length);\n      let offset = 0;\n      for (let i = 0; i < buffers.length; i++) {\n        result.set(buffers[i], offset);\n        offset += buffers[i].length;\n      }\n      channels[n] = result;\n    }\n    return channels;\n  }\n\n  /**\n   * Combines parallel audio data into correct format,\n   * channels[Left[], Right[]] to float32Array[LRLRLRLR...]\n   */\n  formatAudioData(channels) {\n    if (channels.length === 1) {\n      // Simple case is only one channel\n      const float32Array = channels[0].slice();\n      const meanValues = channels[0].slice();\n      return { float32Array, meanValues };\n    } else {\n      const float32Array = new Float32Array(\n        channels[0].length * channels.length\n      );\n      const meanValues = new Float32Array(channels[0].length);\n      for (let i = 0; i < channels[0].length; i++) {\n        const offset = i * channels.length;\n        let meanValue = 0;\n        for (let n = 0; n < channels.length; n++) {\n          float32Array[offset + n] = channels[n][i];\n          meanValue += channels[n][i];\n        }\n        meanValues[i] = meanValue / channels.length;\n      }\n      return { float32Array, meanValues };\n    }\n  }\n\n  /**\n   * Converts 32-bit float data to 16-bit integers\n   */\n  floatTo16BitPCM(float32Array) {\n    const buffer = new ArrayBuffer(float32Array.length * 2);\n    const view = new DataView(buffer);\n    let offset = 0;\n    for (let i = 0; i < float32Array.length; i++, offset += 2) {\n      let s = Math.max(-1, Math.min(1, float32Array[i]));\n      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n    }\n    return buffer;\n  }\n\n  /**\n   * Retrieves the most recent amplitude values from the audio stream\n   * @param {number} channel\n   */\n  getValues(channel = -1) {\n    const channels = this.readChannelData(this.chunks, channel);\n    const { meanValues } = this.formatAudioData(channels);\n    return { meanValues, channels };\n  }\n\n  /**\n   * Exports chunks as an audio/wav file\n   */\n  export() {\n    const channels = this.readChannelData(this.chunks);\n    const { float32Array, meanValues } = this.formatAudioData(channels);\n    const audioData = this.floatTo16BitPCM(float32Array);\n    return {\n      meanValues: meanValues,\n      audio: {\n        bitsPerSample: 16,\n        channels: channels,\n        data: audioData,\n      },\n    };\n  }\n\n  receive(e) {\n    const { event, id } = e.data;\n    let receiptData = {};\n    switch (event) {\n      case 'start':\n        this.recording = true;\n        break;\n      case 'stop':\n        this.recording = false;\n        break;\n      case 'clear':\n        this.initialize();\n        break;\n      case 'export':\n        receiptData = this.export();\n        break;\n      case 'read':\n        receiptData = this.getValues();\n        break;\n      default:\n        break;\n    }\n    // Always send back receipt\n    this.port.postMessage({ event: 'receipt', id, data: receiptData });\n  }\n\n  sendChunk(chunk) {\n    const channels = this.readChannelData([chunk]);\n    const { float32Array, meanValues } = this.formatAudioData(channels);\n    const rawAudioData = this.floatTo16BitPCM(float32Array);\n    const monoAudioData = this.floatTo16BitPCM(meanValues);\n    this.port.postMessage({\n      event: 'chunk',\n      data: {\n        mono: monoAudioData,\n        raw: rawAudioData,\n      },\n    });\n  }\n\n  process(inputList, outputList, parameters) {\n    // Copy input to output (e.g. speakers)\n    // Note that this creates choppy sounds with Mac products\n    const sourceLimit = Math.min(inputList.length, outputList.length);\n    for (let inputNum = 0; inputNum < sourceLimit; inputNum++) {\n      const input = inputList[inputNum];\n      const output = outputList[inputNum];\n      const channelCount = Math.min(input.length, output.length);\n      for (let channelNum = 0; channelNum < channelCount; channelNum++) {\n        input[channelNum].forEach((sample, i) => {\n          output[channelNum][i] = sample;\n        });\n      }\n    }\n    const inputs = inputList[0];\n    // There's latency at the beginning of a stream before recording starts\n    // Make sure we actually receive audio data before we start storing chunks\n    let sliceIndex = 0;\n    if (!this.foundAudio) {\n      for (const channel of inputs) {\n        sliceIndex = 0; // reset for each channel\n        if (this.foundAudio) {\n          break;\n        }\n        if (channel) {\n          for (const value of channel) {\n            if (value !== 0) {\n              // find only one non-zero entry in any channel\n              this.foundAudio = true;\n              break;\n            } else {\n              sliceIndex++;\n            }\n          }\n        }\n      }\n    }\n    if (inputs && inputs[0] && this.foundAudio && this.recording) {\n      // We need to copy the TypedArray, because the \\`process\\`\n      // internals will reuse the same buffer to hold each input\n      const chunk = inputs.map((input) => input.slice(sliceIndex));\n      this.chunks.push(chunk);\n      this.sendChunk(chunk);\n    }\n    return true;\n  }\n}\n\nregisterProcessor('audio_processor', AudioProcessor);\n`;\n\nconst script = new Blob([AudioProcessorWorklet], {\n  type: 'application/javascript',\n});\nconst src = URL.createObjectURL(script);\nexport const AudioProcessorSrc = src;\n","import { AudioProcessorSrc } from \"./worklets/audio_processor.js\";\nimport { AudioAnalysis } from \"./analysis/audio_analysis.js\";\nimport { WavPacker } from \"./wav_packer.js\";\n\n/**\n * Decodes audio into a wav file\n * @typedef {Object} DecodedAudioType\n * @property {Blob} blob\n * @property {string} url\n * @property {Float32Array} values\n * @property {AudioBuffer} audioBuffer\n */\n\n/**\n * Records live stream of user audio as PCM16 \"audio/wav\" data\n * @class\n */\nexport class MediaStreamRecorder {\n  /**\n   * Create a new MediaStreamRecorder instance\n   * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]\n   * @returns {MediaStreamRecorder}\n   */\n  constructor({\n    sampleRate = 44100,\n    outputToSpeakers = false,\n    debug = false,\n  } = {}) {\n    // Script source\n    this.scriptSrc = AudioProcessorSrc;\n    // Config\n    this.sampleRate = sampleRate;\n    this.outputToSpeakers = outputToSpeakers;\n    this.debug = !!debug;\n    // State variables\n    this.stream = null;\n    this.processor = null;\n    this.source = null;\n    this.node = null;\n    this.recording = false;\n    // Event handling with AudioWorklet\n    this._lastEventId = 0;\n    this.eventReceipts = {};\n    this.eventTimeout = 5000;\n    // Process chunks of audio\n    this._chunkProcessor = () => {};\n    this._chunkProcessorSize = void 0;\n    this._chunkProcessorBuffer = {\n      raw: new ArrayBuffer(0),\n      mono: new ArrayBuffer(0),\n    };\n  }\n\n  /**\n   * Logs data in debug mode\n   * @param {...any} arguments\n   * @returns {true}\n   */\n  log() {\n    if (this.debug) {\n      this.log(...arguments);\n    }\n    return true;\n  }\n\n  /**\n   * Retrieves the current sampleRate for the recorder\n   * @returns {number}\n   */\n  getSampleRate() {\n    return this.sampleRate;\n  }\n\n  /**\n   * Retrieves the current status of the recording\n   * @returns {\"ended\"|\"paused\"|\"recording\"}\n   */\n  getStatus() {\n    if (!this.processor) {\n      return \"ended\";\n    } else if (!this.recording) {\n      return \"paused\";\n    } else {\n      return \"recording\";\n    }\n  }\n\n  /**\n   * Sends an event to the AudioWorklet\n   * @private\n   * @param {string} name\n   * @param {{[key: string]: any}} data\n   * @param {AudioWorkletNode} [_processor]\n   * @returns {Promise<{[key: string]: any}>}\n   */\n  async _event(name, data = {}, _processor = null) {\n    _processor = _processor || this.processor;\n    if (!_processor) {\n      throw new Error(\"Can not send events without recording first\");\n    }\n    const message = {\n      event: name,\n      id: this._lastEventId++,\n      data,\n    };\n    _processor.port.postMessage(message);\n    const t0 = new Date().valueOf();\n    while (!this.eventReceipts[message.id]) {\n      if (new Date().valueOf() - t0 > this.eventTimeout) {\n        throw new Error(`Timeout waiting for \"${name}\" event`);\n      }\n      await new Promise((res) => setTimeout(() => res(true), 1));\n    }\n    const payload = this.eventReceipts[message.id];\n    delete this.eventReceipts[message.id];\n    return payload;\n  }\n\n  /**\n   * Begins a recording session for the given audioTrack\n   * Microphone recording indicator will appear on browser tab but status will be \"paused\"\n   * @param {MediaStreamTrack} [audioTrack] if no device provided, default device will be used\n   * @returns {Promise<true>}\n   */\n  async begin(audioTrack) {\n    if (this.processor) {\n      throw new Error(\n        `Already connected: please call .end() to start a new session`\n      );\n    }\n\n    if (!audioTrack || audioTrack.kind !== \"audio\") {\n      throw new Error(\"No audio track provided\");\n    }\n\n    this.stream = new MediaStream([audioTrack]);\n\n    const context = new AudioContext({ sampleRate: this.sampleRate });\n    const source = context.createMediaStreamSource(this.stream);\n    // Load and execute the module script.\n    try {\n      await context.audioWorklet.addModule(this.scriptSrc);\n    } catch (e) {\n      console.error(e);\n      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);\n    }\n    const processor = new AudioWorkletNode(context, \"audio_processor\");\n    processor.port.onmessage = (e) => {\n      const { event, id, data } = e.data;\n      if (event === \"receipt\") {\n        this.eventReceipts[id] = data;\n      } else if (event === \"chunk\") {\n        if (this._chunkProcessorSize) {\n          const buffer = this._chunkProcessorBuffer;\n          this._chunkProcessorBuffer = {\n            raw: WavPacker.mergeBuffers(buffer.raw, data.raw),\n            mono: WavPacker.mergeBuffers(buffer.mono, data.mono),\n          };\n          if (\n            this._chunkProcessorBuffer.mono.byteLength >=\n            this._chunkProcessorSize\n          ) {\n            this._chunkProcessor(this._chunkProcessorBuffer);\n            this._chunkProcessorBuffer = {\n              raw: new ArrayBuffer(0),\n              mono: new ArrayBuffer(0),\n            };\n          }\n        } else {\n          this._chunkProcessor(data);\n        }\n      }\n    };\n\n    const node = source.connect(processor);\n    const analyser = context.createAnalyser();\n    analyser.fftSize = 8192;\n    analyser.smoothingTimeConstant = 0.1;\n    node.connect(analyser);\n    if (this.outputToSpeakers) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        \"Warning: Output to speakers may affect sound quality,\\n\" +\n          \"especially due to system audio feedback preventative measures.\\n\" +\n          \"use only for debugging\"\n      );\n      analyser.connect(context.destination);\n    }\n\n    this.source = source;\n    this.node = node;\n    this.analyser = analyser;\n    this.processor = processor;\n    return true;\n  }\n\n  /**\n   * Gets the current frequency domain data from the recording track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}\n   */\n  getFrequencies(\n    analysisType = \"frequency\",\n    minDecibels = -100,\n    maxDecibels = -30\n  ) {\n    if (!this.processor) {\n      throw new Error(\"Session ended: please call .begin() first\");\n    }\n    return AudioAnalysis.getFrequencies(\n      this.analyser,\n      this.sampleRate,\n      null,\n      analysisType,\n      minDecibels,\n      maxDecibels\n    );\n  }\n\n  /**\n   * Pauses the recording\n   * Keeps microphone stream open but halts storage of audio\n   * @returns {Promise<true>}\n   */\n  async pause() {\n    if (!this.processor) {\n      throw new Error(\"Session ended: please call .begin() first\");\n    } else if (!this.recording) {\n      throw new Error(\"Already paused: please call .record() first\");\n    }\n    if (this._chunkProcessorBuffer.raw.byteLength) {\n      this._chunkProcessor(this._chunkProcessorBuffer);\n    }\n    this.log(\"Pausing ...\");\n    await this._event(\"stop\");\n    this.recording = false;\n    return true;\n  }\n\n  /**\n   * Start recording stream and storing to memory from the connected audio source\n   * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]\n   * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio\n   * @returns {Promise<true>}\n   */\n  async record(chunkProcessor = () => {}, chunkSize = 8192) {\n    if (!this.processor) {\n      throw new Error(\"Session ended: please call .begin() first\");\n    } else if (this.recording) {\n      throw new Error(\"Already recording: HELLO please call .pause() first\");\n    } else if (typeof chunkProcessor !== \"function\") {\n      throw new Error(`chunkProcessor must be a function`);\n    }\n    this._chunkProcessor = chunkProcessor;\n    this._chunkProcessorSize = chunkSize;\n    this._chunkProcessorBuffer = {\n      raw: new ArrayBuffer(0),\n      mono: new ArrayBuffer(0),\n    };\n    this.log(\"Recording ...\");\n    await this._event(\"start\");\n    this.recording = true;\n    return true;\n  }\n\n  /**\n   * Clears the audio buffer, empties stored recording\n   * @returns {Promise<true>}\n   */\n  async clear() {\n    if (!this.processor) {\n      throw new Error(\"Session ended: please call .begin() first\");\n    }\n    await this._event(\"clear\");\n    return true;\n  }\n\n  /**\n   * Reads the current audio stream data\n   * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}\n   */\n  async read() {\n    if (!this.processor) {\n      throw new Error(\"Session ended: please call .begin() first\");\n    }\n    this.log(\"Reading ...\");\n    const result = await this._event(\"read\");\n    return result;\n  }\n\n  /**\n   * Saves the current audio stream to a file\n   * @param {boolean} [force] Force saving while still recording\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */\n  async save(force = false) {\n    if (!this.processor) {\n      throw new Error(\"Session ended: please call .begin() first\");\n    }\n    if (!force && this.recording) {\n      throw new Error(\n        \"Currently recording: please call .pause() first, or call .save(true) to force\"\n      );\n    }\n    this.log(\"Exporting ...\");\n    const exportData = await this._event(\"export\");\n    const packer = new WavPacker();\n    const result = packer.pack(this.sampleRate, exportData.audio);\n    return result;\n  }\n\n  /**\n   * Ends the current recording session and saves the result\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */\n  async end() {\n    if (!this.processor) {\n      throw new Error(\"Session ended: please call .begin() first\");\n    }\n\n    const _processor = this.processor;\n\n    this.log(\"Stopping ...\");\n    await this._event(\"stop\");\n    this.recording = false;\n\n    this.log(\"Exporting ...\");\n    const exportData = await this._event(\"export\", {}, _processor);\n\n    this.processor.disconnect();\n    this.source.disconnect();\n    this.node.disconnect();\n    this.analyser.disconnect();\n    this.stream = null;\n    this.processor = null;\n    this.source = null;\n    this.node = null;\n\n    const packer = new WavPacker();\n    const result = packer.pack(this.sampleRate, exportData.audio);\n    return result;\n  }\n\n  /**\n   * Performs a full cleanup of WavRecorder instance\n   * Stops actively listening via microphone and removes existing listeners\n   * @returns {Promise<true>}\n   */\n  async quit() {\n    this.listenForDeviceChange(null);\n    if (this.processor) {\n      await this.end();\n    }\n    return true;\n  }\n}\n\nglobalThis.WavRecorder = WavRecorder;\n","import { MediaManager } from \"./mediaManager\";\nimport { MediaStreamRecorder, WavStreamPlayer } from \"../wavtools\";\n\nimport Daily, {\n  DailyCall,\n  DailyEventObjectAvailableDevicesUpdated,\n  DailyEventObjectLocalAudioLevel,\n  DailyEventObjectSelectedDevicesUpdated,\n  DailyEventObjectTrack,\n  DailyParticipant,\n  DailyParticipantsObject,\n} from \"@daily-co/daily-js\";\nimport { Participant, Tracks } from \"@pipecat-ai/client-js\";\n\nexport class DailyMediaManager extends MediaManager {\n  private _daily: DailyCall;\n  private _mediaStreamRecorder: MediaStreamRecorder | undefined;\n  private _wavStreamPlayer: WavStreamPlayer | undefined;\n\n  private _initialized: boolean;\n  private _connected: boolean;\n  private _connectResolve: ((value: void | PromiseLike<void>) => void) | null;\n\n  private _currentAudioTrack: MediaStreamTrack | null;\n  private _selectedCam: MediaDeviceInfo | Record<string, never> = {};\n  private _selectedMic: MediaDeviceInfo | Record<string, never> = {};\n  private _selectedSpeaker: MediaDeviceInfo | Record<string, never> = {};\n\n  private _remoteAudioLevelInterval: NodeJS.Timeout | null = null;\n\n  private onTrackStartedCallback?: (event: DailyEventObjectTrack) => void;\n  private onTrackStoppedCallback?: (event: DailyEventObjectTrack) => void;\n\n  private _recorderChunkSize: number | undefined = undefined;\n\n  constructor(\n    enablePlayer: boolean = true,\n    enableRecording: boolean = true,\n    onTrackStartedCallback?: (event: DailyEventObjectTrack) => void,\n    onTrackStoppedCallback?: (event: DailyEventObjectTrack) => void,\n    recorderChunkSize: number | undefined = undefined,\n    recorderSampleRate: number = 24000,\n    playerSampleRate: number = 24000,\n  ) {\n    super();\n    this._initialized = false;\n    this._connected = false;\n    this._currentAudioTrack = null;\n    this._connectResolve = null;\n    this.onTrackStartedCallback = onTrackStartedCallback;\n    this.onTrackStoppedCallback = onTrackStoppedCallback;\n    this._recorderChunkSize = recorderChunkSize;\n\n    this._daily = Daily.getCallInstance() ?? Daily.createCallObject();\n\n    if (enableRecording) {\n      this._mediaStreamRecorder = new MediaStreamRecorder({\n        sampleRate: recorderSampleRate,\n      });\n    }\n    if (enablePlayer) {\n      this._wavStreamPlayer = new WavStreamPlayer({\n        sampleRate: playerSampleRate,\n      });\n    }\n\n    this._daily.on(\"track-started\", this.handleTrackStarted.bind(this));\n    this._daily.on(\"track-stopped\", this.handleTrackStopped.bind(this));\n    this._daily.on(\n      \"available-devices-updated\",\n      this._handleAvailableDevicesUpdated.bind(this),\n    );\n    this._daily.on(\n      \"selected-devices-updated\",\n      this._handleSelectedDevicesUpdated.bind(this),\n    );\n    this._daily.on(\"local-audio-level\", this._handleLocalAudioLevel.bind(this));\n  }\n\n  async initialize(): Promise<void> {\n    if (this._initialized) {\n      console.warn(\"DailyMediaManager already initialized\");\n      return;\n    }\n    const infos = await this._daily.startCamera({\n      startVideoOff: !this._camEnabled,\n      startAudioOff: !this._micEnabled,\n    });\n    const { devices } = await this._daily.enumerateDevices();\n    const cams = devices.filter((d) => d.kind === \"videoinput\");\n    const mics = devices.filter((d) => d.kind === \"audioinput\");\n    const speakers = devices.filter((d) => d.kind === \"audiooutput\");\n    this._callbacks.onAvailableCamsUpdated?.(cams);\n    this._callbacks.onAvailableMicsUpdated?.(mics);\n    this._callbacks.onAvailableSpeakersUpdated?.(speakers);\n    this._selectedCam = infos.camera;\n    this._callbacks.onCamUpdated?.(infos.camera as MediaDeviceInfo);\n    this._selectedMic = infos.mic;\n    this._callbacks.onMicUpdated?.(infos.mic as MediaDeviceInfo);\n    this._selectedSpeaker = infos.speaker;\n    this._callbacks.onSpeakerUpdated?.(infos.speaker as MediaDeviceInfo);\n\n    // Instantiate audio observers\n    if (!this._daily.isLocalAudioLevelObserverRunning())\n      await this._daily.startLocalAudioLevelObserver(100);\n\n    if (this._wavStreamPlayer) {\n      await this._wavStreamPlayer.connect();\n      if (!this._remoteAudioLevelInterval) {\n        this._remoteAudioLevelInterval = setInterval(() => {\n          const frequencies = this._wavStreamPlayer!.getFrequencies();\n          let aveVal = 0;\n          if (frequencies.values?.length) {\n            aveVal =\n              frequencies.values.reduce((a, c) => a + c, 0) /\n              frequencies.values.length;\n          }\n          this._handleRemoteAudioLevel(aveVal);\n        }, 100);\n      }\n    }\n    this._initialized = true;\n  }\n\n  async connect(): Promise<void> {\n    if (this._connected) {\n      console.warn(\"DailyMediaManager already connected\");\n      return;\n    }\n    this._connected = true;\n    if (!this._initialized) {\n      return new Promise((resolve) => {\n        (async () => {\n          this._connectResolve = resolve;\n          await this.initialize();\n        })();\n      });\n    }\n    if (this._micEnabled) {\n      this._startRecording();\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    if (this._remoteAudioLevelInterval) {\n      clearInterval(this._remoteAudioLevelInterval);\n    }\n    this._remoteAudioLevelInterval = null;\n    this._daily.leave();\n    this._currentAudioTrack = null;\n    await this._mediaStreamRecorder?.end();\n    this._wavStreamPlayer?.interrupt();\n    this._initialized = false;\n    this._connected = false;\n  }\n\n  async userStartedSpeaking(): Promise<unknown> {\n    return this._wavStreamPlayer?.interrupt();\n  }\n\n  bufferBotAudio(\n    data: ArrayBuffer | Int16Array,\n    id?: string,\n  ): Int16Array | undefined {\n    return this._wavStreamPlayer?.add16BitPCM(data, id);\n  }\n\n  async getAllMics(): Promise<MediaDeviceInfo[]> {\n    let devices = (await this._daily.enumerateDevices()).devices;\n    return devices.filter((device) => device.kind === \"audioinput\");\n  }\n  async getAllCams(): Promise<MediaDeviceInfo[]> {\n    let devices = (await this._daily.enumerateDevices()).devices;\n    return devices.filter((device) => device.kind === \"videoinput\");\n  }\n  async getAllSpeakers(): Promise<MediaDeviceInfo[]> {\n    let devices = (await this._daily.enumerateDevices()).devices;\n    return devices.filter((device) => device.kind === \"audiooutput\");\n  }\n\n  updateMic(micId: string) {\n    this._daily\n      .setInputDevicesAsync({ audioDeviceId: micId })\n      .then((deviceInfo) => {\n        this._selectedMic = deviceInfo.mic;\n      });\n  }\n  updateCam(camId: string) {\n    this._daily\n      .setInputDevicesAsync({ videoDeviceId: camId })\n      .then((deviceInfo) => {\n        this._selectedCam = deviceInfo.camera;\n      });\n  }\n  async updateSpeaker(speakerId: string): Promise<void> {\n    if (speakerId !== \"default\" && this._selectedSpeaker.deviceId === speakerId)\n      return;\n    let sID = speakerId;\n    if (sID === \"default\") {\n      const speakers = await this.getAllSpeakers();\n      const defaultSpeaker = speakers.find((s) => s.deviceId === \"default\");\n      if (!defaultSpeaker) {\n        console.warn(\"No default speaker found\");\n        return;\n      }\n      speakers.splice(speakers.indexOf(defaultSpeaker), 1);\n      const defaultSpeakerCp = speakers.find((s) =>\n        defaultSpeaker.label.includes(s.label),\n      );\n      sID = defaultSpeakerCp?.deviceId ?? speakerId;\n    }\n    this._wavStreamPlayer?.updateSpeaker(sID).then(() => {\n      this._selectedSpeaker = { deviceId: speakerId } as MediaDeviceInfo;\n      this._callbacks.onSpeakerUpdated?.(this._selectedSpeaker);\n    });\n  }\n\n  get selectedMic(): MediaDeviceInfo | Record<string, never> {\n    return this._selectedMic;\n  }\n  get selectedCam(): MediaDeviceInfo | Record<string, never> {\n    return this._selectedCam;\n  }\n  get selectedSpeaker(): MediaDeviceInfo | Record<string, never> {\n    return this._selectedSpeaker;\n  }\n\n  async enableMic(enable: boolean): Promise<void> {\n    this._micEnabled = enable;\n    if (!this._daily.participants()?.local) return;\n    this._daily.setLocalAudio(enable);\n    if (this._mediaStreamRecorder) {\n      if (enable) {\n        if (this._mediaStreamRecorder.getStatus() === \"paused\") {\n          this._startRecording();\n        } // else, we'll record on the track-started event\n      } else {\n        if (this._mediaStreamRecorder.getStatus() === \"recording\") {\n          this._mediaStreamRecorder.pause();\n        }\n      }\n    }\n  }\n  enableCam(enable: boolean): void {\n    this._camEnabled = enable;\n    this._daily.setLocalVideo(enable);\n  }\n\n  get isCamEnabled(): boolean {\n    return this._daily.localVideo();\n  }\n  get isMicEnabled(): boolean {\n    return this._daily.localAudio();\n  }\n\n  tracks(): Tracks {\n    const participants: DailyParticipantsObject = this._daily.participants();\n    return {\n      local: {\n        audio: participants?.local?.tracks?.audio?.persistentTrack,\n        video: participants?.local?.tracks?.video?.persistentTrack,\n      },\n    };\n  }\n\n  private _startRecording(): void {\n    if (!this._connected || !this._mediaStreamRecorder) return;\n    try {\n      this._mediaStreamRecorder.record((data) => {\n        this._userAudioCallback(data.mono);\n      }, this._recorderChunkSize);\n    } catch (e) {\n      const err = e as Error;\n      if (!err.message.includes(\"Already recording\")) {\n        console.error(\"Error starting recording\", e);\n      }\n    }\n  }\n\n  private _handleAvailableDevicesUpdated(\n    event: DailyEventObjectAvailableDevicesUpdated,\n  ) {\n    this._callbacks.onAvailableCamsUpdated?.(\n      event.availableDevices.filter((d) => d.kind === \"videoinput\"),\n    );\n    this._callbacks.onAvailableMicsUpdated?.(\n      event.availableDevices.filter((d) => d.kind === \"audioinput\"),\n    );\n    this._callbacks.onAvailableSpeakersUpdated?.(\n      event.availableDevices.filter((d) => d.kind === \"audiooutput\"),\n    );\n    if (this._selectedSpeaker.deviceId === \"default\") {\n      this.updateSpeaker(\"default\");\n    }\n  }\n\n  private _handleSelectedDevicesUpdated(\n    event: DailyEventObjectSelectedDevicesUpdated,\n  ) {\n    if (this._selectedCam?.deviceId !== event.devices.camera) {\n      this._selectedCam = event.devices.camera;\n      this._callbacks.onCamUpdated?.(event.devices.camera as MediaDeviceInfo);\n    }\n    if (this._selectedMic?.deviceId !== event.devices.mic) {\n      this._selectedMic = event.devices.mic;\n      this._callbacks.onMicUpdated?.(event.devices.mic as MediaDeviceInfo);\n    }\n  }\n\n  private _handleLocalAudioLevel(ev: DailyEventObjectLocalAudioLevel) {\n    this._callbacks.onLocalAudioLevel?.(ev.audioLevel);\n  }\n\n  private _handleRemoteAudioLevel(audioLevel: number) {\n    this._callbacks.onRemoteAudioLevel?.(audioLevel, botParticipant());\n  }\n\n  protected async handleTrackStarted(event: DailyEventObjectTrack) {\n    if (!event.participant?.local) return;\n    if (event.track.kind === \"audio\") {\n      if (this._mediaStreamRecorder) {\n        const status = this._mediaStreamRecorder.getStatus();\n        switch (status) {\n          case \"ended\":\n            await this._mediaStreamRecorder.begin(event.track);\n            if (this._connected) {\n              this._startRecording();\n              if (this._connectResolve) {\n                this._connectResolve();\n                this._connectResolve = null;\n              }\n            }\n            break;\n          case \"paused\":\n            this._startRecording();\n            break;\n          case \"recording\":\n          default:\n            if (this._currentAudioTrack !== event.track) {\n              await this._mediaStreamRecorder.end();\n              await this._mediaStreamRecorder.begin(event.track);\n              this._startRecording();\n            } else {\n              console.warn(\n                \"track-started event received for current track and already recording\",\n              );\n            }\n            break;\n        }\n      }\n      this._currentAudioTrack = event.track;\n    }\n    this._callbacks.onTrackStarted?.(\n      event.track,\n      event.participant\n        ? dailyParticipantToParticipant(event.participant)\n        : undefined,\n    );\n    this.onTrackStartedCallback?.(event);\n  }\n\n  protected handleTrackStopped(event: DailyEventObjectTrack) {\n    if (!event.participant?.local) return;\n    if (event.track.kind === \"audio\") {\n      if (\n        this._mediaStreamRecorder &&\n        this._mediaStreamRecorder.getStatus() === \"recording\"\n      ) {\n        this._mediaStreamRecorder.pause();\n      }\n    }\n    this._callbacks.onTrackStopped?.(\n      event.track,\n      event.participant\n        ? dailyParticipantToParticipant(event.participant)\n        : undefined,\n    );\n    this.onTrackStoppedCallback?.(event);\n  }\n}\n\nconst dailyParticipantToParticipant = (p: DailyParticipant): Participant => ({\n  id: p.user_id,\n  local: p.local,\n  name: p.user_name,\n});\n\nconst botParticipant = () => ({\n  id: \"bot\",\n  local: false,\n  name: \"Bot\",\n});\n","import {\n  logger,\n  RTVIClientOptions,\n  RTVIMessage,\n  Tracks,\n  Transport,\n  TransportStartError,\n  TransportState,\n} from \"@pipecat-ai/client-js\";\n\nimport { ReconnectingWebSocket } from \"../../../lib/websocket-utils/reconnectingWebSocket\";\nimport { DailyMediaManager } from \"../../../lib/media-mgmt/dailyMediaManager\";\nimport { MediaManager } from \"../../../lib/media-mgmt/mediaManager\";\nimport { WebSocketSerializer } from \"./serializers/websocketSerializer.ts\";\nimport { ProtobufFrameSerializer } from \"./serializers/protobufSerializer.ts\";\n\nexport class WebSocketTransport extends Transport {\n  declare private _ws: ReconnectingWebSocket | null;\n  private static RECORDER_SAMPLE_RATE = 16_000;\n  private static PLAYER_SAMPLE_RATE = 24_000;\n  private audioQueue: ArrayBuffer[] = [];\n  private _mediaManager: MediaManager;\n  private _serializer: WebSocketSerializer;\n\n  constructor(\n    {\n      serializer,\n      recorderSampleRate,\n      playerSampleRate,\n    }: {\n      serializer: WebSocketSerializer;\n      recorderSampleRate?: number;\n      playerSampleRate?: number;\n    } = {\n      serializer: new ProtobufFrameSerializer(),\n      recorderSampleRate: WebSocketTransport.RECORDER_SAMPLE_RATE,\n      playerSampleRate: WebSocketTransport.PLAYER_SAMPLE_RATE,\n    },\n  ) {\n    super();\n    this._mediaManager = new DailyMediaManager(\n      true,\n      true,\n      undefined,\n      undefined,\n      512,\n      recorderSampleRate,\n      playerSampleRate,\n    );\n    this._mediaManager.setUserAudioCallback(\n      this.handleUserAudioStream.bind(this),\n    );\n    this._ws = null;\n    this._serializer = serializer;\n  }\n\n  initialize(\n    options: RTVIClientOptions,\n    messageHandler: (ev: RTVIMessage) => void,\n  ): void {\n    this._options = options;\n    this._callbacks = options.callbacks ?? {};\n    this._onMessage = messageHandler;\n    this._mediaManager.setRTVIOptions(options);\n    this.state = \"disconnected\";\n  }\n\n  async initDevices(): Promise<void> {\n    this.state = \"initializing\";\n    await this._mediaManager.initialize();\n    this.state = \"initialized\";\n  }\n\n  async connect(\n    authBundle: unknown,\n    abortController: AbortController,\n  ): Promise<void> {\n    this.state = \"connecting\";\n    try {\n      this._ws = this.initializeWebsocket(authBundle);\n      await this._ws.connect();\n      await this._mediaManager.connect();\n      this.state = \"connected\";\n      this._callbacks.onConnected?.();\n    } catch (error) {\n      const msg = `Failed to connect to websocket: ${error}`;\n      logger.error(msg);\n      this.state = \"error\";\n      throw new TransportStartError(msg);\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    this.state = \"disconnecting\";\n    await this._mediaManager.disconnect();\n    await this._ws?.close();\n    this.state = \"disconnected\";\n    this._callbacks.onDisconnected?.();\n  }\n\n  getAllMics(): Promise<MediaDeviceInfo[]> {\n    return this._mediaManager.getAllMics();\n  }\n  getAllCams(): Promise<MediaDeviceInfo[]> {\n    return this._mediaManager.getAllCams();\n  }\n  getAllSpeakers(): Promise<MediaDeviceInfo[]> {\n    return this._mediaManager.getAllSpeakers();\n  }\n\n  async updateMic(micId: string): Promise<void> {\n    return this._mediaManager.updateMic(micId);\n  }\n  updateCam(camId: string): void {\n    return this._mediaManager.updateCam(camId);\n  }\n  updateSpeaker(speakerId: string): void {\n    return this._mediaManager.updateSpeaker(speakerId);\n  }\n\n  get selectedMic(): MediaDeviceInfo | Record<string, never> {\n    return this._mediaManager.selectedMic;\n  }\n  get selectedSpeaker(): MediaDeviceInfo | Record<string, never> {\n    return this._mediaManager.selectedSpeaker;\n  }\n\n  enableMic(enable: boolean): void {\n    this._mediaManager.enableMic(enable);\n  }\n  get isMicEnabled(): boolean {\n    return this._mediaManager.isMicEnabled;\n  }\n\n  get state(): TransportState {\n    return this._state;\n  }\n\n  set state(state: TransportState) {\n    if (this._state === state) return;\n\n    this._state = state;\n    this._callbacks.onTransportStateChanged?.(state);\n  }\n\n  get expiry(): number | undefined {\n    return this._expiry;\n  }\n\n  tracks(): Tracks {\n    return this._mediaManager.tracks();\n  }\n\n  initializeWebsocket(authBundle: any): ReconnectingWebSocket {\n    console.log(\"Initializing websocket\", authBundle);\n    const ws = new ReconnectingWebSocket(`${authBundle.ws_url}`, undefined, {\n      parseBlobToJson: false,\n    });\n    // disabling the keep alive, there is no API for it inside Pipecat\n    ws.keepAliveInterval = 0;\n    ws.on(\"open\", () => {\n      logger.debug(\"Websocket connection opened\");\n    });\n    ws.on(\"message\", async (data: any) => {\n      try {\n        const parsed = await this._serializer.deserialize(data);\n        if (parsed.type === \"audio\") {\n          this._mediaManager.bufferBotAudio(parsed.audio);\n        } else if (parsed.type === \"message\") {\n          if (parsed.message.label === \"rtvi-ai\") {\n            this._onMessage(parsed.message);\n          }\n        }\n      } catch (e) {\n        logger.error(\"Failed to deserialize incoming message\", e);\n      }\n    });\n    ws.on(\"error\", (error: Error) => {\n      this.connectionError(`websocket error: ${error}`);\n    });\n    ws.on(\"connection-timeout\", () => {\n      this.connectionError(\"websocket connection timed out\");\n    });\n    ws.on(\"close\", (code: number) => {\n      this.connectionError(`websocket connection closed. Code: ${code}`);\n    });\n    ws.on(\"reconnect-failed\", () => {\n      this.connectionError(`websocket reconnect failed`);\n    });\n    return ws;\n  }\n\n  sendReadyMessage(): void {\n    this.state = \"ready\";\n    this.sendMessage(RTVIMessage.clientReady());\n  }\n\n  handleUserAudioStream(data: ArrayBuffer): void {\n    if (this.state === \"ready\") {\n      try {\n        void this.flushAudioQueue();\n        void this._sendAudioInput(data);\n      } catch (error) {\n        logger.error(\"Error sending audio stream to websocket:\", error);\n        this.state = \"error\";\n      }\n    } else {\n      this.audioQueue.push(data);\n    }\n  }\n\n  private flushAudioQueue(): void {\n    if (this.audioQueue.length <= 0) {\n      return;\n    }\n    logger.info(\"Will flush audio queue\", this.audioQueue.length);\n    while (this.audioQueue.length > 0) {\n      const queuedData = this.audioQueue.shift();\n      if (queuedData) void this._sendAudioInput(queuedData);\n    }\n  }\n\n  sendRawMessage(message: any): void {\n    logger.debug(\"Received raw message to send to Web Socket\", message);\n    const encoded = this._serializer.serialize(message);\n    void this._sendMsg(encoded);\n  }\n\n  sendMessage(message: RTVIMessage): void {\n    logger.debug(\"Received message to send to Web Socket\", message);\n    const encoded = this._serializer.serializeMessage(message);\n    void this._sendMsg(encoded);\n  }\n\n  async _sendAudioInput(data: ArrayBuffer): Promise<void> {\n    try {\n      const encoded = this._serializer.serializeAudio(\n        data,\n        WebSocketTransport.RECORDER_SAMPLE_RATE,\n        1,\n      );\n      await this._sendMsg(encoded);\n    } catch (e) {\n      logger.error(\"Error sending audio frame\", e);\n    }\n  }\n\n  async _sendMsg(msg: any): Promise<void> {\n    if (!this._ws) {\n      logger.error(\"sendMsg called but WS is null\");\n      return;\n    }\n    if (this._ws.readyState !== WebSocket.OPEN) {\n      logger.error(\"attempt to send to closed socket\");\n      return;\n    }\n    if (!msg) {\n      return;\n    }\n    try {\n      await this._ws.send(msg);\n    } catch (e) {\n      logger.error(\"sendMsg error\", e);\n    }\n  }\n\n  connectionError(errorMsg: string): void {\n    console.error(errorMsg);\n    this.state = \"error\";\n    void this.disconnect();\n  }\n\n  // Not implemented\n  enableScreenShare(enable: boolean): void {\n    logger.error(\"startScreenShare not implemented for WebSocketTransport\");\n    throw new Error(\"Not implemented\");\n  }\n\n  public get isSharingScreen(): boolean {\n    logger.error(\"isSharingScreen not implemented for WebSocketTransport\");\n    return false;\n  }\n\n  enableCam(enable: boolean) {\n    logger.error(\"enableCam not implemented for WebSocketTransport\");\n    throw new Error(\"Not implemented\");\n  }\n\n  get isCamEnabled(): boolean {\n    logger.error(\"isCamEnabled not implemented for WebSocketTransport\");\n    return false;\n  }\n\n  get selectedCam(): MediaDeviceInfo | Record<string, never> {\n    logger.error(\"selectedCam not implemented for WebSocketTransport\");\n    throw new Error(\"Not implemented\");\n  }\n}\n","import { EventEmitter } from \"events\";\n\nconst readyStates = [\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"];\nconst KEEP_ALIVE_INTERVAL = 5000;\nconst KEEP_ALIVE_TIMEOUT = 15000;\n// client side code in soupSFU has a timeout of 15 seconds for command response\n// 5 seconds seems reasonable that it provides roughly 3 retry attempts\nconst WEBSOCKET_CONNECTION_TIMEOUT = 150 * 1000;\nconst DEFAULT_RECONNECT_ATTEMPTS = 2;\nconst MAX_RECONNECT_ATTEMPTS = 10;\nconst DEFAULT_RECONNECT_INTERVAL = 1000;\nconst MAX_RECONNECT_INTERVAL = 30 * 1000;\nconst DEFAULT_RECONNECT_DECAY = 1.5;\n\nconst WEBSOCKET_TIMEOUT_CODE = 4100;\n\nconst SIG_CONNECTION_CANCELED = \"SIG_CONNECTION_CANCELED\";\nconst WEBSOCKET_ERROR = \"WEBSOCKET_ERROR\";\n\nenum LOG_LEVEL {\n  DEBUG,\n  ERROR,\n  INFO,\n  WARN,\n}\n\nclass rWebSocket {\n  private _ws: WebSocket;\n  _closedManually: boolean = false;\n  _errored: boolean = false;\n  _rejected: boolean = false;\n  _timed_out: boolean = false;\n  _initialConnectionOk: string | boolean = false;\n\n  constructor(url: string, protocols?: string | string[]) {\n    this._ws = new WebSocket(url, protocols);\n  }\n\n  addEventListener(\n    type: string,\n    listener: (this: WebSocket, ev: Event) => any,\n  ) {\n    this._ws.addEventListener(type, listener);\n  }\n\n  // Add other WebSocket methods as needed\n  close(code?: number, reason?: string) {\n    this._ws.close(code, reason);\n  }\n\n  send(data: string | ArrayBuffer | Blob | ArrayBufferView) {\n    this._ws.send(data);\n  }\n\n  // Add getters for WebSocket properties\n  get url() {\n    return this._ws.url;\n  }\n\n  get readyState() {\n    return this._ws.readyState;\n  }\n}\n\ninterface WebSocketOptions {\n  parseBlobToJson?: boolean;\n}\n\n/**\n * Builds on top of Javascript Websockets\n *\n * This behaves like the Websocket library in every way, except if it fails to\n * connect or if it gets disconnected, it will try to reconnect depending on\n * the maximum number of reconnect attempts set. retry is not enabled for initial\n * connection. When initial connection fails it is best to check yourself before\n * you keep wreckin' yourself.\n *\n * It is API compatible, so when you have:\n *   ws = new WebSocket('ws://....');\n * you can replace with:\n *   ws = new ReconnectingWebSocket('ws://....');\n *\n * While it is API compatible with the NodeJS ws library, we provide the\n * following additional properties and events on the ReconnectingWebSocket.\n *\n * Events:\n *\n * connection-timeout\n * - Emitted when the web socket connection times out.\n *\n * reconnecting\n * - Emitted after a manual close of the web socket is done and before retrying\n *   the connection.\n *\n * reconnect-failed\n * - Emitted when the number of connection attempts exceeds the set number of\n *   reconnection attempts.\n *\n * keep-alive\n * - Emitted when the set keep alive interval elapses. This event may be used\n *   to have ping pong keep-alive mechanism for web socket health.\n *\n * Properties:\n *\n * keepAliveTimeout\n * - The timeout for keep-alive. Default: 15000\n *\n * keepAliveInterval\n * - The interval at which to emit keep-alive event. Default: 5000\n *\n * shouldRetryFn\n * - A callback function which should return boolean to determine if a web\n *   socket reconnection attempt should be made. When not set, connection is\n *   always retried.\n *\n * connectionTimeout\n * - The timeout interval for considering whether the connection timed out.\n *   Default: 20000 ms\n *\n * maxReconnectAttempts\n * - The maximum number of attempts to be made for reconnection. Default: 2\n *\n * reconnectInterval\n * - The interval to wait before attempting a reconnection. Default: 1000 ms\n */\nexport class ReconnectingWebSocket extends EventEmitter {\n  /** The connection is not yet open. */\n  static readonly CONNECTING: 0;\n  /** The connection is open and ready to communicate. */\n  static readonly OPEN: 1;\n  /** The connection is in the process of closing. */\n  static readonly CLOSING: 2;\n  /** The connection is closed. */\n  static readonly CLOSED: 3;\n\n  private _ws: rWebSocket | null;\n\n  _url: string;\n  _protocols: string | string[] | undefined;\n\n  declare private _keepAliveTimeout: number;\n  declare private _keepAliveInterval: number;\n  declare private _lastMsgRecvTime: number;\n  declare private _lastMsgSendTime: number;\n  declare private _disconnected: boolean;\n  declare private _keepIntervalID: NodeJS.Timeout | null;\n  declare private _connectionTimeout: number;\n  declare private _connectionTimeoutID: NodeJS.Timeout | undefined;\n  declare private _reconnectTimeoutID: NodeJS.Timeout | undefined;\n  declare private _shouldRetryFn: (() => boolean) | null;\n  declare private _reconnectAttempts: number;\n  declare private _allowedReconnectAttempts: number;\n  declare private _reconnectInterval: number;\n  declare private _maxReconnectInterval: number;\n  declare private _reconnectDecay: number;\n  declare private _parseBlobToJson: boolean;\n\n  constructor(\n    address: string,\n    protocols?: string | string[],\n    options: WebSocketOptions = {},\n  ) {\n    super();\n\n    if (!address) {\n      throw new Error(\"Need a valid WebSocket URL\");\n    }\n\n    this._ws = null;\n\n    this._url = address;\n    this._protocols = protocols;\n    this._parseBlobToJson = options?.parseBlobToJson ?? true;\n\n    this.init();\n  }\n\n  private init() {\n    this._keepAliveTimeout = KEEP_ALIVE_TIMEOUT;\n    this._keepAliveInterval = KEEP_ALIVE_INTERVAL;\n    this._disconnected = false;\n    this._keepIntervalID = null;\n    this._shouldRetryFn = null;\n    this._connectionTimeout = WEBSOCKET_CONNECTION_TIMEOUT;\n    this._reconnectAttempts = 0;\n    this._allowedReconnectAttempts = DEFAULT_RECONNECT_ATTEMPTS;\n    this._reconnectInterval = DEFAULT_RECONNECT_INTERVAL;\n    this._maxReconnectInterval = MAX_RECONNECT_INTERVAL;\n    this._reconnectDecay = DEFAULT_RECONNECT_DECAY;\n  }\n\n  public async connect() {\n    return new Promise((resolve, reject) => {\n      this._disconnected = false;\n      this.clearReconnectTimeout();\n\n      let ws: rWebSocket = new rWebSocket(this._url, this._protocols);\n      this.setConnectionTimeout();\n\n      ws.addEventListener(\"close\", (evt) => {\n        const closeEvent = evt as CloseEvent;\n        let code = ws._timed_out ? WEBSOCKET_TIMEOUT_CODE : closeEvent.code;\n        let reason = ws._timed_out\n          ? \"websocket connection timed out\"\n          : closeEvent.reason;\n        ws._timed_out = false;\n        if (!ws._closedManually && ws._initialConnectionOk) {\n          console.warn(\n            `signaling socket closed unexpectedly: ${code}${\n              reason ? \" \" + reason : \"\"\n            }`,\n          );\n          this._closeSocket();\n          this.emit(\"close\", code, reason);\n        } else {\n          this.log(\"signaling socket closed\");\n        }\n        if (!ws._closedManually && (ws._errored || ws._timed_out)) {\n          console.warn(\n            `signaling socket closed on error: ${code}${\n              reason ? \" \" + reason : \"\"\n            }`,\n          );\n          if (!ws._rejected) {\n            ws._rejected = true;\n            const err = new Error(\n              `WebSocket connection error (${code}): ${reason}`,\n            );\n            err.name = WEBSOCKET_ERROR;\n            reject(err);\n          }\n        }\n      });\n      ws.addEventListener(\"open\", (evt) => {\n        this.log(\"wss connection opened to\", LOG_LEVEL.DEBUG, this._url);\n        this.clearConnectionTimeout();\n        // now that the timeout closes the socket, in theory this onopen\n        // callback should never happen in the first place, but seems\n        // harmless to leave these safeguards in\n        if (ws._rejected || ws._timed_out) {\n          return;\n        }\n        if (ws._closedManually || (this._ws && this._ws !== ws)) {\n          ws._rejected = true;\n          ws.close();\n          let err = Error(\n            \"wss connection interrupted by disconnect or newer connection\",\n          );\n          err.name = SIG_CONNECTION_CANCELED;\n          reject(err);\n          return;\n        }\n        ws._initialConnectionOk = this._url;\n        this._lastMsgRecvTime = Date.now();\n        if (this._keepAliveInterval) {\n          this._keepIntervalID = setInterval(\n            () => this.checkSocketHealthAndSendKeepAlive(),\n            this._keepAliveInterval,\n          );\n        }\n        this._ws = ws;\n        this.emit(\"open\");\n        resolve(ws);\n      });\n      ws.addEventListener(\"error\", (evt) => {\n        // fyi: evt is an Event here, with 0 amount of helpful info. If there\n        //   happens to be info about the error, it's included in the\n        //   accompanying close event (because that make sense. shakes head)\n        //   SO. We do not reject here. Instead, we just set the _errored\n        //   flag on the socket so when the close event occurs, it knows to\n        //   reject the promise\n        if (!ws._closedManually) {\n          const wsTarget = evt.currentTarget as WebSocket;\n          this.log(`websocket error event: ${wsTarget?.url}`);\n        }\n        ws._errored = true;\n      });\n      ws.addEventListener(\"message\", (msg) => {\n        void this._handleMessage(msg as MessageEvent);\n      });\n    });\n  }\n\n  private setConnectionTimeout() {\n    this._connectionTimeoutID = setTimeout(async () => {\n      this.log(\"Connection reconnect attempt timed out.\");\n      this.emit(\"connection-timeout\");\n      this.clearConnectionTimeout();\n      await this._closeSocket();\n    }, this._connectionTimeout);\n  }\n\n  private clearConnectionTimeout() {\n    clearTimeout(this._connectionTimeoutID);\n    this._connectionTimeoutID = undefined;\n  }\n\n  private clearReconnectTimeout() {\n    clearTimeout(this._reconnectTimeoutID);\n    this._reconnectTimeoutID = undefined;\n  }\n\n  private clearKeepAliveInterval() {\n    if (this._keepIntervalID) {\n      clearInterval(this._keepIntervalID);\n      this._keepIntervalID = null;\n    }\n  }\n\n  private async checkSocketHealthAndSendKeepAlive() {\n    if (!(this._ws && this._ws.readyState === WebSocket.OPEN)) {\n      return;\n    }\n\n    if (!this._keepAliveTimeout || !this._keepAliveInterval) {\n      return;\n    }\n\n    // See if we haven't gotten a message back recently, and if we\n    // haven't, close the socket. the os timeouts to detect if a socket\n    // has gone stale are longer than we want.\n    if (Date.now() - this._lastMsgRecvTime > this._keepAliveTimeout) {\n      this.log(\"Connection is stale, need to reconnect\", LOG_LEVEL.WARN);\n      await this._closeSocket();\n      return;\n    }\n\n    // Only emit the keep-alive event if we haven't sent anything else recently\n    if (Date.now() - this._lastMsgSendTime < this._keepAliveInterval) {\n      return;\n    }\n\n    this.log(\"Emitting keep-alive\", LOG_LEVEL.DEBUG);\n    this.emit(\"keep-alive\");\n  }\n\n  // We use the word manually here to imply the application using this code\n  // or this code itself will decide to close the socket.\n  private async _closeSocket() {\n    this.log(\"Closing\");\n    try {\n      this.clearKeepAliveInterval();\n      this._lastMsgRecvTime = 0;\n\n      if (this._ws) {\n        this._ws._closedManually = true;\n        this._ws.close();\n      }\n\n      // query retry function if we want to retry.\n      const shouldRetry =\n        this._ws?._initialConnectionOk &&\n        this._shouldRetryFn &&\n        this._shouldRetryFn();\n\n      this._ws = null;\n\n      if (shouldRetry) {\n        this.log(\"Emitting reconnect\", LOG_LEVEL.DEBUG);\n        this.emit(\"reconnecting\");\n        await this.retryFailedConnection();\n      }\n    } catch (error) {\n      this.log(`Error while closing and retrying: ${error}`, LOG_LEVEL.ERROR);\n    }\n  }\n\n  private async retryFailedConnection() {\n    if (this._reconnectAttempts < this._allowedReconnectAttempts) {\n      if (this._reconnectTimeoutID) {\n        this.log(\"Retry already scheduled\");\n        return;\n      }\n      this.log(\"Retrying failed connection\");\n      let timeout =\n        // The timeout logic is taken from\n        // https://github.com/joewalnes/reconnecting-websocket\n        this._reconnectInterval *\n        Math.pow(this._reconnectDecay, this._reconnectAttempts);\n      timeout =\n        timeout > this._maxReconnectInterval\n          ? this._maxReconnectInterval\n          : timeout;\n      this.log(`Reconnecting in ${timeout / 1000} seconds`);\n\n      this._reconnectAttempts += 1;\n      this._reconnectTimeoutID = setTimeout(() => this.connect(), timeout);\n    } else {\n      this.log(\"Maximum connection retry attempts exceeded\", LOG_LEVEL.ERROR);\n      this.emit(\"reconnect-failed\");\n    }\n  }\n\n  private log(\n    msg: string,\n    log_level: LOG_LEVEL = LOG_LEVEL.DEBUG,\n    ...args: any\n  ) {\n    switch (log_level) {\n      case LOG_LEVEL.DEBUG:\n        console.debug(`websocket: ${msg}`, ...args);\n        break;\n      case LOG_LEVEL.ERROR:\n        console.error(`websocket: ${msg}`, ...args);\n        break;\n      case LOG_LEVEL.WARN:\n        console.warn(`websocket: ${msg}`, ...args);\n        break;\n      case LOG_LEVEL.INFO:\n      default:\n        console.log(`websocket: ${msg}`, ...args);\n        break;\n    }\n  }\n\n  async send(data: any) {\n    try {\n      if (this._ws && this._ws.readyState === WebSocket.OPEN) {\n        this._lastMsgSendTime = Date.now();\n        this._ws.send(data);\n      } else {\n        this.log(`Failed to send data, web socket not open.`, LOG_LEVEL.ERROR);\n      }\n    } catch (error) {\n      this.log(`Failed to send data. ${error}`, LOG_LEVEL.ERROR);\n    }\n  }\n\n  async close() {\n    try {\n      this.log(\"Closing websocket\");\n      this._disconnected = true;\n      this.clearReconnectTimeout();\n      this._closeSocket();\n    } catch (error) {\n      this.log(`Failed to close websocket. ${error}`);\n    }\n  }\n\n  get readyState(): number {\n    return this._ws?.readyState ?? WebSocket.CLOSED;\n  }\n\n  get url(): string {\n    return this._url;\n  }\n\n  get keepAliveTimeout(): number {\n    return this._keepAliveTimeout;\n  }\n\n  set keepAliveTimeout(keepAliveTimeout: number) {\n    if (typeof keepAliveTimeout === \"number\") {\n      this.log(`Setting ACK freshness timeout to ${keepAliveTimeout}`);\n      this._keepAliveTimeout = keepAliveTimeout;\n    }\n  }\n\n  get keepAliveInterval(): number {\n    return this._keepAliveInterval;\n  }\n\n  set keepAliveInterval(keepAliveInterval: number) {\n    if (typeof keepAliveInterval === \"number\") {\n      this.log(`Setting keep-alive interval to ${keepAliveInterval}`);\n      this._keepAliveInterval = keepAliveInterval;\n    }\n  }\n\n  set shouldRetryFn(cb: () => boolean) {\n    if (typeof cb === \"function\") {\n      this._shouldRetryFn = cb;\n    }\n  }\n\n  get connectionTimeout(): number {\n    return this._connectionTimeout;\n  }\n\n  set connectionTimeout(timeout: number) {\n    if (typeof timeout === \"number\") {\n      this._connectionTimeout = timeout;\n    }\n  }\n\n  get maxReconnectAttempts(): number {\n    return this._allowedReconnectAttempts;\n  }\n\n  set maxReconnectAttempts(attempts: number) {\n    if (attempts > 0 && attempts < MAX_RECONNECT_ATTEMPTS) {\n      this.log(`Setting maximum connection retry attempts to ${attempts}`);\n      this._allowedReconnectAttempts = attempts;\n    } else {\n      this._allowedReconnectAttempts = DEFAULT_RECONNECT_ATTEMPTS;\n    }\n  }\n\n  get reconnectInterval(): number {\n    return this._reconnectInterval;\n  }\n\n  set reconnectInterval(interval: number) {\n    if (typeof interval === \"number\") {\n      this._reconnectInterval =\n        interval < this._maxReconnectInterval\n          ? interval\n          : this._maxReconnectInterval;\n    }\n  }\n\n  async _handleMessage(event: MessageEvent) {\n    this._lastMsgRecvTime = Date.now();\n    const data = event.data;\n\n    const _parsePromise = new Promise((resolve, reject) => {\n      if (typeof data === \"string\") {\n        // Handle text message\n        resolve(data);\n      } else if (data instanceof ArrayBuffer) {\n        // Handle binary message\n        const arrayBuffer = data;\n        // Parse the ArrayBuffer as needed\n        // Example: Convert ArrayBuffer to Uint8Array\n        resolve(new Uint8Array(arrayBuffer));\n        // Process the Uint8Array as needed\n      } else if (data instanceof Blob) {\n        if (!this._parseBlobToJson) {\n          resolve(data);\n          return;\n        }\n        // Handle Blob message\n        const blob = data;\n        // Convert Blob to ArrayBuffer\n        const reader = new FileReader();\n        reader.onload = () => {\n          const text = reader.result as string;\n          try {\n            const json = JSON.parse(text);\n            resolve(json);\n          } catch (e) {\n            console.error(\"Failed to parse JSON from Blob:\", e);\n          }\n        };\n        reader.readAsText(blob);\n      }\n    });\n\n    let msg = await _parsePromise;\n\n    this.emit(\"message\", msg);\n  }\n}\n\n[\n  \"binaryType\",\n  \"bufferedAmount\",\n  \"extensions\",\n  \"protocol\",\n  \"readyState\",\n  \"url\",\n  \"keepAliveTimeout\",\n  \"keepAliveInterval\",\n  \"shouldRetryFn\",\n  \"connectionTimeout\",\n  \"maxReconnectAttempts\",\n  \"reconnectInterval\",\n].forEach((property) => {\n  Object.defineProperty(ReconnectingWebSocket.prototype, property, {\n    enumerable: true,\n  });\n});\n\n[\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"].forEach((property) => {\n  Object.defineProperty(ReconnectingWebSocket.prototype, property, {\n    enumerable: true,\n    value: readyStates.indexOf(property),\n  });\n});\n\n[\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"].forEach((property) => {\n  Object.defineProperty(ReconnectingWebSocket, property, {\n    enumerable: true,\n    value: readyStates.indexOf(property),\n  });\n});\n","import { Frame } from \"../generated/proto/frames\";\nimport { WebSocketSerializer } from \"./websocketSerializer.ts\";\nimport { RTVIMessage } from \"@pipecat-ai/client-js\";\n\nexport class ProtobufFrameSerializer implements WebSocketSerializer {\n  serialize(data: any): any {}\n  serializeAudio(\n    data: ArrayBuffer,\n    sampleRate: number,\n    numChannels: number,\n  ): Uint8Array {\n    const pcmByteArray = new Uint8Array(data);\n    const frame = Frame.create({\n      frame: {\n        oneofKind: \"audio\",\n        audio: {\n          id: 0n,\n          name: \"audio\",\n          audio: pcmByteArray,\n          sampleRate: sampleRate,\n          numChannels: numChannels,\n        },\n      },\n    });\n    return new Uint8Array(Frame.toBinary(frame));\n  }\n  serializeMessage(msg: RTVIMessage): Uint8Array {\n    const frame = Frame.create({\n      frame: {\n        oneofKind: \"message\",\n        message: {\n          data: JSON.stringify(msg),\n        },\n      },\n    });\n    return new Uint8Array(Frame.toBinary(frame));\n  }\n  async deserialize(\n    data: any,\n  ): Promise<\n    | { type: \"audio\"; audio: Int16Array }\n    | { type: \"message\"; message: RTVIMessage }\n  > {\n    if (!(data instanceof Blob)) {\n      throw new Error(\"Unknown data type\");\n    }\n    const arrayBuffer = await data.arrayBuffer();\n    const parsed = Frame.fromBinary(new Uint8Array(arrayBuffer)).frame;\n    if (parsed.oneofKind === \"audio\") {\n      const audioVector = Array.from(parsed.audio.audio);\n      const uint8Array = new Uint8Array(audioVector);\n      const int16Array = new Int16Array(uint8Array.buffer);\n      return { type: \"audio\", audio: int16Array };\n    } else if (parsed.oneofKind === \"message\") {\n      const msg = JSON.parse(parsed.message.data);\n      return { type: \"message\", message: msg };\n    } else {\n      throw new Error(\"Unknown frame kind\");\n    }\n  }\n}\n","// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies\n// @generated from protobuf file \"proto/frames.proto\" (package \"pipecat\", syntax proto3)\n// tslint:disable\n//\n//\n// Copyright (c) 20242025, Daily\n//\n// SPDX-License-Identifier: BSD 2-Clause License\n//\n//\n//\n// Generate frames_pb2.py with:\n//\n//   python -m grpc_tools.protoc --proto_path=./ --python_out=./protobufs frames.proto\n//\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\n/**\n * @generated from protobuf message pipecat.TextFrame\n */\nexport interface TextFrame {\n    /**\n     * @generated from protobuf field: uint64 id = 1\n     */\n    id: bigint;\n    /**\n     * @generated from protobuf field: string name = 2\n     */\n    name: string;\n    /**\n     * @generated from protobuf field: string text = 3\n     */\n    text: string;\n}\n/**\n * @generated from protobuf message pipecat.AudioRawFrame\n */\nexport interface AudioRawFrame {\n    /**\n     * @generated from protobuf field: uint64 id = 1\n     */\n    id: bigint;\n    /**\n     * @generated from protobuf field: string name = 2\n     */\n    name: string;\n    /**\n     * @generated from protobuf field: bytes audio = 3\n     */\n    audio: Uint8Array;\n    /**\n     * @generated from protobuf field: uint32 sample_rate = 4\n     */\n    sampleRate: number;\n    /**\n     * @generated from protobuf field: uint32 num_channels = 5\n     */\n    numChannels: number;\n    /**\n     * @generated from protobuf field: optional uint64 pts = 6\n     */\n    pts?: bigint;\n}\n/**\n * @generated from protobuf message pipecat.TranscriptionFrame\n */\nexport interface TranscriptionFrame {\n    /**\n     * @generated from protobuf field: uint64 id = 1\n     */\n    id: bigint;\n    /**\n     * @generated from protobuf field: string name = 2\n     */\n    name: string;\n    /**\n     * @generated from protobuf field: string text = 3\n     */\n    text: string;\n    /**\n     * @generated from protobuf field: string user_id = 4\n     */\n    userId: string;\n    /**\n     * @generated from protobuf field: string timestamp = 5\n     */\n    timestamp: string;\n}\n/**\n * @generated from protobuf message pipecat.MessageFrame\n */\nexport interface MessageFrame {\n    /**\n     * @generated from protobuf field: string data = 1\n     */\n    data: string;\n}\n/**\n * @generated from protobuf message pipecat.Frame\n */\nexport interface Frame {\n    /**\n     * @generated from protobuf oneof: frame\n     */\n    frame: {\n        oneofKind: \"text\";\n        /**\n         * @generated from protobuf field: pipecat.TextFrame text = 1\n         */\n        text: TextFrame;\n    } | {\n        oneofKind: \"audio\";\n        /**\n         * @generated from protobuf field: pipecat.AudioRawFrame audio = 2\n         */\n        audio: AudioRawFrame;\n    } | {\n        oneofKind: \"transcription\";\n        /**\n         * @generated from protobuf field: pipecat.TranscriptionFrame transcription = 3\n         */\n        transcription: TranscriptionFrame;\n    } | {\n        oneofKind: \"message\";\n        /**\n         * @generated from protobuf field: pipecat.MessageFrame message = 4\n         */\n        message: MessageFrame;\n    } | {\n        oneofKind: undefined;\n    };\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass TextFrame$Type extends MessageType<TextFrame> {\n    constructor() {\n        super(\"pipecat.TextFrame\", [\n            { no: 1, name: \"id\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 2, name: \"name\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"text\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<TextFrame>): TextFrame {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.id = 0n;\n        message.name = \"\";\n        message.text = \"\";\n        if (value !== undefined)\n            reflectionMergePartial<TextFrame>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TextFrame): TextFrame {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* uint64 id */ 1:\n                    message.id = reader.uint64().toBigInt();\n                    break;\n                case /* string name */ 2:\n                    message.name = reader.string();\n                    break;\n                case /* string text */ 3:\n                    message.text = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: TextFrame, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* uint64 id = 1; */\n        if (message.id !== 0n)\n            writer.tag(1, WireType.Varint).uint64(message.id);\n        /* string name = 2; */\n        if (message.name !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.name);\n        /* string text = 3; */\n        if (message.text !== \"\")\n            writer.tag(3, WireType.LengthDelimited).string(message.text);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message pipecat.TextFrame\n */\nexport const TextFrame = new TextFrame$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AudioRawFrame$Type extends MessageType<AudioRawFrame> {\n    constructor() {\n        super(\"pipecat.AudioRawFrame\", [\n            { no: 1, name: \"id\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 2, name: \"name\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"audio\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 4, name: \"sample_rate\", kind: \"scalar\", T: 13 /*ScalarType.UINT32*/ },\n            { no: 5, name: \"num_channels\", kind: \"scalar\", T: 13 /*ScalarType.UINT32*/ },\n            { no: 6, name: \"pts\", kind: \"scalar\", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }\n        ]);\n    }\n    create(value?: PartialMessage<AudioRawFrame>): AudioRawFrame {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.id = 0n;\n        message.name = \"\";\n        message.audio = new Uint8Array(0);\n        message.sampleRate = 0;\n        message.numChannels = 0;\n        if (value !== undefined)\n            reflectionMergePartial<AudioRawFrame>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AudioRawFrame): AudioRawFrame {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* uint64 id */ 1:\n                    message.id = reader.uint64().toBigInt();\n                    break;\n                case /* string name */ 2:\n                    message.name = reader.string();\n                    break;\n                case /* bytes audio */ 3:\n                    message.audio = reader.bytes();\n                    break;\n                case /* uint32 sample_rate */ 4:\n                    message.sampleRate = reader.uint32();\n                    break;\n                case /* uint32 num_channels */ 5:\n                    message.numChannels = reader.uint32();\n                    break;\n                case /* optional uint64 pts */ 6:\n                    message.pts = reader.uint64().toBigInt();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: AudioRawFrame, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* uint64 id = 1; */\n        if (message.id !== 0n)\n            writer.tag(1, WireType.Varint).uint64(message.id);\n        /* string name = 2; */\n        if (message.name !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.name);\n        /* bytes audio = 3; */\n        if (message.audio.length)\n            writer.tag(3, WireType.LengthDelimited).bytes(message.audio);\n        /* uint32 sample_rate = 4; */\n        if (message.sampleRate !== 0)\n            writer.tag(4, WireType.Varint).uint32(message.sampleRate);\n        /* uint32 num_channels = 5; */\n        if (message.numChannels !== 0)\n            writer.tag(5, WireType.Varint).uint32(message.numChannels);\n        /* optional uint64 pts = 6; */\n        if (message.pts !== undefined)\n            writer.tag(6, WireType.Varint).uint64(message.pts);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message pipecat.AudioRawFrame\n */\nexport const AudioRawFrame = new AudioRawFrame$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TranscriptionFrame$Type extends MessageType<TranscriptionFrame> {\n    constructor() {\n        super(\"pipecat.TranscriptionFrame\", [\n            { no: 1, name: \"id\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 2, name: \"name\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"text\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 4, name: \"user_id\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 5, name: \"timestamp\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<TranscriptionFrame>): TranscriptionFrame {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.id = 0n;\n        message.name = \"\";\n        message.text = \"\";\n        message.userId = \"\";\n        message.timestamp = \"\";\n        if (value !== undefined)\n            reflectionMergePartial<TranscriptionFrame>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TranscriptionFrame): TranscriptionFrame {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* uint64 id */ 1:\n                    message.id = reader.uint64().toBigInt();\n                    break;\n                case /* string name */ 2:\n                    message.name = reader.string();\n                    break;\n                case /* string text */ 3:\n                    message.text = reader.string();\n                    break;\n                case /* string user_id */ 4:\n                    message.userId = reader.string();\n                    break;\n                case /* string timestamp */ 5:\n                    message.timestamp = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: TranscriptionFrame, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* uint64 id = 1; */\n        if (message.id !== 0n)\n            writer.tag(1, WireType.Varint).uint64(message.id);\n        /* string name = 2; */\n        if (message.name !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.name);\n        /* string text = 3; */\n        if (message.text !== \"\")\n            writer.tag(3, WireType.LengthDelimited).string(message.text);\n        /* string user_id = 4; */\n        if (message.userId !== \"\")\n            writer.tag(4, WireType.LengthDelimited).string(message.userId);\n        /* string timestamp = 5; */\n        if (message.timestamp !== \"\")\n            writer.tag(5, WireType.LengthDelimited).string(message.timestamp);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message pipecat.TranscriptionFrame\n */\nexport const TranscriptionFrame = new TranscriptionFrame$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass MessageFrame$Type extends MessageType<MessageFrame> {\n    constructor() {\n        super(\"pipecat.MessageFrame\", [\n            { no: 1, name: \"data\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<MessageFrame>): MessageFrame {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.data = \"\";\n        if (value !== undefined)\n            reflectionMergePartial<MessageFrame>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageFrame): MessageFrame {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string data */ 1:\n                    message.data = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: MessageFrame, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string data = 1; */\n        if (message.data !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.data);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message pipecat.MessageFrame\n */\nexport const MessageFrame = new MessageFrame$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Frame$Type extends MessageType<Frame> {\n    constructor() {\n        super(\"pipecat.Frame\", [\n            { no: 1, name: \"text\", kind: \"message\", oneof: \"frame\", T: () => TextFrame },\n            { no: 2, name: \"audio\", kind: \"message\", oneof: \"frame\", T: () => AudioRawFrame },\n            { no: 3, name: \"transcription\", kind: \"message\", oneof: \"frame\", T: () => TranscriptionFrame },\n            { no: 4, name: \"message\", kind: \"message\", oneof: \"frame\", T: () => MessageFrame }\n        ]);\n    }\n    create(value?: PartialMessage<Frame>): Frame {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.frame = { oneofKind: undefined };\n        if (value !== undefined)\n            reflectionMergePartial<Frame>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Frame): Frame {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* pipecat.TextFrame text */ 1:\n                    message.frame = {\n                        oneofKind: \"text\",\n                        text: TextFrame.internalBinaryRead(reader, reader.uint32(), options, (message.frame as any).text)\n                    };\n                    break;\n                case /* pipecat.AudioRawFrame audio */ 2:\n                    message.frame = {\n                        oneofKind: \"audio\",\n                        audio: AudioRawFrame.internalBinaryRead(reader, reader.uint32(), options, (message.frame as any).audio)\n                    };\n                    break;\n                case /* pipecat.TranscriptionFrame transcription */ 3:\n                    message.frame = {\n                        oneofKind: \"transcription\",\n                        transcription: TranscriptionFrame.internalBinaryRead(reader, reader.uint32(), options, (message.frame as any).transcription)\n                    };\n                    break;\n                case /* pipecat.MessageFrame message */ 4:\n                    message.frame = {\n                        oneofKind: \"message\",\n                        message: MessageFrame.internalBinaryRead(reader, reader.uint32(), options, (message.frame as any).message)\n                    };\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Frame, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* pipecat.TextFrame text = 1; */\n        if (message.frame.oneofKind === \"text\")\n            TextFrame.internalBinaryWrite(message.frame.text, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* pipecat.AudioRawFrame audio = 2; */\n        if (message.frame.oneofKind === \"audio\")\n            AudioRawFrame.internalBinaryWrite(message.frame.audio, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        /* pipecat.TranscriptionFrame transcription = 3; */\n        if (message.frame.oneofKind === \"transcription\")\n            TranscriptionFrame.internalBinaryWrite(message.frame.transcription, writer.tag(3, WireType.LengthDelimited).fork(), options).join();\n        /* pipecat.MessageFrame message = 4; */\n        if (message.frame.oneofKind === \"message\")\n            MessageFrame.internalBinaryWrite(message.frame.message, writer.tag(4, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message pipecat.Frame\n */\nexport const Frame = new Frame$Type();\n","import { WebSocketSerializer } from \"./websocketSerializer.ts\";\nimport { RTVIMessage } from \"@pipecat-ai/client-js\";\nimport { mulaw } from \"x-law\";\n\nexport class TwilioSerializer implements WebSocketSerializer {\n  serialize(data: any): string {\n    return JSON.stringify(data);\n  }\n\n  serializeAudio(\n    data: ArrayBuffer,\n    sampleRate: number,\n    numChannels: number,\n  ): string {\n    const pcmSamples = new Int16Array(data);\n    const muLawSamples = mulaw.encode(pcmSamples);\n    const base64Payload = this.arrayToBase64(muLawSamples);\n    const twilioMessage = {\n      event: \"media\",\n      media: {\n        payload: base64Payload,\n      },\n    };\n    return JSON.stringify(twilioMessage);\n  }\n\n  serializeMessage(msg: RTVIMessage): any {\n    // Twilio does not support RTVI messages, so just ignore them\n    return null;\n  }\n\n  private arrayToBase64(bytes: Uint8Array): string {\n    let binary = \"\";\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n  }\n\n  private base64ToUint8Array(base64: string): Uint8Array {\n    const binaryString = atob(base64);\n    const len = binaryString.length;\n    const bytes = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n  }\n\n  async deserialize(\n    data: any,\n  ): Promise<\n    | { type: \"audio\"; audio: Int16Array }\n    | { type: \"message\"; message: RTVIMessage }\n    | { type: \"raw\"; message: any }\n  > {\n    const jsonMessage = JSON.parse(data); // Assuming 'data' is a JSON string\n    if (jsonMessage.event === \"clear\") {\n      return {\n        type: \"raw\",\n        message: jsonMessage,\n      };\n    } else if (jsonMessage.event === \"media\") {\n      // Deserialize 'media' event\n      const payload = jsonMessage.media.payload;\n      const serialized_data = this.base64ToUint8Array(payload);\n      //const decoded_audio = this.ulawToPcm(serialized_data);\n      const decoded_audio = mulaw.decode(serialized_data);\n\n      return { type: \"audio\", audio: decoded_audio };\n    } else {\n      // Deserialize other message types (assuming 'frame' has 'message' field)\n      return { type: \"message\", message: jsonMessage.message };\n    }\n  }\n}\n"],"names":[],"version":3,"file":"index.module.js.map"}