import { RTVIClientOptions, RTVIEventCallbacks, Tracks, RTVIMessage, Transport, TransportState } from "@pipecat-ai/client-js";
import { DailyEventObjectTrack } from "@daily-co/daily-js";
import { EventEmitter } from "events";
declare abstract class MediaManager {
    protected _userAudioCallback: (data: ArrayBuffer) => void;
    protected _options: RTVIClientOptions;
    protected _callbacks: RTVIEventCallbacks;
    protected _micEnabled: boolean;
    protected _camEnabled: boolean;
    constructor();
    setUserAudioCallback(userAudioCallback: (data: ArrayBuffer) => void): void;
    setRTVIOptions(options: RTVIClientOptions, override?: boolean): void;
    abstract initialize(): Promise<void>;
    abstract connect(): Promise<void>;
    abstract disconnect(): Promise<void>;
    abstract userStartedSpeaking(): Promise<unknown>;
    abstract bufferBotAudio(data: ArrayBuffer | Int16Array, id?: string): Int16Array | undefined;
    abstract getAllMics(): Promise<MediaDeviceInfo[]>;
    abstract getAllCams(): Promise<MediaDeviceInfo[]>;
    abstract getAllSpeakers(): Promise<MediaDeviceInfo[]>;
    abstract updateMic(micId: string): void;
    abstract updateCam(camId: string): void;
    abstract updateSpeaker(speakerId: string): void;
    abstract get selectedMic(): MediaDeviceInfo | Record<string, never>;
    abstract get selectedCam(): MediaDeviceInfo | Record<string, never>;
    abstract get selectedSpeaker(): MediaDeviceInfo | Record<string, never>;
    abstract enableMic(enable: boolean): void;
    abstract enableCam(enable: boolean): void;
    abstract get isCamEnabled(): boolean;
    abstract get isMicEnabled(): boolean;
    abstract tracks(): Tracks;
}
export class WavMediaManager extends MediaManager {
    constructor(recorderChunkSize?: number | undefined, recorderSampleRate?: number | undefined);
    initialize(): Promise<void>;
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    userStartedSpeaking(): Promise<unknown>;
    bufferBotAudio(data: ArrayBuffer | Int16Array, id?: string): Int16Array;
    getAllMics(): Promise<MediaDeviceInfo[]>;
    getAllCams(): Promise<MediaDeviceInfo[]>;
    getAllSpeakers(): Promise<MediaDeviceInfo[]>;
    updateMic(micId: string): Promise<void>;
    updateCam(camId: string): void;
    updateSpeaker(speakerId: string): void;
    get selectedMic(): MediaDeviceInfo | Record<string, never>;
    get selectedCam(): MediaDeviceInfo | Record<string, never>;
    get selectedSpeaker(): MediaDeviceInfo | Record<string, never>;
    enableMic(enable: boolean): Promise<void>;
    enableCam(enable: boolean): void;
    get isCamEnabled(): boolean;
    get isMicEnabled(): boolean;
    tracks(): Tracks;
}
export class DailyMediaManager extends MediaManager {
    constructor(enablePlayer?: boolean, enableRecording?: boolean, onTrackStartedCallback?: (event: DailyEventObjectTrack) => void, onTrackStoppedCallback?: (event: DailyEventObjectTrack) => void, recorderChunkSize?: number | undefined, recorderSampleRate?: number, playerSampleRate?: number);
    initialize(): Promise<void>;
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    userStartedSpeaking(): Promise<unknown>;
    bufferBotAudio(data: ArrayBuffer | Int16Array, id?: string): Int16Array | undefined;
    getAllMics(): Promise<MediaDeviceInfo[]>;
    getAllCams(): Promise<MediaDeviceInfo[]>;
    getAllSpeakers(): Promise<MediaDeviceInfo[]>;
    updateMic(micId: string): void;
    updateCam(camId: string): void;
    updateSpeaker(speakerId: string): Promise<void>;
    get selectedMic(): MediaDeviceInfo | Record<string, never>;
    get selectedCam(): MediaDeviceInfo | Record<string, never>;
    get selectedSpeaker(): MediaDeviceInfo | Record<string, never>;
    enableMic(enable: boolean): Promise<void>;
    enableCam(enable: boolean): void;
    get isCamEnabled(): boolean;
    get isMicEnabled(): boolean;
    tracks(): Tracks;
    protected handleTrackStarted(event: DailyEventObjectTrack): Promise<void>;
    protected handleTrackStopped(event: DailyEventObjectTrack): void;
}
interface WebSocketOptions {
    parseBlobToJson?: boolean;
}
/**
 * Builds on top of Javascript Websockets
 *
 * This behaves like the Websocket library in every way, except if it fails to
 * connect or if it gets disconnected, it will try to reconnect depending on
 * the maximum number of reconnect attempts set. retry is not enabled for initial
 * connection. When initial connection fails it is best to check yourself before
 * you keep wreckin' yourself.
 *
 * It is API compatible, so when you have:
 *   ws = new WebSocket('ws://....');
 * you can replace with:
 *   ws = new ReconnectingWebSocket('ws://....');
 *
 * While it is API compatible with the NodeJS ws library, we provide the
 * following additional properties and events on the ReconnectingWebSocket.
 *
 * Events:
 *
 * connection-timeout
 * - Emitted when the web socket connection times out.
 *
 * reconnecting
 * - Emitted after a manual close of the web socket is done and before retrying
 *   the connection.
 *
 * reconnect-failed
 * - Emitted when the number of connection attempts exceeds the set number of
 *   reconnection attempts.
 *
 * keep-alive
 * - Emitted when the set keep alive interval elapses. This event may be used
 *   to have ping pong keep-alive mechanism for web socket health.
 *
 * Properties:
 *
 * keepAliveTimeout
 * - The timeout for keep-alive. Default: 15000
 *
 * keepAliveInterval
 * - The interval at which to emit keep-alive event. Default: 5000
 *
 * shouldRetryFn
 * - A callback function which should return boolean to determine if a web
 *   socket reconnection attempt should be made. When not set, connection is
 *   always retried.
 *
 * connectionTimeout
 * - The timeout interval for considering whether the connection timed out.
 *   Default: 20000 ms
 *
 * maxReconnectAttempts
 * - The maximum number of attempts to be made for reconnection. Default: 2
 *
 * reconnectInterval
 * - The interval to wait before attempting a reconnection. Default: 1000 ms
 */
declare class ReconnectingWebSocket extends EventEmitter {
    /** The connection is not yet open. */
    static readonly CONNECTING: 0;
    /** The connection is open and ready to communicate. */
    static readonly OPEN: 1;
    /** The connection is in the process of closing. */
    static readonly CLOSING: 2;
    /** The connection is closed. */
    static readonly CLOSED: 3;
    _url: string;
    _protocols: string | string[] | undefined;
    constructor(address: string, protocols?: string | string[], options?: WebSocketOptions);
    connect(): Promise<unknown>;
    send(data: any): Promise<void>;
    close(): Promise<void>;
    get readyState(): number;
    get url(): string;
    get keepAliveTimeout(): number;
    set keepAliveTimeout(keepAliveTimeout: number);
    get keepAliveInterval(): number;
    set keepAliveInterval(keepAliveInterval: number);
    set shouldRetryFn(cb: () => boolean);
    get connectionTimeout(): number;
    set connectionTimeout(timeout: number);
    get maxReconnectAttempts(): number;
    set maxReconnectAttempts(attempts: number);
    get reconnectInterval(): number;
    set reconnectInterval(interval: number);
    _handleMessage(event: MessageEvent): Promise<void>;
}
interface WebSocketSerializer {
    serialize(data: any): any;
    serializeAudio(data: ArrayBuffer, sampleRate: number, numChannels: number): any;
    serializeMessage(msg: RTVIMessage): any;
    deserialize(data: any): Promise<{
        type: "audio";
        audio: Int16Array;
    } | {
        type: "message";
        message: RTVIMessage;
    } | {
        type: "raw";
        message: any;
    }>;
}
export class ProtobufFrameSerializer implements WebSocketSerializer {
    serialize(data: any): any;
    serializeAudio(data: ArrayBuffer, sampleRate: number, numChannels: number): Uint8Array;
    serializeMessage(msg: RTVIMessage): Uint8Array;
    deserialize(data: any): Promise<{
        type: "audio";
        audio: Int16Array;
    } | {
        type: "message";
        message: RTVIMessage;
    }>;
}
export class WebSocketTransport extends Transport {
    constructor({ serializer, recorderSampleRate, playerSampleRate, }?: {
        serializer: WebSocketSerializer;
        recorderSampleRate?: number;
        playerSampleRate?: number;
    });
    initialize(options: RTVIClientOptions, messageHandler: (ev: RTVIMessage) => void): void;
    initDevices(): Promise<void>;
    connect(authBundle: unknown, abortController: AbortController): Promise<void>;
    disconnect(): Promise<void>;
    getAllMics(): Promise<MediaDeviceInfo[]>;
    getAllCams(): Promise<MediaDeviceInfo[]>;
    getAllSpeakers(): Promise<MediaDeviceInfo[]>;
    updateMic(micId: string): Promise<void>;
    updateCam(camId: string): void;
    updateSpeaker(speakerId: string): void;
    get selectedMic(): MediaDeviceInfo | Record<string, never>;
    get selectedSpeaker(): MediaDeviceInfo | Record<string, never>;
    enableMic(enable: boolean): void;
    get isMicEnabled(): boolean;
    get state(): TransportState;
    set state(state: TransportState);
    get expiry(): number | undefined;
    tracks(): Tracks;
    initializeWebsocket(authBundle: any): ReconnectingWebSocket;
    sendReadyMessage(): void;
    handleUserAudioStream(data: ArrayBuffer): void;
    sendRawMessage(message: any): void;
    sendMessage(message: RTVIMessage): void;
    _sendAudioInput(data: ArrayBuffer): Promise<void>;
    _sendMsg(msg: any): Promise<void>;
    connectionError(errorMsg: string): void;
    enableScreenShare(enable: boolean): void;
    get isSharingScreen(): boolean;
    enableCam(enable: boolean): void;
    get isCamEnabled(): boolean;
    get selectedCam(): MediaDeviceInfo | Record<string, never>;
}
export class TwilioSerializer implements WebSocketSerializer {
    serialize(data: any): string;
    serializeAudio(data: ArrayBuffer, sampleRate: number, numChannels: number): string;
    serializeMessage(msg: RTVIMessage): any;
    deserialize(data: any): Promise<{
        type: "audio";
        audio: Int16Array;
    } | {
        type: "message";
        message: RTVIMessage;
    } | {
        type: "raw";
        message: any;
    }>;
}

//# sourceMappingURL=index.d.ts.map
