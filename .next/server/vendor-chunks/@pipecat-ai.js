"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@pipecat-ai";
exports.ids = ["vendor-chunks/@pipecat-ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/@pipecat-ai/client-js/dist/index.module.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@pipecat-ai/client-js/dist/index.module.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionEndpointNotSetError: () => (/* binding */ $8ead7b33b8402751$export$be839f0100cd3132),\n/* harmony export */   BotNotReadyError: () => (/* binding */ $8ead7b33b8402751$export$885fb96b850e8fbb),\n/* harmony export */   ConfigUpdateError: () => (/* binding */ $8ead7b33b8402751$export$4eda4fd287fbbca5),\n/* harmony export */   ConnectionTimeoutError: () => (/* binding */ $8ead7b33b8402751$export$c67992fa684a81a6),\n/* harmony export */   LLMActionType: () => (/* binding */ $0908f693e3e0724c$export$43cdfb26f790451),\n/* harmony export */   LLMHelper: () => (/* binding */ $0908f693e3e0724c$export$3cf39a62d076dd5c),\n/* harmony export */   LLMMessageType: () => (/* binding */ $0908f693e3e0724c$export$441bcd2e10762760),\n/* harmony export */   LogLevel: () => (/* binding */ $7afbbd59ebaa42bf$export$243e62d78d3b544d),\n/* harmony export */   MessageDispatcher: () => (/* binding */ $b48f893ed1354c1e$export$e9a960646cc432aa),\n/* harmony export */   RTVIActionRequest: () => (/* binding */ $b48f893ed1354c1e$export$378529d7a8bead8b),\n/* harmony export */   RTVIClient: () => (/* binding */ $a7c324a73303ad55$export$fa42a01c1d60f4a1),\n/* harmony export */   RTVIClientHelper: () => (/* binding */ $7614fb2168c523cc$export$23bc637255b2a471),\n/* harmony export */   RTVIError: () => (/* binding */ $8ead7b33b8402751$export$59b4786f333aac02),\n/* harmony export */   RTVIEvent: () => (/* binding */ $f9fc0c57b9aaed9c$export$6b4624d233c61fcb),\n/* harmony export */   RTVIMessage: () => (/* binding */ $b48f893ed1354c1e$export$69aa9ab0334b212),\n/* harmony export */   RTVIMessageType: () => (/* binding */ $b48f893ed1354c1e$export$38b3db05cbf0e240),\n/* harmony export */   RTVI_MESSAGE_LABEL: () => (/* binding */ $b48f893ed1354c1e$export$882b13c7fda338f5),\n/* harmony export */   StartBotError: () => (/* binding */ $8ead7b33b8402751$export$e7544ab812238a61),\n/* harmony export */   Transport: () => (/* binding */ $4086f06442fcb7d7$export$86495b081fef8e52),\n/* harmony export */   TransportStartError: () => (/* binding */ $8ead7b33b8402751$export$e0624a511a2c4e9),\n/* harmony export */   TransportWrapper: () => (/* binding */ $4086f06442fcb7d7$export$82b6ede160a64a3c),\n/* harmony export */   httpActionGenerator: () => (/* binding */ $4bb349f22aee5185$export$8728b60ea57bf43e),\n/* harmony export */   logger: () => (/* binding */ $7afbbd59ebaa42bf$export$af88d00dbe7f521)\n/* harmony export */ });\n/* harmony import */ var clone_deep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clone-deep */ \"(ssr)/./node_modules/clone-deep/index.js\");\n/* harmony import */ var clone_deep__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(clone_deep__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/uuid/dist/esm-node/v4.js\");\n\n\n\n\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */ var $4bb349f22aee5185$exports = {};\n\n$parcel$export($4bb349f22aee5185$exports, \"httpActionGenerator\", () => $4bb349f22aee5185$export$8728b60ea57bf43e);\n/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */ \nasync function $4bb349f22aee5185$export$8728b60ea57bf43e(actionUrl, action, params, handleResponse) {\n    try {\n        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(\"[RTVI] Fetch action\", actionUrl, action);\n        const headers = new Headers({\n            ...Object.fromEntries((params.headers ?? new Headers()).entries())\n        });\n        if (!headers.has(\"Content-Type\")) headers.set(\"Content-Type\", \"application/json\");\n        headers.set(\"Cache-Control\", \"no-cache\");\n        headers.set(\"Connection\", \"keep-alive\");\n        // Perform the fetch request\n        const response = await fetch(actionUrl, {\n            method: \"POST\",\n            headers: headers,\n            body: JSON.stringify({\n                ...params.requestData,\n                actions: [\n                    action\n                ]\n            })\n        });\n        // Check the response content type\n        const contentType = response.headers.get(\"content-type\");\n        // Handle non-ok response status\n        if (!response.ok) {\n            const errorMessage = await response.text();\n            throw new (0, $8ead7b33b8402751$export$59b4786f333aac02)(`Failed to resolve action: ${errorMessage}`, response.status);\n        }\n        if (response.body && contentType?.includes(\"text/event-stream\")) {\n            // Parse streamed responses\n            const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();\n            let buffer = \"\";\n            while(true){\n                const { value: value, done: done } = await reader.read();\n                if (done) break;\n                buffer += value;\n                let boundary = buffer.indexOf(\"\\n\\n\");\n                while(boundary !== -1){\n                    const message = buffer.slice(0, boundary);\n                    buffer = buffer.slice(boundary + 2);\n                    // Split on the first \":\" to extract the JSON part\n                    const lines = message.split(\"\\n\");\n                    let encodedData = \"\";\n                    for (const line of lines){\n                        const colonIndex = line.indexOf(\":\");\n                        if (colonIndex !== -1) encodedData += line.slice(colonIndex + 1).trim();\n                    }\n                    try {\n                        const jsonData = atob(encodedData);\n                        const parsedData = JSON.parse(jsonData);\n                        handleResponse(parsedData);\n                    } catch (error) {\n                        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error(\"[RTVI] Failed to parse JSON:\", error);\n                        throw error;\n                    }\n                    boundary = buffer.indexOf(\"\\n\\n\");\n                }\n            }\n        } else {\n            // For regular non-streamed responses, parse and handle the data as JSON\n            const data = await response.json();\n            handleResponse(data);\n        }\n    } catch (error) {\n        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error(\"[RTVI] Error during fetch:\", error);\n        throw error;\n    }\n} /*\n//@TODO: implement abortController when mode changes / bad things happen\nexport async function dispatchAction(\n  this: RTVIClient,\n  action: RTVIActionRequest\n): Promise<RTVIActionResponse> {\n  const promise = new Promise((resolve, reject) => {\n    (async () => {\n      if (this.connected) {\n        return this._messageDispatcher.dispatch(action);\n      } else {\n        const actionUrl = this.constructUrl(\"action\");\n        try {\n          const result = await httpActionGenerator(\n            actionUrl,\n            action,\n            this.params,\n            (response) => {\n              this.handleMessage(response);\n            }\n          );\n          resolve(result);\n        } catch (error) {\n          reject(error);\n        }\n      }\n    })();\n  });\n\n  return promise as Promise<RTVIActionResponse>;\n}\n*/ \n\n\nvar $a7c324a73303ad55$exports = {};\n\n$parcel$export($a7c324a73303ad55$exports, \"RTVIClient\", () => $a7c324a73303ad55$export$fa42a01c1d60f4a1);\n/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */ \n\nvar $e3bad9cc25e327f7$exports = {};\n$e3bad9cc25e327f7$exports = JSON.parse(\"{\\\"name\\\":\\\"@pipecat-ai/client-js\\\",\\\"version\\\":\\\"0.4.1\\\",\\\"license\\\":\\\"BSD-2-Clause\\\",\\\"main\\\":\\\"dist/index.js\\\",\\\"module\\\":\\\"dist/index.module.js\\\",\\\"types\\\":\\\"dist/index.d.ts\\\",\\\"source\\\":\\\"src/index.ts\\\",\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https://github.com/pipecat-ai/pipecat-client-web.git\\\"},\\\"files\\\":[\\\"dist\\\",\\\"package.json\\\",\\\"README.md\\\"],\\\"scripts\\\":{\\\"build\\\":\\\"jest --silent && parcel build --no-cache\\\",\\\"dev\\\":\\\"parcel watch\\\",\\\"lint\\\":\\\"eslint src/ --report-unused-disable-directives --max-warnings 0\\\",\\\"test\\\":\\\"jest\\\"},\\\"jest\\\":{\\\"preset\\\":\\\"ts-jest\\\",\\\"testEnvironment\\\":\\\"node\\\"},\\\"devDependencies\\\":{\\\"@jest/globals\\\":\\\"^29.7.0\\\",\\\"@types/clone-deep\\\":\\\"^4.0.4\\\",\\\"@types/jest\\\":\\\"^29.5.12\\\",\\\"@types/uuid\\\":\\\"^10.0.0\\\",\\\"eslint\\\":\\\"^9.11.1\\\",\\\"eslint-config-prettier\\\":\\\"^9.1.0\\\",\\\"eslint-plugin-simple-import-sort\\\":\\\"^12.1.1\\\",\\\"jest\\\":\\\"^29.7.0\\\",\\\"ts-jest\\\":\\\"^29.2.5\\\"},\\\"dependencies\\\":{\\\"@types/events\\\":\\\"^3.0.3\\\",\\\"clone-deep\\\":\\\"^4.0.1\\\",\\\"events\\\":\\\"^3.3.0\\\",\\\"typed-emitter\\\":\\\"^2.1.0\\\",\\\"uuid\\\":\\\"^10.0.0\\\"}}\");\n\n\n/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */ var $8ead7b33b8402751$exports = {};\n\n$parcel$export($8ead7b33b8402751$exports, \"RTVIError\", () => $8ead7b33b8402751$export$59b4786f333aac02);\n$parcel$export($8ead7b33b8402751$exports, \"ConnectionTimeoutError\", () => $8ead7b33b8402751$export$c67992fa684a81a6);\n$parcel$export($8ead7b33b8402751$exports, \"StartBotError\", () => $8ead7b33b8402751$export$e7544ab812238a61);\n$parcel$export($8ead7b33b8402751$exports, \"TransportStartError\", () => $8ead7b33b8402751$export$e0624a511a2c4e9);\n$parcel$export($8ead7b33b8402751$exports, \"BotNotReadyError\", () => $8ead7b33b8402751$export$885fb96b850e8fbb);\n$parcel$export($8ead7b33b8402751$exports, \"ConfigUpdateError\", () => $8ead7b33b8402751$export$4eda4fd287fbbca5);\n$parcel$export($8ead7b33b8402751$exports, \"ActionEndpointNotSetError\", () => $8ead7b33b8402751$export$be839f0100cd3132);\n/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */ class $8ead7b33b8402751$export$59b4786f333aac02 extends Error {\n    constructor(message, status){\n        super(message);\n        this.status = status;\n    }\n}\nclass $8ead7b33b8402751$export$c67992fa684a81a6 extends $8ead7b33b8402751$export$59b4786f333aac02 {\n    constructor(message){\n        super(message ?? \"Bot did not enter ready state within the specified timeout period.\");\n    }\n}\nclass $8ead7b33b8402751$export$e7544ab812238a61 extends $8ead7b33b8402751$export$59b4786f333aac02 {\n    constructor(message, status){\n        super(message ?? `Failed to connect / invalid auth bundle from base url`, status ?? 500);\n        this.error = \"invalid-request-error\";\n    }\n}\nclass $8ead7b33b8402751$export$e0624a511a2c4e9 extends $8ead7b33b8402751$export$59b4786f333aac02 {\n    constructor(message){\n        super(message ?? \"Unable to connect to transport\");\n    }\n}\nclass $8ead7b33b8402751$export$885fb96b850e8fbb extends $8ead7b33b8402751$export$59b4786f333aac02 {\n    constructor(message){\n        super(message ?? \"Attempt to call action on transport when not in 'ready' state.\");\n    }\n}\nclass $8ead7b33b8402751$export$4eda4fd287fbbca5 extends $8ead7b33b8402751$export$59b4786f333aac02 {\n    constructor(message){\n        super(message ?? \"Unable to update configuration\");\n        this.status = 400;\n    }\n}\nclass $8ead7b33b8402751$export$be839f0100cd3132 extends $8ead7b33b8402751$export$59b4786f333aac02 {\n    constructor(message){\n        super(message ?? \"Action endpoint is not set\");\n    }\n}\n\n\nfunction $16f019d4d16917df$export$f1586721024c4dab(_target, propertyKey, descriptor) {\n    const originalMethod = descriptor.value;\n    descriptor.value = function(...args) {\n        if (this.state === \"ready\") return originalMethod.apply(this, args);\n        else throw new (0, $8ead7b33b8402751$export$885fb96b850e8fbb)(`Attempt to call ${propertyKey.toString()} when transport not in ready state. Await connect() first.`);\n    };\n    return descriptor;\n}\nfunction $16f019d4d16917df$export$808994d0d8c9acb3(states) {\n    return function(_target, propertyKey, descriptor) {\n        const originalMethod = descriptor.value;\n        descriptor.get = function(...args) {\n            if (states.includes(this.state)) return originalMethod.apply(this, args);\n            else throw new (0, $8ead7b33b8402751$export$885fb96b850e8fbb)(`Attempt to call ${propertyKey.toString()} when transport not in ${states}.`);\n        };\n        return descriptor;\n    };\n}\nfunction $16f019d4d16917df$export$5c35b4fe6fa8c9a6(...states) {\n    states = [\n        \"ready\",\n        ...states\n    ];\n    return function(_target, propertyKey, descriptor) {\n        const originalGetter = descriptor.get;\n        descriptor.get = function() {\n            if (states.includes(this.state)) return originalGetter?.apply(this);\n            else throw new (0, $8ead7b33b8402751$export$885fb96b850e8fbb)(`Attempt to call ${propertyKey.toString()} when transport not in ${states}. Await connect() first.`);\n        };\n        return descriptor;\n    };\n}\n\n\n\nvar $f9fc0c57b9aaed9c$exports = {};\n\n$parcel$export($f9fc0c57b9aaed9c$exports, \"RTVIEvent\", () => $f9fc0c57b9aaed9c$export$6b4624d233c61fcb);\n/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */ var $f9fc0c57b9aaed9c$export$6b4624d233c61fcb;\n(function(RTVIEvent) {\n    RTVIEvent[\"MessageError\"] = \"messageError\";\n    RTVIEvent[\"Error\"] = \"error\";\n    RTVIEvent[\"Connected\"] = \"connected\";\n    RTVIEvent[\"Disconnected\"] = \"disconnected\";\n    RTVIEvent[\"TransportStateChanged\"] = \"transportStateChanged\";\n    RTVIEvent[\"Config\"] = \"config\";\n    RTVIEvent[\"ConfigDescribe\"] = \"configDescribe\";\n    RTVIEvent[\"ActionsAvailable\"] = \"actionsAvailable\";\n    RTVIEvent[\"ParticipantConnected\"] = \"participantConnected\";\n    RTVIEvent[\"ParticipantLeft\"] = \"participantLeft\";\n    RTVIEvent[\"TrackStarted\"] = \"trackStarted\";\n    RTVIEvent[\"TrackStopped\"] = \"trackStopped\";\n    RTVIEvent[\"ScreenTrackStarted\"] = \"screenTrackStarted\";\n    RTVIEvent[\"ScreenTrackStopped\"] = \"screenTrackStopped\";\n    RTVIEvent[\"ScreenShareError\"] = \"screenShareError\";\n    RTVIEvent[\"AvailableCamsUpdated\"] = \"availableCamsUpdated\";\n    RTVIEvent[\"AvailableMicsUpdated\"] = \"availableMicsUpdated\";\n    RTVIEvent[\"AvailableSpeakersUpdated\"] = \"availableSpeakersUpdated\";\n    RTVIEvent[\"CamUpdated\"] = \"camUpdated\";\n    RTVIEvent[\"MicUpdated\"] = \"micUpdated\";\n    RTVIEvent[\"SpeakerUpdated\"] = \"speakerUpdated\";\n    RTVIEvent[\"BotConnected\"] = \"botConnected\";\n    RTVIEvent[\"BotReady\"] = \"botReady\";\n    RTVIEvent[\"BotDisconnected\"] = \"botDisconnected\";\n    RTVIEvent[\"BotStartedSpeaking\"] = \"botStartedSpeaking\";\n    RTVIEvent[\"BotStoppedSpeaking\"] = \"botStoppedSpeaking\";\n    RTVIEvent[\"RemoteAudioLevel\"] = \"remoteAudioLevel\";\n    RTVIEvent[\"UserStartedSpeaking\"] = \"userStartedSpeaking\";\n    RTVIEvent[\"UserStoppedSpeaking\"] = \"userStoppedSpeaking\";\n    RTVIEvent[\"LocalAudioLevel\"] = \"localAudioLevel\";\n    RTVIEvent[\"Metrics\"] = \"metrics\";\n    RTVIEvent[\"UserTranscript\"] = \"userTranscript\";\n    RTVIEvent[\"BotTranscript\"] = \"botTranscript\";\n    RTVIEvent[\"BotLlmText\"] = \"botLlmText\";\n    RTVIEvent[\"BotLlmStarted\"] = \"botLlmStarted\";\n    RTVIEvent[\"BotLlmStopped\"] = \"botLlmStopped\";\n    RTVIEvent[\"BotTtsText\"] = \"botTtsText\";\n    RTVIEvent[\"BotTtsStarted\"] = \"botTtsStarted\";\n    RTVIEvent[\"BotTtsStopped\"] = \"botTtsStopped\";\n    RTVIEvent[\"LLMFunctionCall\"] = \"llmFunctionCall\";\n    RTVIEvent[\"LLMFunctionCallStart\"] = \"llmFunctionCallStart\";\n    RTVIEvent[\"LLMJsonCompletion\"] = \"llmJsonCompletion\";\n    RTVIEvent[\"StorageItemStored\"] = \"storageItemStored\";\n    RTVIEvent[\"BotLlmSearchResponse\"] = \"botLlmSearchResponse\";\n    RTVIEvent[\"ServerMessage\"] = \"serverMessage\";\n})($f9fc0c57b9aaed9c$export$6b4624d233c61fcb || ($f9fc0c57b9aaed9c$export$6b4624d233c61fcb = {}));\n\n\nvar $7614fb2168c523cc$exports = {};\n\n$parcel$export($7614fb2168c523cc$exports, \"RTVIClientHelper\", () => $7614fb2168c523cc$export$23bc637255b2a471);\n/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */ class $7614fb2168c523cc$export$23bc637255b2a471 {\n    constructor(options){\n        this._options = options;\n    }\n    set client(client) {\n        this._client = client;\n    }\n    set service(service) {\n        this._service = service;\n    }\n}\n\n\nvar $7afbbd59ebaa42bf$exports = {};\n\n$parcel$export($7afbbd59ebaa42bf$exports, \"LogLevel\", () => $7afbbd59ebaa42bf$export$243e62d78d3b544d);\n$parcel$export($7afbbd59ebaa42bf$exports, \"logger\", () => $7afbbd59ebaa42bf$export$af88d00dbe7f521);\n/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */ var $7afbbd59ebaa42bf$export$243e62d78d3b544d;\n(function(LogLevel) {\n    LogLevel[LogLevel[\"NONE\"] = 0] = \"NONE\";\n    LogLevel[LogLevel[\"ERROR\"] = 1] = \"ERROR\";\n    LogLevel[LogLevel[\"WARN\"] = 2] = \"WARN\";\n    LogLevel[LogLevel[\"INFO\"] = 3] = \"INFO\";\n    LogLevel[LogLevel[\"DEBUG\"] = 4] = \"DEBUG\";\n})($7afbbd59ebaa42bf$export$243e62d78d3b544d || ($7afbbd59ebaa42bf$export$243e62d78d3b544d = {}));\nclass $7afbbd59ebaa42bf$var$Logger {\n    constructor(){\n        this.level = $7afbbd59ebaa42bf$export$243e62d78d3b544d.DEBUG;\n    }\n    static getInstance() {\n        if (!$7afbbd59ebaa42bf$var$Logger.instance) $7afbbd59ebaa42bf$var$Logger.instance = new $7afbbd59ebaa42bf$var$Logger();\n        return $7afbbd59ebaa42bf$var$Logger.instance;\n    }\n    setLevel(level) {\n        this.level = level;\n    }\n    debug(...args) {\n        if (this.level >= $7afbbd59ebaa42bf$export$243e62d78d3b544d.DEBUG) console.debug(...args);\n    }\n    info(...args) {\n        if (this.level >= $7afbbd59ebaa42bf$export$243e62d78d3b544d.INFO) console.info(...args);\n    }\n    warn(...args) {\n        if (this.level >= $7afbbd59ebaa42bf$export$243e62d78d3b544d.WARN) console.warn(...args);\n    }\n    error(...args) {\n        if (this.level >= $7afbbd59ebaa42bf$export$243e62d78d3b544d.ERROR) console.error(...args);\n    }\n}\nconst $7afbbd59ebaa42bf$export$af88d00dbe7f521 = $7afbbd59ebaa42bf$var$Logger.getInstance();\n\n\nvar $b48f893ed1354c1e$exports = {};\n\n$parcel$export($b48f893ed1354c1e$exports, \"RTVI_MESSAGE_LABEL\", () => $b48f893ed1354c1e$export$882b13c7fda338f5);\n$parcel$export($b48f893ed1354c1e$exports, \"RTVIMessageType\", () => $b48f893ed1354c1e$export$38b3db05cbf0e240);\n$parcel$export($b48f893ed1354c1e$exports, \"RTVIMessage\", () => $b48f893ed1354c1e$export$69aa9ab0334b212);\n$parcel$export($b48f893ed1354c1e$exports, \"RTVIActionRequest\", () => $b48f893ed1354c1e$export$378529d7a8bead8b);\n$parcel$export($b48f893ed1354c1e$exports, \"MessageDispatcher\", () => $b48f893ed1354c1e$export$e9a960646cc432aa);\n/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */ \n\n\n\nconst $b48f893ed1354c1e$export$882b13c7fda338f5 = \"rtvi-ai\";\nvar $b48f893ed1354c1e$export$38b3db05cbf0e240;\n(function(RTVIMessageType) {\n    // Outbound\n    RTVIMessageType[\"CLIENT_READY\"] = \"client-ready\";\n    RTVIMessageType[\"UPDATE_CONFIG\"] = \"update-config\";\n    RTVIMessageType[\"GET_CONFIG\"] = \"get-config\";\n    RTVIMessageType[\"DESCRIBE_CONFIG\"] = \"describe-config\";\n    RTVIMessageType[\"DESCRIBE_ACTIONS\"] = \"describe-actions\";\n    RTVIMessageType[\"DISCONNECT_BOT\"] = \"disconnect-bot\";\n    RTVIMessageType[\"ACTION\"] = \"action\";\n    // Inbound\n    RTVIMessageType[\"BOT_READY\"] = \"bot-ready\";\n    RTVIMessageType[\"ERROR\"] = \"error\";\n    RTVIMessageType[\"ERROR_RESPONSE\"] = \"error-response\";\n    RTVIMessageType[\"CONFIG\"] = \"config\";\n    RTVIMessageType[\"CONFIG_AVAILABLE\"] = \"config-available\";\n    RTVIMessageType[\"CONFIG_ERROR\"] = \"config-error\";\n    RTVIMessageType[\"ACTIONS_AVAILABLE\"] = \"actions-available\";\n    RTVIMessageType[\"ACTION_RESPONSE\"] = \"action-response\";\n    RTVIMessageType[\"METRICS\"] = \"metrics\";\n    RTVIMessageType[\"USER_TRANSCRIPTION\"] = \"user-transcription\";\n    RTVIMessageType[\"BOT_TRANSCRIPTION\"] = \"bot-transcription\";\n    RTVIMessageType[\"USER_STARTED_SPEAKING\"] = \"user-started-speaking\";\n    RTVIMessageType[\"USER_STOPPED_SPEAKING\"] = \"user-stopped-speaking\";\n    RTVIMessageType[\"BOT_STARTED_SPEAKING\"] = \"bot-started-speaking\";\n    RTVIMessageType[\"BOT_STOPPED_SPEAKING\"] = \"bot-stopped-speaking\";\n    // Service-specific\n    RTVIMessageType[\"USER_LLM_TEXT\"] = \"user-llm-text\";\n    RTVIMessageType[\"BOT_LLM_TEXT\"] = \"bot-llm-text\";\n    RTVIMessageType[\"BOT_LLM_STARTED\"] = \"bot-llm-started\";\n    RTVIMessageType[\"BOT_LLM_STOPPED\"] = \"bot-llm-stopped\";\n    RTVIMessageType[\"BOT_TTS_TEXT\"] = \"bot-tts-text\";\n    RTVIMessageType[\"BOT_TTS_STARTED\"] = \"bot-tts-started\";\n    RTVIMessageType[\"BOT_TTS_STOPPED\"] = \"bot-tts-stopped\";\n    RTVIMessageType[\"BOT_LLM_SEARCH_RESPONSE\"] = \"bot-llm-search-response\";\n    // Storage\n    RTVIMessageType[\"STORAGE_ITEM_STORED\"] = \"storage-item-stored\";\n    // Server-to-client messages\n    RTVIMessageType[\"SERVER_MESSAGE\"] = \"server-message\";\n})($b48f893ed1354c1e$export$38b3db05cbf0e240 || ($b48f893ed1354c1e$export$38b3db05cbf0e240 = {}));\nclass $b48f893ed1354c1e$export$69aa9ab0334b212 {\n    constructor(type, data, id){\n        this.label = $b48f893ed1354c1e$export$882b13c7fda338f5;\n        this.type = type;\n        this.data = data;\n        this.id = id || (0, uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])().slice(0, 8);\n    }\n    // Outbound message types\n    static clientReady() {\n        return new $b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.CLIENT_READY, {});\n    }\n    static updateConfig(config, interrupt = false) {\n        return new $b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.UPDATE_CONFIG, {\n            config: config,\n            interrupt: interrupt\n        });\n    }\n    static describeConfig() {\n        return new $b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.DESCRIBE_CONFIG, {});\n    }\n    static getBotConfig() {\n        return new $b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.GET_CONFIG, {});\n    }\n    static describeActions() {\n        return new $b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.DESCRIBE_ACTIONS, {});\n    }\n    static disconnectBot() {\n        return new $b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.DISCONNECT_BOT, {});\n    }\n    static error(message, fatal = false) {\n        return new $b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.ERROR, {\n            message: message,\n            fatal: fatal\n        });\n    }\n}\nclass $b48f893ed1354c1e$export$378529d7a8bead8b extends $b48f893ed1354c1e$export$69aa9ab0334b212 {\n    constructor(data){\n        super($b48f893ed1354c1e$export$38b3db05cbf0e240.ACTION, data);\n    }\n}\nclass $b48f893ed1354c1e$export$e9a960646cc432aa {\n    constructor(client){\n        this._queue = new Array();\n        this._gcTime = 10000; // How long to wait before resolving the message\n        this._queue = [];\n        this._client = client;\n    }\n    dispatch(message) {\n        const promise = new Promise((resolve, reject)=>{\n            this._queue.push({\n                message: message,\n                timestamp: Date.now(),\n                resolve: resolve,\n                reject: reject\n            });\n        });\n        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(\"[MessageDispatcher] dispatch\", message);\n        this._client.sendMessage(message);\n        this._gc();\n        return promise;\n    }\n    async dispatchAction(action, onMessage) {\n        const promise = new Promise((resolve, reject)=>{\n            this._queue.push({\n                message: action,\n                timestamp: Date.now(),\n                resolve: resolve,\n                reject: reject\n            });\n        });\n        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(\"[MessageDispatcher] action\", action);\n        if (this._client.connected) // Send message to transport when connected\n        this._client.sendMessage(action);\n        else {\n            if (!this._client.params.endpoints?.action) {\n                (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error(\"[MessageDispatcher] Action endpoint is required when dispatching action in disconnected state\");\n                throw new (0, $8ead7b33b8402751$export$be839f0100cd3132)();\n            }\n            const actionUrl = this._client.constructUrl(\"action\");\n            try {\n                // Dispatch action via HTTP when disconnected\n                await (0, $4bb349f22aee5185$export$8728b60ea57bf43e)(actionUrl, action, this._client.params, (response)=>{\n                    onMessage(response);\n                });\n            // On HTTP success (resolve), send `action` message (for callbacks)\n            } catch (e) {\n                onMessage(new $b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.ERROR_RESPONSE, `Action endpoint '${actionUrl}' returned an error response`, action.id));\n            }\n        }\n        this._gc();\n        return promise;\n    }\n    _resolveReject(message, resolve = true) {\n        const queuedMessage = this._queue.find((msg)=>msg.message.id === message.id);\n        if (queuedMessage) {\n            if (resolve) {\n                (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(\"[MessageDispatcher] Resolve\", message);\n                queuedMessage.resolve(message.type === $b48f893ed1354c1e$export$38b3db05cbf0e240.ACTION_RESPONSE ? message : message);\n            } else {\n                (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(\"[MessageDispatcher] Reject\", message);\n                queuedMessage.reject(message);\n            }\n            // Remove message from queue\n            this._queue = this._queue.filter((msg)=>msg.message.id !== message.id);\n            (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(\"[MessageDispatcher] Queue\", this._queue);\n        }\n        return message;\n    }\n    resolve(message) {\n        return this._resolveReject(message, true);\n    }\n    reject(message) {\n        return this._resolveReject(message, false);\n    }\n    _gc() {\n        this._queue = this._queue.filter((msg)=>{\n            return Date.now() - msg.timestamp < this._gcTime;\n        });\n        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(\"[MessageDispatcher] GC\", this._queue);\n    }\n}\n\n\nvar $4086f06442fcb7d7$exports = {};\n\n$parcel$export($4086f06442fcb7d7$exports, \"Transport\", () => $4086f06442fcb7d7$export$86495b081fef8e52);\n$parcel$export($4086f06442fcb7d7$exports, \"TransportWrapper\", () => $4086f06442fcb7d7$export$82b6ede160a64a3c);\n/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */ class $4086f06442fcb7d7$export$86495b081fef8e52 {\n    constructor(){\n        this._state = \"disconnected\";\n        this._expiry = undefined;\n    }\n    get expiry() {\n        return this._expiry;\n    }\n}\nclass $4086f06442fcb7d7$export$82b6ede160a64a3c {\n    constructor(transport){\n        this._transport = transport;\n        this._proxy = new Proxy(this._transport, {\n            get: (target, prop, receiver)=>{\n                if (typeof target[prop] === \"function\") {\n                    let errMsg;\n                    switch(String(prop)){\n                        // Disable methods that modify the lifecycle of the call. These operations\n                        // should be performed via the RTVI client in order to keep state in sync.\n                        case \"initialize\":\n                            errMsg = `Direct calls to initialize() are disabled and used internally by the RTVIClient.`;\n                            break;\n                        case \"initDevices\":\n                            errMsg = `Direct calls to initDevices() are disabled. Please use the RTVIClient.initDevices() wrapper or let RTVIClient.connect() call it for you.`;\n                            break;\n                        case \"sendReadyMessage\":\n                            errMsg = `Direct calls to sendReadyMessage() are disabled and used internally by the RTVIClient.`;\n                            break;\n                        case \"connect\":\n                            errMsg = `Direct calls to connect() are disabled. Please use the RTVIClient.connect() wrapper.`;\n                            break;\n                        case \"disconnect\":\n                            errMsg = `Direct calls to disconnect() are disabled. Please use the RTVIClient.disconnect() wrapper.`;\n                            break;\n                    }\n                    if (errMsg) return ()=>{\n                        throw new Error(errMsg);\n                    };\n                    // Forward other method calls\n                    return (...args)=>{\n                        return target[prop](...args);\n                    };\n                }\n                // Forward property access\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n    get proxy() {\n        return this._proxy;\n    }\n}\n\n\nvar $a7c324a73303ad55$var$__decorate =  false || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst $a7c324a73303ad55$var$defaultEndpoints = {\n    connect: \"/connect\",\n    action: \"/action\"\n};\nclass $a7c324a73303ad55$var$RTVIEventEmitter extends (0, (events__WEBPACK_IMPORTED_MODULE_1___default())) {\n}\nclass $a7c324a73303ad55$export$fa42a01c1d60f4a1 extends $a7c324a73303ad55$var$RTVIEventEmitter {\n    constructor(options){\n        super();\n        this.params = {\n            ...options.params,\n            endpoints: {\n                ...$a7c324a73303ad55$var$defaultEndpoints,\n                ...options.params.endpoints ?? {}\n            }\n        };\n        this._helpers = {};\n        this._transport = options.transport;\n        this._transportWrapper = new (0, $4086f06442fcb7d7$export$82b6ede160a64a3c)(this._transport);\n        // Wrap transport callbacks with event triggers\n        // This allows for either functional callbacks or .on / .off event listeners\n        const wrappedCallbacks = {\n            ...options.callbacks,\n            onMessageError: (message)=>{\n                options?.callbacks?.onMessageError?.(message);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).MessageError, message);\n            },\n            onError: (message)=>{\n                options?.callbacks?.onError?.(message);\n                try {\n                    this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).Error, message);\n                } catch (e) {\n                    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(\"Could not emit error\", message);\n                }\n                const data = message.data;\n                if (data?.fatal) {\n                    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error(\"Fatal error reported. Disconnecting...\");\n                    this.disconnect();\n                }\n            },\n            onConnected: ()=>{\n                options?.callbacks?.onConnected?.();\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).Connected);\n            },\n            onDisconnected: ()=>{\n                options?.callbacks?.onDisconnected?.();\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).Disconnected);\n            },\n            onTransportStateChanged: (state)=>{\n                options?.callbacks?.onTransportStateChanged?.(state);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).TransportStateChanged, state);\n            },\n            onConfig: (config)=>{\n                options?.callbacks?.onConfig?.(config);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).Config, config);\n            },\n            onConfigDescribe: (configDescription)=>{\n                options?.callbacks?.onConfigDescribe?.(configDescription);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ConfigDescribe, configDescription);\n            },\n            onActionsAvailable: (actionsAvailable)=>{\n                options?.callbacks?.onActionsAvailable?.(actionsAvailable);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ActionsAvailable, actionsAvailable);\n            },\n            onParticipantJoined: (p)=>{\n                options?.callbacks?.onParticipantJoined?.(p);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ParticipantConnected, p);\n            },\n            onParticipantLeft: (p)=>{\n                options?.callbacks?.onParticipantLeft?.(p);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ParticipantLeft, p);\n            },\n            onTrackStarted: (track, p)=>{\n                options?.callbacks?.onTrackStarted?.(track, p);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).TrackStarted, track, p);\n            },\n            onTrackStopped: (track, p)=>{\n                options?.callbacks?.onTrackStopped?.(track, p);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).TrackStopped, track, p);\n            },\n            onScreenTrackStarted: (track, p)=>{\n                options?.callbacks?.onScreenTrackStarted?.(track, p);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ScreenTrackStarted, track, p);\n            },\n            onScreenTrackStopped: (track, p)=>{\n                options?.callbacks?.onScreenTrackStopped?.(track, p);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ScreenTrackStopped, track, p);\n            },\n            onScreenShareError: (errorMessage)=>{\n                options?.callbacks?.onScreenShareError?.(errorMessage);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ScreenShareError, errorMessage);\n            },\n            onAvailableCamsUpdated: (cams)=>{\n                options?.callbacks?.onAvailableCamsUpdated?.(cams);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).AvailableCamsUpdated, cams);\n            },\n            onAvailableMicsUpdated: (mics)=>{\n                options?.callbacks?.onAvailableMicsUpdated?.(mics);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).AvailableMicsUpdated, mics);\n            },\n            onAvailableSpeakersUpdated: (speakers)=>{\n                options?.callbacks?.onAvailableSpeakersUpdated?.(speakers);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).AvailableSpeakersUpdated, speakers);\n            },\n            onCamUpdated: (cam)=>{\n                options?.callbacks?.onCamUpdated?.(cam);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).CamUpdated, cam);\n            },\n            onMicUpdated: (mic)=>{\n                options?.callbacks?.onMicUpdated?.(mic);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).MicUpdated, mic);\n            },\n            onSpeakerUpdated: (speaker)=>{\n                options?.callbacks?.onSpeakerUpdated?.(speaker);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).SpeakerUpdated, speaker);\n            },\n            onBotConnected: (p)=>{\n                options?.callbacks?.onBotConnected?.(p);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotConnected, p);\n            },\n            onBotReady: (botReadyData)=>{\n                options?.callbacks?.onBotReady?.(botReadyData);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotReady, botReadyData);\n            },\n            onBotDisconnected: (p)=>{\n                options?.callbacks?.onBotDisconnected?.(p);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotDisconnected, p);\n            },\n            onBotStartedSpeaking: ()=>{\n                options?.callbacks?.onBotStartedSpeaking?.();\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotStartedSpeaking);\n            },\n            onBotStoppedSpeaking: ()=>{\n                options?.callbacks?.onBotStoppedSpeaking?.();\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotStoppedSpeaking);\n            },\n            onRemoteAudioLevel: (level, p)=>{\n                options?.callbacks?.onRemoteAudioLevel?.(level, p);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).RemoteAudioLevel, level, p);\n            },\n            onUserStartedSpeaking: ()=>{\n                options?.callbacks?.onUserStartedSpeaking?.();\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).UserStartedSpeaking);\n            },\n            onUserStoppedSpeaking: ()=>{\n                options?.callbacks?.onUserStoppedSpeaking?.();\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).UserStoppedSpeaking);\n            },\n            onLocalAudioLevel: (level)=>{\n                options?.callbacks?.onLocalAudioLevel?.(level);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).LocalAudioLevel, level);\n            },\n            onUserTranscript: (data)=>{\n                options?.callbacks?.onUserTranscript?.(data);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).UserTranscript, data);\n            },\n            onBotTranscript: (text)=>{\n                options?.callbacks?.onBotTranscript?.(text);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotTranscript, text);\n            },\n            onBotLlmText: (text)=>{\n                options?.callbacks?.onBotLlmText?.(text);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotLlmText, text);\n            },\n            onBotLlmStarted: ()=>{\n                options?.callbacks?.onBotLlmStarted?.();\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotLlmStarted);\n            },\n            onBotLlmStopped: ()=>{\n                options?.callbacks?.onBotLlmStopped?.();\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotLlmStopped);\n            },\n            onBotTtsText: (text)=>{\n                options?.callbacks?.onBotTtsText?.(text);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotTtsText, text);\n            },\n            onBotTtsStarted: ()=>{\n                options?.callbacks?.onBotTtsStarted?.();\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotTtsStarted);\n            },\n            onBotTtsStopped: ()=>{\n                options?.callbacks?.onBotTtsStopped?.();\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotTtsStopped);\n            },\n            onStorageItemStored: (data)=>{\n                options?.callbacks?.onStorageItemStored?.(data);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).StorageItemStored, data);\n            }\n        };\n        // Update options to reference wrapped callbacks and config defaults\n        this._options = {\n            ...options,\n            callbacks: wrappedCallbacks,\n            enableMic: options.enableMic ?? true,\n            enableCam: options.enableCam ?? false\n        };\n        // Instantiate the transport class and bind message handler\n        this._initialize();\n        // Get package version number\n        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(\"[RTVI Client] Initialized\", this.version);\n    }\n    constructUrl(endpoint) {\n        if (!this.params.baseUrl) throw new $8ead7b33b8402751$export$59b4786f333aac02(\"Base URL not set. Please set rtviClient.params.baseUrl\");\n        const baseUrl = this.params.baseUrl.replace(/\\/+$/, \"\");\n        return baseUrl + (this.params.endpoints?.[endpoint] ?? \"\");\n    }\n    setLogLevel(level) {\n        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).setLevel(level);\n    }\n    // ------ Transport methods\n    /**\n     * Initialize local media devices\n     */ async initDevices() {\n        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(\"[RTVI Client] Initializing devices...\");\n        await this._transport.initDevices();\n    }\n    /**\n     * Connect the voice client session with chosen transport\n     * Call async (await) to handle errors\n     */ async connect() {\n        if ([\n            \"authenticating\",\n            \"connecting\",\n            \"connected\",\n            \"ready\"\n        ].includes(this._transport.state)) throw new $8ead7b33b8402751$export$59b4786f333aac02(\"Voice client has already been started. Please call disconnect() before starting again.\");\n        this._abortController = new AbortController();\n        // Establish transport session and await bot ready signal\n        return new Promise((resolve, reject)=>{\n            (async ()=>{\n                this._startResolve = resolve;\n                if (this._transport.state === \"disconnected\") await this._transport.initDevices();\n                this._transport.state = \"authenticating\";\n                // Set a timer for the bot to enter a ready state, otherwise abort the attempt\n                if (this._options.timeout) this._handshakeTimeout = setTimeout(async ()=>{\n                    this._abortController?.abort();\n                    await this.disconnect();\n                    this._transport.state = \"error\";\n                    reject(new $8ead7b33b8402751$export$c67992fa684a81a6());\n                }, this._options.timeout);\n                let authBundle;\n                const customConnectHandler = this._options.customConnectHandler;\n                (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(\"[RTVI Client] Start params\", this.params);\n                this.params = {\n                    ...this.params,\n                    requestData: {\n                        ...this.params.requestData,\n                        rtvi_client_version: this.version\n                    }\n                };\n                if (!this.params.baseUrl && !this.params.endpoints?.connect) {\n                    // If baseUrl and endpoints.connect are not set, bypass the handshake and connect directly\n                    // This is useful with transports that do not require service side auth, especially in local development\n                    // Note: this is not recommended for production use, see [docs link]\n                    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(\"[RTVI Client] Connecting directly (skipping handshake / auth)...\");\n                    clearTimeout(this._handshakeTimeout);\n                } else {\n                    const connectUrl = this.constructUrl(\"connect\");\n                    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(\"[RTVI Client] Connecting...\", connectUrl);\n                    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(\"[RTVI Client] Start params\", this.params);\n                    try {\n                        if (customConnectHandler) authBundle = await customConnectHandler(this.params, this._handshakeTimeout, this._abortController);\n                        else authBundle = await fetch(connectUrl, {\n                            method: \"POST\",\n                            mode: \"cors\",\n                            headers: new Headers({\n                                \"Content-Type\": \"application/json\",\n                                ...Object.fromEntries((this.params.headers ?? new Headers()).entries())\n                            }),\n                            body: JSON.stringify({\n                                config: this.params.config,\n                                ...this.params.services ? {\n                                    services: this.params.services\n                                } : {},\n                                ...this.params.requestData\n                            }),\n                            signal: this._abortController?.signal\n                        }).then((res)=>{\n                            clearTimeout(this._handshakeTimeout);\n                            if (res.ok) return res.json();\n                            return Promise.reject(res);\n                        });\n                    } catch (e) {\n                        clearTimeout(this._handshakeTimeout);\n                        // Handle errors if the request was not aborted\n                        if (this._abortController?.signal.aborted) return;\n                        this._transport.state = \"error\";\n                        if (e instanceof Response) {\n                            const errorResp = await e.json();\n                            reject(new $8ead7b33b8402751$export$e7544ab812238a61(errorResp.info ?? errorResp.detail ?? e.statusText, e.status));\n                        } else reject(new $8ead7b33b8402751$export$e7544ab812238a61());\n                        return;\n                    }\n                    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(\"[RTVI Client] Auth bundle received\", authBundle);\n                }\n                try {\n                    await this._transport.connect(authBundle, this._abortController);\n                    await this._transport.sendReadyMessage();\n                } catch (e) {\n                    clearTimeout(this._handshakeTimeout);\n                    this.disconnect();\n                    reject(e);\n                    return;\n                }\n            })();\n        });\n    }\n    /**\n     * Disconnect the voice client from the transport\n     * Reset / reinitialize transport and abort any pending requests\n     */ async disconnect() {\n        if (this._abortController) this._abortController.abort();\n        clearTimeout(this._handshakeTimeout);\n        await this._transport.disconnect();\n        this._messageDispatcher = new (0, $b48f893ed1354c1e$export$e9a960646cc432aa)(this);\n    }\n    _initialize() {\n        this._transport.initialize(this._options, this.handleMessage.bind(this));\n        // Create a new message dispatch queue for async message handling\n        this._messageDispatcher = new (0, $b48f893ed1354c1e$export$e9a960646cc432aa)(this);\n    }\n    /**\n     * Get the current state of the transport\n     */ get connected() {\n        return [\n            \"connected\",\n            \"ready\"\n        ].includes(this._transport.state);\n    }\n    get transport() {\n        return this._transportWrapper.proxy;\n    }\n    get state() {\n        return this._transport.state;\n    }\n    get version() {\n        return (0, (/*@__PURE__*/$parcel$interopDefault($e3bad9cc25e327f7$exports))).version;\n    }\n    // ------ Device methods\n    async getAllMics() {\n        return await this._transport.getAllMics();\n    }\n    async getAllCams() {\n        return await this._transport.getAllCams();\n    }\n    async getAllSpeakers() {\n        return await this._transport.getAllSpeakers();\n    }\n    get selectedMic() {\n        return this._transport.selectedMic;\n    }\n    get selectedCam() {\n        return this._transport.selectedCam;\n    }\n    get selectedSpeaker() {\n        return this._transport.selectedSpeaker;\n    }\n    updateMic(micId) {\n        this._transport.updateMic(micId);\n    }\n    updateCam(camId) {\n        this._transport.updateCam(camId);\n    }\n    updateSpeaker(speakerId) {\n        this._transport.updateSpeaker(speakerId);\n    }\n    enableMic(enable) {\n        this._transport.enableMic(enable);\n    }\n    get isMicEnabled() {\n        return this._transport.isMicEnabled;\n    }\n    enableCam(enable) {\n        this._transport.enableCam(enable);\n    }\n    get isCamEnabled() {\n        return this._transport.isCamEnabled;\n    }\n    tracks() {\n        return this._transport.tracks();\n    }\n    enableScreenShare(enable) {\n        return this._transport.enableScreenShare(enable);\n    }\n    get isSharingScreen() {\n        return this._transport.isSharingScreen;\n    }\n    // ------ Config methods\n    /**\n     * Request the bot to send the current configuration\n     * @returns Promise<RTVIClientConfigOption[]> - Promise that resolves with the bot's configuration\n     */ async getConfig() {\n        const configMsg = await this._messageDispatcher.dispatch((0, $b48f893ed1354c1e$export$69aa9ab0334b212).getBotConfig());\n        return configMsg.data.config;\n    }\n    /**\n     * Update pipeline and services\n     * @param config - RTVIClientConfigOption[] partial object with the new configuration\n     * @param interrupt - boolean flag to interrupt the current pipeline, or wait until the next turn\n     * @returns Promise<RTVIMessage> - Promise that resolves with the updated configuration\n     */ async updateConfig(config, interrupt = false) {\n        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(\"[RTVI Client] Updating config\", config);\n        // Only send the partial config if the bot is ready to prevent\n        // potential racing conditions whilst pipeline is instantiating\n        return this._messageDispatcher.dispatch((0, $b48f893ed1354c1e$export$69aa9ab0334b212).updateConfig(config, interrupt));\n    }\n    /**\n     * Request bot describe the current configuration options\n     * @returns Promise<unknown> - Promise that resolves with the bot's configuration description\n     */ async describeConfig() {\n        return this._messageDispatcher.dispatch((0, $b48f893ed1354c1e$export$69aa9ab0334b212).describeConfig());\n    }\n    /**\n     * Returns configuration options for specified service key\n     * @param serviceKey - Service name to get options for (e.g. \"llm\")\n     * @param config? - Optional RTVIClientConfigOption[] to query (vs. using remote config)\n     * @returns RTVIClientConfigOption | undefined - Configuration options array for the service with specified key or undefined\n     */ async getServiceOptionsFromConfig(serviceKey, config) {\n        if (!config && this.state !== \"ready\") throw new $8ead7b33b8402751$export$885fb96b850e8fbb(\"getServiceOptionsFromConfig called without config array before bot is ready\");\n        return Promise.resolve().then(async ()=>{\n            // Check if we have registered service with name service\n            if (!serviceKey) {\n                (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(\"Target service name is required\");\n                return undefined;\n            }\n            const passedConfig = config ?? await this.getConfig();\n            // Find matching service name in the config and update the messages\n            const configServiceKey = passedConfig.find((config)=>config.service === serviceKey);\n            if (!configServiceKey) {\n                (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(\"No service with name \" + serviceKey + \" not found in config\");\n                return undefined;\n            }\n            // Return a new object, as to not mutate existing state\n            return configServiceKey;\n        });\n    }\n    /**\n     * Returns configuration option value (unknown) for specified service key and option name\n     * @param serviceKey - Service name to get options for (e.g. \"llm\")\n     * @optional option Name of option return from the config (e.g. \"model\")\n     * @returns Promise<unknown | undefined> - Service configuration option value or undefined\n     */ async getServiceOptionValueFromConfig(serviceKey, option, config) {\n        const configServiceKey = await this.getServiceOptionsFromConfig(serviceKey, config);\n        if (!configServiceKey) {\n            (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(\"Service with name \" + serviceKey + \" not found in config\");\n            return undefined;\n        }\n        // Find matching option key in the service config\n        const optionValue = configServiceKey.options.find((o)=>o.name === option);\n        return optionValue ? optionValue.value : undefined;\n    }\n    _updateOrAddOption(existingOptions, newOption) {\n        const existingOptionIndex = existingOptions.findIndex((item)=>item.name === newOption.name);\n        if (existingOptionIndex !== -1) // Update existing option\n        return existingOptions.map((item, index)=>index === existingOptionIndex ? {\n                ...item,\n                value: newOption.value\n            } : item);\n        else // Add new option\n        return [\n            ...existingOptions,\n            {\n                name: newOption.name,\n                value: newOption.value\n            }\n        ];\n    }\n    /**\n     * Returns config with updated option(s) for specified service key and option name\n     * Note: does not update current config, only returns a new object (call updateConfig to apply changes)\n     * @param serviceKey - Service name to get options for (e.g. \"llm\")\n     * @param option - Service name to get options for (e.g. \"model\")\n     * @param config - Optional RTVIClientConfigOption[] to update (vs. using current config)\n     * @returns Promise<RTVIClientConfigOption[] | undefined> - Configuration options array with updated option(s) or undefined\n     */ async setServiceOptionInConfig(serviceKey, option, config) {\n        const newConfig = (0, (clone_deep__WEBPACK_IMPORTED_MODULE_0___default()))(config ?? await this.getConfig());\n        const serviceOptions = await this.getServiceOptionsFromConfig(serviceKey, newConfig);\n        if (!serviceOptions) {\n            (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(\"Service with name '\" + serviceKey + \"' not found in config\");\n            return newConfig;\n        }\n        const optionsArray = Array.isArray(option) ? option : [\n            option\n        ];\n        for (const opt of optionsArray){\n            const existingItem = newConfig.find((item)=>item.service === serviceKey);\n            const updatedOptions = existingItem ? this._updateOrAddOption(existingItem.options, opt) : [\n                {\n                    name: opt.name,\n                    value: opt.value\n                }\n            ];\n            if (existingItem) existingItem.options = updatedOptions;\n            else newConfig.push({\n                service: serviceKey,\n                options: updatedOptions\n            });\n        }\n        return newConfig;\n    }\n    /**\n     * Returns config object with updated properties from passed array.\n     * @param configOptions - Array of RTVIClientConfigOption[] to update\n     * @param config? - Optional RTVIClientConfigOption[] to update (vs. using current config)\n     * @returns Promise<RTVIClientConfigOption[]> - Configuration options\n     */ async setConfigOptions(configOptions, config) {\n        let accumulator = (0, (clone_deep__WEBPACK_IMPORTED_MODULE_0___default()))(config ?? await this.getConfig());\n        for (const configOption of configOptions)accumulator = await this.setServiceOptionInConfig(configOption.service, configOption.options, accumulator) || accumulator;\n        return accumulator;\n    }\n    // ------ Actions\n    /**\n     * Dispatch an action message to the bot or http single-turn endpoint\n     */ async action(action) {\n        return this._messageDispatcher.dispatchAction(new (0, $b48f893ed1354c1e$export$378529d7a8bead8b)(action), this.handleMessage.bind(this));\n    }\n    /**\n     * Describe available / registered actions the bot has\n     * @returns Promise<unknown> - Promise that resolves with the bot's actions\n     */ async describeActions() {\n        return this._messageDispatcher.dispatch((0, $b48f893ed1354c1e$export$69aa9ab0334b212).describeActions());\n    }\n    // ------ Transport methods\n    /**\n     * Get the session expiry time for the transport session (if applicable)\n     * @returns number - Expiry time in milliseconds\n     */ get transportExpiry() {\n        return this._transport.expiry;\n    }\n    // ------ Messages\n    /**\n     * Directly send a message to the bot via the transport\n     * @param message - RTVIMessage object to send\n     */ sendMessage(message) {\n        this._transport.sendMessage(message);\n    }\n    /**\n     * Disconnects the bot, but keeps the session alive\n     */ disconnectBot() {\n        this._transport.sendMessage(new (0, $b48f893ed1354c1e$export$69aa9ab0334b212)((0, $b48f893ed1354c1e$export$38b3db05cbf0e240).DISCONNECT_BOT, {}));\n    }\n    handleMessage(ev) {\n        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(\"[RTVI Message]\", ev);\n        switch(ev.type){\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_READY:\n                clearTimeout(this._handshakeTimeout);\n                this._startResolve?.(ev.data);\n                this._options.callbacks?.onBotReady?.(ev.data);\n                break;\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).CONFIG_AVAILABLE:\n                this._messageDispatcher.resolve(ev);\n                this._options.callbacks?.onConfigDescribe?.(ev.data);\n                break;\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).CONFIG:\n                {\n                    const resp = this._messageDispatcher.resolve(ev);\n                    this._options.callbacks?.onConfig?.(resp.data.config);\n                    break;\n                }\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).ACTIONS_AVAILABLE:\n                this._messageDispatcher.resolve(ev);\n                this._options.callbacks?.onActionsAvailable?.(ev.data);\n                break;\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).ACTION_RESPONSE:\n                this._messageDispatcher.resolve(ev);\n                break;\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).ERROR_RESPONSE:\n                {\n                    const resp = this._messageDispatcher.reject(ev);\n                    this._options.callbacks?.onMessageError?.(resp);\n                    break;\n                }\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).ERROR:\n                this._options.callbacks?.onError?.(ev);\n                break;\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).USER_STARTED_SPEAKING:\n                this._options.callbacks?.onUserStartedSpeaking?.();\n                break;\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).USER_STOPPED_SPEAKING:\n                this._options.callbacks?.onUserStoppedSpeaking?.();\n                break;\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_STARTED_SPEAKING:\n                this._options.callbacks?.onBotStartedSpeaking?.();\n                break;\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_STOPPED_SPEAKING:\n                this._options.callbacks?.onBotStoppedSpeaking?.();\n                break;\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).USER_TRANSCRIPTION:\n                {\n                    const TranscriptData = ev.data;\n                    this._options.callbacks?.onUserTranscript?.(TranscriptData);\n                    break;\n                }\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_TRANSCRIPTION:\n                this._options.callbacks?.onBotTranscript?.(ev.data);\n                break;\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_LLM_TEXT:\n                this._options.callbacks?.onBotLlmText?.(ev.data);\n                break;\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_LLM_STARTED:\n                this._options.callbacks?.onBotLlmStarted?.();\n                break;\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_LLM_STOPPED:\n                this._options.callbacks?.onBotLlmStopped?.();\n                break;\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_TTS_TEXT:\n                this._options.callbacks?.onBotTtsText?.(ev.data);\n                break;\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_TTS_STARTED:\n                this._options.callbacks?.onBotTtsStarted?.();\n                break;\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_TTS_STOPPED:\n                this._options.callbacks?.onBotTtsStopped?.();\n                break;\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_LLM_SEARCH_RESPONSE:\n                this._options.callbacks?.onBotLlmSearchResponse?.(ev.data);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotLlmSearchResponse, ev.data);\n                break;\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).METRICS:\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).Metrics, ev.data);\n                this._options.callbacks?.onMetrics?.(ev.data);\n                break;\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).STORAGE_ITEM_STORED:\n                this._options.callbacks?.onStorageItemStored?.(ev.data);\n                break;\n            case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).SERVER_MESSAGE:\n                this._options.callbacks?.onServerMessage?.(ev.data);\n                this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ServerMessage, ev.data);\n                break;\n            default:\n                {\n                    let match = false;\n                    // Pass message to registered helpers\n                    for (const helper of Object.values(this._helpers))if (helper.getMessageTypes().includes(ev.type)) {\n                        match = true;\n                        helper.handleMessage(ev);\n                    }\n                    if (!match) this._options.callbacks?.onGenericMessage?.(ev.data);\n                }\n        }\n    }\n    // ------ Helpers\n    /**\n     * Register a new helper to the client\n     * This (optionally) provides a way to reference helpers directly\n     * from the client and use the event dispatcher\n     * @param service - Target service for this helper\n     * @param helper - Helper instance\n     * @returns RTVIClientHelper - Registered helper instance\n     */ registerHelper(service, helper) {\n        if (this._helpers[service]) throw new Error(`Helper with name '${service}' already registered`);\n        // Check helper is instance of RTVIClientHelper\n        if (!(helper instanceof (0, $7614fb2168c523cc$export$23bc637255b2a471))) throw new Error(`Helper must be an instance of RTVIClientHelper`);\n        helper.service = service;\n        helper.client = this;\n        this._helpers[service] = helper;\n        return this._helpers[service];\n    }\n    getHelper(service) {\n        const helper = this._helpers[service];\n        if (!helper) {\n            (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(`Helper targeting service '${service}' not found`);\n            return undefined;\n        }\n        return helper;\n    }\n    unregisterHelper(service) {\n        if (!this._helpers[service]) return;\n        delete this._helpers[service];\n    }\n}\n$a7c324a73303ad55$var$__decorate([\n    (0, $16f019d4d16917df$export$f1586721024c4dab)\n], $a7c324a73303ad55$export$fa42a01c1d60f4a1.prototype, \"getConfig\", null);\n$a7c324a73303ad55$var$__decorate([\n    (0, $16f019d4d16917df$export$f1586721024c4dab)\n], $a7c324a73303ad55$export$fa42a01c1d60f4a1.prototype, \"updateConfig\", null);\n$a7c324a73303ad55$var$__decorate([\n    (0, $16f019d4d16917df$export$f1586721024c4dab)\n], $a7c324a73303ad55$export$fa42a01c1d60f4a1.prototype, \"describeConfig\", null);\n$a7c324a73303ad55$var$__decorate([\n    (0, $16f019d4d16917df$export$f1586721024c4dab)\n], $a7c324a73303ad55$export$fa42a01c1d60f4a1.prototype, \"describeActions\", null);\n$a7c324a73303ad55$var$__decorate([\n    (0, $16f019d4d16917df$export$5c35b4fe6fa8c9a6)(\"connected\", \"ready\")\n], $a7c324a73303ad55$export$fa42a01c1d60f4a1.prototype, \"transportExpiry\", null);\n$a7c324a73303ad55$var$__decorate([\n    (0, $16f019d4d16917df$export$f1586721024c4dab)\n], $a7c324a73303ad55$export$fa42a01c1d60f4a1.prototype, \"sendMessage\", null);\n$a7c324a73303ad55$var$__decorate([\n    (0, $16f019d4d16917df$export$f1586721024c4dab)\n], $a7c324a73303ad55$export$fa42a01c1d60f4a1.prototype, \"disconnectBot\", null);\n\n\n\n\n\nvar $0908f693e3e0724c$exports = {};\n\n$parcel$export($0908f693e3e0724c$exports, \"LLMMessageType\", () => $0908f693e3e0724c$export$441bcd2e10762760);\n$parcel$export($0908f693e3e0724c$exports, \"LLMActionType\", () => $0908f693e3e0724c$export$43cdfb26f790451);\n$parcel$export($0908f693e3e0724c$exports, \"LLMHelper\", () => $0908f693e3e0724c$export$3cf39a62d076dd5c);\n/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */ \n\n\n\nvar $0908f693e3e0724c$export$441bcd2e10762760;\n(function(LLMMessageType) {\n    LLMMessageType[\"LLM_FUNCTION_CALL\"] = \"llm-function-call\";\n    LLMMessageType[\"LLM_FUNCTION_CALL_START\"] = \"llm-function-call-start\";\n    LLMMessageType[\"LLM_FUNCTION_CALL_RESULT\"] = \"llm-function-call-result\";\n    LLMMessageType[\"LLM_JSON_COMPLETION\"] = \"llm-json-completion\";\n})($0908f693e3e0724c$export$441bcd2e10762760 || ($0908f693e3e0724c$export$441bcd2e10762760 = {}));\nvar $0908f693e3e0724c$export$43cdfb26f790451;\n(function(LLMActionType) {\n    LLMActionType[\"APPEND_TO_MESSAGES\"] = \"append_to_messages\";\n    LLMActionType[\"GET_CONTEXT\"] = \"get_context\";\n    LLMActionType[\"SET_CONTEXT\"] = \"set_context\";\n    LLMActionType[\"RUN\"] = \"run\";\n})($0908f693e3e0724c$export$43cdfb26f790451 || ($0908f693e3e0724c$export$43cdfb26f790451 = {}));\nclass $0908f693e3e0724c$export$3cf39a62d076dd5c extends (0, $7614fb2168c523cc$export$23bc637255b2a471) {\n    constructor(options){\n        super(options);\n        this._functionCallCallback = null;\n    }\n    getMessageTypes() {\n        return Object.values($0908f693e3e0724c$export$441bcd2e10762760);\n    }\n    // --- Actions\n    /**\n     * Retrieve the bot's current LLM context.\n     * @returns Promise<LLMContext>\n     */ async getContext() {\n        if (this._client.state !== \"ready\") throw new $8ead7b33b8402751$export$885fb96b850e8fbb(\"getContext called while transport not in ready state\");\n        const actionResponseMsg = await this._client.action({\n            service: this._service,\n            action: $0908f693e3e0724c$export$43cdfb26f790451.GET_CONTEXT\n        });\n        return actionResponseMsg.data.result;\n    }\n    /**\n     * Update the bot's LLM context.\n     * If this is called while the transport is not in the ready state, the local context will be updated\n     * @param context LLMContext - The new context\n     * @param interrupt boolean - Whether to interrupt the bot, or wait until it has finished speaking\n     * @returns Promise<boolean>\n     */ async setContext(context, interrupt = false) {\n        if (this._client.state !== \"ready\") throw new $8ead7b33b8402751$export$885fb96b850e8fbb(\"setContext called while transport not in ready state\");\n        const actionResponse = await this._client.action({\n            service: this._service,\n            action: $0908f693e3e0724c$export$43cdfb26f790451.SET_CONTEXT,\n            arguments: [\n                {\n                    name: \"messages\",\n                    value: context.messages\n                },\n                {\n                    name: \"interrupt\",\n                    value: interrupt\n                }\n            ]\n        });\n        return !!actionResponse.data.result;\n    }\n    /**\n     * Append a new message to the LLM context.\n     * If this is called while the transport is not in the ready state, the local context will be updated\n     * @param context LLMContextMessage\n     * @param runImmediately boolean - wait until pipeline is idle before running\n     * @returns boolean\n     */ async appendToMessages(message, runImmediately = false) {\n        if (this._client.state !== \"ready\") throw new $8ead7b33b8402751$export$885fb96b850e8fbb(\"setContext called while transport not in ready state\");\n        const actionResponse = await this._client.action({\n            service: this._service,\n            action: $0908f693e3e0724c$export$43cdfb26f790451.APPEND_TO_MESSAGES,\n            arguments: [\n                {\n                    name: \"messages\",\n                    value: [\n                        message\n                    ]\n                },\n                {\n                    name: \"run_immediately\",\n                    value: runImmediately\n                }\n            ]\n        });\n        return !!actionResponse.data.result;\n    }\n    /**\n     * Run the bot's current LLM context.\n     * Useful when appending messages to the context without runImmediately set to true.\n     * Will do nothing if the bot is not in the ready state.\n     * @param interrupt boolean - Whether to interrupt the bot, or wait until it has finished speaking\n     * @returns Promise<unknown>\n     */ async run(interrupt = false) {\n        if (this._client.state !== \"ready\") return;\n        return this._client.action({\n            service: this._service,\n            action: $0908f693e3e0724c$export$43cdfb26f790451.RUN,\n            arguments: [\n                {\n                    name: \"interrupt\",\n                    value: interrupt\n                }\n            ]\n        });\n    }\n    // --- Handlers\n    /**\n     * If the LLM wants to call a function, RTVI will invoke the callback defined\n     * here. Whatever the callback returns will be sent to the LLM as the function result.\n     * @param callback\n     * @returns void\n     */ handleFunctionCall(callback) {\n        this._functionCallCallback = callback;\n    }\n    handleMessage(ev) {\n        switch(ev.type){\n            case $0908f693e3e0724c$export$441bcd2e10762760.LLM_JSON_COMPLETION:\n                this._options.callbacks?.onLLMJsonCompletion?.(ev.data);\n                this._client.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).LLMJsonCompletion, ev.data);\n                break;\n            case $0908f693e3e0724c$export$441bcd2e10762760.LLM_FUNCTION_CALL:\n                {\n                    const d = ev.data;\n                    this._options.callbacks?.onLLMFunctionCall?.(ev.data);\n                    this._client.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).LLMFunctionCall, ev.data);\n                    if (this._functionCallCallback) {\n                        const fn = {\n                            functionName: d.function_name,\n                            arguments: d.args\n                        };\n                        if (this._client.state === \"ready\") this._functionCallCallback(fn).then((result)=>{\n                            this._client.sendMessage(new (0, $b48f893ed1354c1e$export$69aa9ab0334b212)($0908f693e3e0724c$export$441bcd2e10762760.LLM_FUNCTION_CALL_RESULT, {\n                                function_name: d.function_name,\n                                tool_call_id: d.tool_call_id,\n                                arguments: d.args,\n                                result: result\n                            }));\n                        });\n                        else throw new $8ead7b33b8402751$export$885fb96b850e8fbb(\"Attempted to send a function call result from bot while transport not in ready state\");\n                    }\n                    break;\n                }\n            case $0908f693e3e0724c$export$441bcd2e10762760.LLM_FUNCTION_CALL_START:\n                {\n                    const e = ev.data;\n                    this._options.callbacks?.onLLMFunctionCallStart?.(e.function_name);\n                    this._client.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).LLMFunctionCallStart, e.function_name);\n                    break;\n                }\n        }\n    }\n}\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBpcGVjYXQtYWkvY2xpZW50LWpzL2Rpc3QvaW5kZXgubW9kdWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEM7QUFDUDtBQUNFOzs7QUFHckM7QUFDQSwrQkFBK0IscURBQXFEO0FBQ3BGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csYUFBYTtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QywrTkFBK04sc0ZBQXNGLGtFQUFrRSwrS0FBK0ssV0FBVyxvREFBb0Qsc0JBQXNCLG1SQUFtUixtQkFBbUIsZ0lBQWdJOzs7QUFHMWtDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLHdCQUF3QjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLHdCQUF3Qix3QkFBd0IsT0FBTztBQUNwSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2Rix3QkFBd0Isd0JBQXdCLE9BQU87QUFDcEo7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEZBQThGOzs7QUFHL0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4RkFBOEY7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhGQUE4RjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRDQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHNIQUFzSDtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5SEFBeUg7QUFDekg7QUFDQTtBQUNBLG9IQUFvSDtBQUNwSDtBQUNBO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0E7QUFDQSx3SEFBd0g7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGNBQWM7QUFDZCxxSkFBcUosVUFBVTtBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHVDQUF1QyxNQUFpQztBQUN4RTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELCtDQUFhO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLElBQUk7QUFDdEM7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbURBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1EQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUpBQXVKO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsUUFBUTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixRQUFRO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEZBQThGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEZBQTRGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRcTRDO0FBQ3I0QyIsInNvdXJjZXMiOlsid2VicGFjazovL3ZvaWNlLWFzc2lzdGFudC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AcGlwZWNhdC1haS9jbGllbnQtanMvZGlzdC9pbmRleC5tb2R1bGUuanM/MzQwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJGVJTkRrJGNsb25lZGVlcCBmcm9tIFwiY2xvbmUtZGVlcFwiO1xuaW1wb3J0ICRlSU5EayRldmVudHMgZnJvbSBcImV2ZW50c1wiO1xuaW1wb3J0IHt2NCBhcyAkZUlORGskdjR9IGZyb20gXCJ1dWlkXCI7XG5cblxuZnVuY3Rpb24gJHBhcmNlbCRleHBvcnQoZSwgbiwgdiwgcykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgbiwge2dldDogdiwgc2V0OiBzLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9KTtcbn1cblxuZnVuY3Rpb24gJHBhcmNlbCRpbnRlcm9wRGVmYXVsdChhKSB7XG4gIHJldHVybiBhICYmIGEuX19lc01vZHVsZSA/IGEuZGVmYXVsdCA6IGE7XG59XG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCwgRGFpbHkuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0yLUNsYXVzZVxuICovIHZhciAkNGJiMzQ5ZjIyYWVlNTE4NSRleHBvcnRzID0ge307XG5cbiRwYXJjZWwkZXhwb3J0KCQ0YmIzNDlmMjJhZWU1MTg1JGV4cG9ydHMsIFwiaHR0cEFjdGlvbkdlbmVyYXRvclwiLCAoKSA9PiAkNGJiMzQ5ZjIyYWVlNTE4NSRleHBvcnQkODcyOGI2MGVhNTdiZjQzZSk7XG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCwgRGFpbHkuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0yLUNsYXVzZVxuICovIFxuYXN5bmMgZnVuY3Rpb24gJDRiYjM0OWYyMmFlZTUxODUkZXhwb3J0JDg3MjhiNjBlYTU3YmY0M2UoYWN0aW9uVXJsLCBhY3Rpb24sIHBhcmFtcywgaGFuZGxlUmVzcG9uc2UpIHtcbiAgICB0cnkge1xuICAgICAgICAoMCwgJDdhZmJiZDU5ZWJhYTQyYmYkZXhwb3J0JGFmODhkMDBkYmU3ZjUyMSkuZGVidWcoXCJbUlRWSV0gRmV0Y2ggYWN0aW9uXCIsIGFjdGlvblVybCwgYWN0aW9uKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHtcbiAgICAgICAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcygocGFyYW1zLmhlYWRlcnMgPz8gbmV3IEhlYWRlcnMoKSkuZW50cmllcygpKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFoZWFkZXJzLmhhcyhcIkNvbnRlbnQtVHlwZVwiKSkgaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgICBoZWFkZXJzLnNldChcIkNhY2hlLUNvbnRyb2xcIiwgXCJuby1jYWNoZVwiKTtcbiAgICAgICAgaGVhZGVycy5zZXQoXCJDb25uZWN0aW9uXCIsIFwia2VlcC1hbGl2ZVwiKTtcbiAgICAgICAgLy8gUGVyZm9ybSB0aGUgZmV0Y2ggcmVxdWVzdFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGFjdGlvblVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgLi4ucGFyYW1zLnJlcXVlc3REYXRhLFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENoZWNrIHRoZSByZXNwb25zZSBjb250ZW50IHR5cGVcbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgICAgICAgLy8gSGFuZGxlIG5vbi1vayByZXNwb25zZSBzdGF0dXNcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgdGhyb3cgbmV3ICgwLCAkOGVhZDdiMzNiODQwMjc1MSRleHBvcnQkNTliNDc4NmYzMzNhYWMwMikoYEZhaWxlZCB0byByZXNvbHZlIGFjdGlvbjogJHtlcnJvck1lc3NhZ2V9YCwgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2UuYm9keSAmJiBjb250ZW50VHlwZT8uaW5jbHVkZXMoXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiKSkge1xuICAgICAgICAgICAgLy8gUGFyc2Ugc3RyZWFtZWQgcmVzcG9uc2VzXG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgIGxldCBidWZmZXIgPSBcIlwiO1xuICAgICAgICAgICAgd2hpbGUodHJ1ZSl7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZTogdmFsdWUsIGRvbmU6IGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgIGJ1ZmZlciArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBsZXQgYm91bmRhcnkgPSBidWZmZXIuaW5kZXhPZihcIlxcblxcblwiKTtcbiAgICAgICAgICAgICAgICB3aGlsZShib3VuZGFyeSAhPT0gLTEpe1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYnVmZmVyLnNsaWNlKDAsIGJvdW5kYXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGJvdW5kYXJ5ICsgMik7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNwbGl0IG9uIHRoZSBmaXJzdCBcIjpcIiB0byBleHRyYWN0IHRoZSBKU09OIHBhcnRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZXMgPSBtZXNzYWdlLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5jb2RlZERhdGEgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sb25JbmRleCA9IGxpbmUuaW5kZXhPZihcIjpcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sb25JbmRleCAhPT0gLTEpIGVuY29kZWREYXRhICs9IGxpbmUuc2xpY2UoY29sb25JbmRleCArIDEpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QganNvbkRhdGEgPSBhdG9iKGVuY29kZWREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBKU09OLnBhcnNlKGpzb25EYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZVJlc3BvbnNlKHBhcnNlZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsICQ3YWZiYmQ1OWViYWE0MmJmJGV4cG9ydCRhZjg4ZDAwZGJlN2Y1MjEpLmVycm9yKFwiW1JUVkldIEZhaWxlZCB0byBwYXJzZSBKU09OOlwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeSA9IGJ1ZmZlci5pbmRleE9mKFwiXFxuXFxuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvciByZWd1bGFyIG5vbi1zdHJlYW1lZCByZXNwb25zZXMsIHBhcnNlIGFuZCBoYW5kbGUgdGhlIGRhdGEgYXMgSlNPTlxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGhhbmRsZVJlc3BvbnNlKGRhdGEpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgKDAsICQ3YWZiYmQ1OWViYWE0MmJmJGV4cG9ydCRhZjg4ZDAwZGJlN2Y1MjEpLmVycm9yKFwiW1JUVkldIEVycm9yIGR1cmluZyBmZXRjaDpcIiwgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59IC8qXG4vL0BUT0RPOiBpbXBsZW1lbnQgYWJvcnRDb250cm9sbGVyIHdoZW4gbW9kZSBjaGFuZ2VzIC8gYmFkIHRoaW5ncyBoYXBwZW5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkaXNwYXRjaEFjdGlvbihcbiAgdGhpczogUlRWSUNsaWVudCxcbiAgYWN0aW9uOiBSVFZJQWN0aW9uUmVxdWVzdFxuKTogUHJvbWlzZTxSVFZJQWN0aW9uUmVzcG9uc2U+IHtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlRGlzcGF0Y2hlci5kaXNwYXRjaChhY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYWN0aW9uVXJsID0gdGhpcy5jb25zdHJ1Y3RVcmwoXCJhY3Rpb25cIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaHR0cEFjdGlvbkdlbmVyYXRvcihcbiAgICAgICAgICAgIGFjdGlvblVybCxcbiAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgIHRoaXMucGFyYW1zLFxuICAgICAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuaGFuZGxlTWVzc2FnZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKCk7XG4gIH0pO1xuXG4gIHJldHVybiBwcm9taXNlIGFzIFByb21pc2U8UlRWSUFjdGlvblJlc3BvbnNlPjtcbn1cbiovIFxuXG5cbnZhciAkYTdjMzI0YTczMzAzYWQ1NSRleHBvcnRzID0ge307XG5cbiRwYXJjZWwkZXhwb3J0KCRhN2MzMjRhNzMzMDNhZDU1JGV4cG9ydHMsIFwiUlRWSUNsaWVudFwiLCAoKSA9PiAkYTdjMzI0YTczMzAzYWQ1NSRleHBvcnQkZmE0MmEwMWMxZDYwZjRhMSk7XG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCwgRGFpbHkuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0yLUNsYXVzZVxuICovIFxuXG52YXIgJGUzYmFkOWNjMjVlMzI3ZjckZXhwb3J0cyA9IHt9O1xuJGUzYmFkOWNjMjVlMzI3ZjckZXhwb3J0cyA9IEpTT04ucGFyc2UoXCJ7XFxcIm5hbWVcXFwiOlxcXCJAcGlwZWNhdC1haS9jbGllbnQtanNcXFwiLFxcXCJ2ZXJzaW9uXFxcIjpcXFwiMC40LjFcXFwiLFxcXCJsaWNlbnNlXFxcIjpcXFwiQlNELTItQ2xhdXNlXFxcIixcXFwibWFpblxcXCI6XFxcImRpc3QvaW5kZXguanNcXFwiLFxcXCJtb2R1bGVcXFwiOlxcXCJkaXN0L2luZGV4Lm1vZHVsZS5qc1xcXCIsXFxcInR5cGVzXFxcIjpcXFwiZGlzdC9pbmRleC5kLnRzXFxcIixcXFwic291cmNlXFxcIjpcXFwic3JjL2luZGV4LnRzXFxcIixcXFwicmVwb3NpdG9yeVxcXCI6e1xcXCJ0eXBlXFxcIjpcXFwiZ2l0XFxcIixcXFwidXJsXFxcIjpcXFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9waXBlY2F0LWFpL3BpcGVjYXQtY2xpZW50LXdlYi5naXRcXFwifSxcXFwiZmlsZXNcXFwiOltcXFwiZGlzdFxcXCIsXFxcInBhY2thZ2UuanNvblxcXCIsXFxcIlJFQURNRS5tZFxcXCJdLFxcXCJzY3JpcHRzXFxcIjp7XFxcImJ1aWxkXFxcIjpcXFwiamVzdCAtLXNpbGVudCAmJiBwYXJjZWwgYnVpbGQgLS1uby1jYWNoZVxcXCIsXFxcImRldlxcXCI6XFxcInBhcmNlbCB3YXRjaFxcXCIsXFxcImxpbnRcXFwiOlxcXCJlc2xpbnQgc3JjLyAtLXJlcG9ydC11bnVzZWQtZGlzYWJsZS1kaXJlY3RpdmVzIC0tbWF4LXdhcm5pbmdzIDBcXFwiLFxcXCJ0ZXN0XFxcIjpcXFwiamVzdFxcXCJ9LFxcXCJqZXN0XFxcIjp7XFxcInByZXNldFxcXCI6XFxcInRzLWplc3RcXFwiLFxcXCJ0ZXN0RW52aXJvbm1lbnRcXFwiOlxcXCJub2RlXFxcIn0sXFxcImRldkRlcGVuZGVuY2llc1xcXCI6e1xcXCJAamVzdC9nbG9iYWxzXFxcIjpcXFwiXjI5LjcuMFxcXCIsXFxcIkB0eXBlcy9jbG9uZS1kZWVwXFxcIjpcXFwiXjQuMC40XFxcIixcXFwiQHR5cGVzL2plc3RcXFwiOlxcXCJeMjkuNS4xMlxcXCIsXFxcIkB0eXBlcy91dWlkXFxcIjpcXFwiXjEwLjAuMFxcXCIsXFxcImVzbGludFxcXCI6XFxcIl45LjExLjFcXFwiLFxcXCJlc2xpbnQtY29uZmlnLXByZXR0aWVyXFxcIjpcXFwiXjkuMS4wXFxcIixcXFwiZXNsaW50LXBsdWdpbi1zaW1wbGUtaW1wb3J0LXNvcnRcXFwiOlxcXCJeMTIuMS4xXFxcIixcXFwiamVzdFxcXCI6XFxcIl4yOS43LjBcXFwiLFxcXCJ0cy1qZXN0XFxcIjpcXFwiXjI5LjIuNVxcXCJ9LFxcXCJkZXBlbmRlbmNpZXNcXFwiOntcXFwiQHR5cGVzL2V2ZW50c1xcXCI6XFxcIl4zLjAuM1xcXCIsXFxcImNsb25lLWRlZXBcXFwiOlxcXCJeNC4wLjFcXFwiLFxcXCJldmVudHNcXFwiOlxcXCJeMy4zLjBcXFwiLFxcXCJ0eXBlZC1lbWl0dGVyXFxcIjpcXFwiXjIuMS4wXFxcIixcXFwidXVpZFxcXCI6XFxcIl4xMC4wLjBcXFwifX1cIik7XG5cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQsIERhaWx5LlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMi1DbGF1c2VcbiAqLyB2YXIgJDhlYWQ3YjMzYjg0MDI3NTEkZXhwb3J0cyA9IHt9O1xuXG4kcGFyY2VsJGV4cG9ydCgkOGVhZDdiMzNiODQwMjc1MSRleHBvcnRzLCBcIlJUVklFcnJvclwiLCAoKSA9PiAkOGVhZDdiMzNiODQwMjc1MSRleHBvcnQkNTliNDc4NmYzMzNhYWMwMik7XG4kcGFyY2VsJGV4cG9ydCgkOGVhZDdiMzNiODQwMjc1MSRleHBvcnRzLCBcIkNvbm5lY3Rpb25UaW1lb3V0RXJyb3JcIiwgKCkgPT4gJDhlYWQ3YjMzYjg0MDI3NTEkZXhwb3J0JGM2Nzk5MmZhNjg0YTgxYTYpO1xuJHBhcmNlbCRleHBvcnQoJDhlYWQ3YjMzYjg0MDI3NTEkZXhwb3J0cywgXCJTdGFydEJvdEVycm9yXCIsICgpID0+ICQ4ZWFkN2IzM2I4NDAyNzUxJGV4cG9ydCRlNzU0NGFiODEyMjM4YTYxKTtcbiRwYXJjZWwkZXhwb3J0KCQ4ZWFkN2IzM2I4NDAyNzUxJGV4cG9ydHMsIFwiVHJhbnNwb3J0U3RhcnRFcnJvclwiLCAoKSA9PiAkOGVhZDdiMzNiODQwMjc1MSRleHBvcnQkZTA2MjRhNTExYTJjNGU5KTtcbiRwYXJjZWwkZXhwb3J0KCQ4ZWFkN2IzM2I4NDAyNzUxJGV4cG9ydHMsIFwiQm90Tm90UmVhZHlFcnJvclwiLCAoKSA9PiAkOGVhZDdiMzNiODQwMjc1MSRleHBvcnQkODg1ZmI5NmI4NTBlOGZiYik7XG4kcGFyY2VsJGV4cG9ydCgkOGVhZDdiMzNiODQwMjc1MSRleHBvcnRzLCBcIkNvbmZpZ1VwZGF0ZUVycm9yXCIsICgpID0+ICQ4ZWFkN2IzM2I4NDAyNzUxJGV4cG9ydCQ0ZWRhNGZkMjg3ZmJiY2E1KTtcbiRwYXJjZWwkZXhwb3J0KCQ4ZWFkN2IzM2I4NDAyNzUxJGV4cG9ydHMsIFwiQWN0aW9uRW5kcG9pbnROb3RTZXRFcnJvclwiLCAoKSA9PiAkOGVhZDdiMzNiODQwMjc1MSRleHBvcnQkYmU4MzlmMDEwMGNkMzEzMik7XG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCwgRGFpbHkuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0yLUNsYXVzZVxuICovIGNsYXNzICQ4ZWFkN2IzM2I4NDAyNzUxJGV4cG9ydCQ1OWI0Nzg2ZjMzM2FhYzAyIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cyl7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB9XG59XG5jbGFzcyAkOGVhZDdiMzNiODQwMjc1MSRleHBvcnQkYzY3OTkyZmE2ODRhODFhNiBleHRlbmRzICQ4ZWFkN2IzM2I4NDAyNzUxJGV4cG9ydCQ1OWI0Nzg2ZjMzM2FhYzAyIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKXtcbiAgICAgICAgc3VwZXIobWVzc2FnZSA/PyBcIkJvdCBkaWQgbm90IGVudGVyIHJlYWR5IHN0YXRlIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHRpbWVvdXQgcGVyaW9kLlwiKTtcbiAgICB9XG59XG5jbGFzcyAkOGVhZDdiMzNiODQwMjc1MSRleHBvcnQkZTc1NDRhYjgxMjIzOGE2MSBleHRlbmRzICQ4ZWFkN2IzM2I4NDAyNzUxJGV4cG9ydCQ1OWI0Nzg2ZjMzM2FhYzAyIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMpe1xuICAgICAgICBzdXBlcihtZXNzYWdlID8/IGBGYWlsZWQgdG8gY29ubmVjdCAvIGludmFsaWQgYXV0aCBidW5kbGUgZnJvbSBiYXNlIHVybGAsIHN0YXR1cyA/PyA1MDApO1xuICAgICAgICB0aGlzLmVycm9yID0gXCJpbnZhbGlkLXJlcXVlc3QtZXJyb3JcIjtcbiAgICB9XG59XG5jbGFzcyAkOGVhZDdiMzNiODQwMjc1MSRleHBvcnQkZTA2MjRhNTExYTJjNGU5IGV4dGVuZHMgJDhlYWQ3YjMzYjg0MDI3NTEkZXhwb3J0JDU5YjQ3ODZmMzMzYWFjMDIge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2Upe1xuICAgICAgICBzdXBlcihtZXNzYWdlID8/IFwiVW5hYmxlIHRvIGNvbm5lY3QgdG8gdHJhbnNwb3J0XCIpO1xuICAgIH1cbn1cbmNsYXNzICQ4ZWFkN2IzM2I4NDAyNzUxJGV4cG9ydCQ4ODVmYjk2Yjg1MGU4ZmJiIGV4dGVuZHMgJDhlYWQ3YjMzYjg0MDI3NTEkZXhwb3J0JDU5YjQ3ODZmMzMzYWFjMDIge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2Upe1xuICAgICAgICBzdXBlcihtZXNzYWdlID8/IFwiQXR0ZW1wdCB0byBjYWxsIGFjdGlvbiBvbiB0cmFuc3BvcnQgd2hlbiBub3QgaW4gJ3JlYWR5JyBzdGF0ZS5cIik7XG4gICAgfVxufVxuY2xhc3MgJDhlYWQ3YjMzYjg0MDI3NTEkZXhwb3J0JDRlZGE0ZmQyODdmYmJjYTUgZXh0ZW5kcyAkOGVhZDdiMzNiODQwMjc1MSRleHBvcnQkNTliNDc4NmYzMzNhYWMwMiB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSl7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UgPz8gXCJVbmFibGUgdG8gdXBkYXRlIGNvbmZpZ3VyYXRpb25cIik7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gNDAwO1xuICAgIH1cbn1cbmNsYXNzICQ4ZWFkN2IzM2I4NDAyNzUxJGV4cG9ydCRiZTgzOWYwMTAwY2QzMTMyIGV4dGVuZHMgJDhlYWQ3YjMzYjg0MDI3NTEkZXhwb3J0JDU5YjQ3ODZmMzMzYWFjMDIge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2Upe1xuICAgICAgICBzdXBlcihtZXNzYWdlID8/IFwiQWN0aW9uIGVuZHBvaW50IGlzIG5vdCBzZXRcIik7XG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uICQxNmYwMTlkNGQxNjkxN2RmJGV4cG9ydCRmMTU4NjcyMTAyNGM0ZGFiKF90YXJnZXQsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxNZXRob2QgPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcInJlYWR5XCIpIHJldHVybiBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgZWxzZSB0aHJvdyBuZXcgKDAsICQ4ZWFkN2IzM2I4NDAyNzUxJGV4cG9ydCQ4ODVmYjk2Yjg1MGU4ZmJiKShgQXR0ZW1wdCB0byBjYWxsICR7cHJvcGVydHlLZXkudG9TdHJpbmcoKX0gd2hlbiB0cmFuc3BvcnQgbm90IGluIHJlYWR5IHN0YXRlLiBBd2FpdCBjb25uZWN0KCkgZmlyc3QuYCk7XG4gICAgfTtcbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbn1cbmZ1bmN0aW9uICQxNmYwMTlkNGQxNjkxN2RmJGV4cG9ydCQ4MDg5OTRkMGQ4YzlhY2IzKHN0YXRlcykge1xuICAgIHJldHVybiBmdW5jdGlvbihfdGFyZ2V0LCBwcm9wZXJ0eUtleSwgZGVzY3JpcHRvcikge1xuICAgICAgICBjb25zdCBvcmlnaW5hbE1ldGhvZCA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgIGRlc2NyaXB0b3IuZ2V0ID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICAgICAgaWYgKHN0YXRlcy5pbmNsdWRlcyh0aGlzLnN0YXRlKSkgcmV0dXJuIG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgZWxzZSB0aHJvdyBuZXcgKDAsICQ4ZWFkN2IzM2I4NDAyNzUxJGV4cG9ydCQ4ODVmYjk2Yjg1MGU4ZmJiKShgQXR0ZW1wdCB0byBjYWxsICR7cHJvcGVydHlLZXkudG9TdHJpbmcoKX0gd2hlbiB0cmFuc3BvcnQgbm90IGluICR7c3RhdGVzfS5gKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgfTtcbn1cbmZ1bmN0aW9uICQxNmYwMTlkNGQxNjkxN2RmJGV4cG9ydCQ1YzM1YjRmZTZmYThjOWE2KC4uLnN0YXRlcykge1xuICAgIHN0YXRlcyA9IFtcbiAgICAgICAgXCJyZWFkeVwiLFxuICAgICAgICAuLi5zdGF0ZXNcbiAgICBdO1xuICAgIHJldHVybiBmdW5jdGlvbihfdGFyZ2V0LCBwcm9wZXJ0eUtleSwgZGVzY3JpcHRvcikge1xuICAgICAgICBjb25zdCBvcmlnaW5hbEdldHRlciA9IGRlc2NyaXB0b3IuZ2V0O1xuICAgICAgICBkZXNjcmlwdG9yLmdldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHN0YXRlcy5pbmNsdWRlcyh0aGlzLnN0YXRlKSkgcmV0dXJuIG9yaWdpbmFsR2V0dGVyPy5hcHBseSh0aGlzKTtcbiAgICAgICAgICAgIGVsc2UgdGhyb3cgbmV3ICgwLCAkOGVhZDdiMzNiODQwMjc1MSRleHBvcnQkODg1ZmI5NmI4NTBlOGZiYikoYEF0dGVtcHQgdG8gY2FsbCAke3Byb3BlcnR5S2V5LnRvU3RyaW5nKCl9IHdoZW4gdHJhbnNwb3J0IG5vdCBpbiAke3N0YXRlc30uIEF3YWl0IGNvbm5lY3QoKSBmaXJzdC5gKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgfTtcbn1cblxuXG5cbnZhciAkZjlmYzBjNTdiOWFhZWQ5YyRleHBvcnRzID0ge307XG5cbiRwYXJjZWwkZXhwb3J0KCRmOWZjMGM1N2I5YWFlZDljJGV4cG9ydHMsIFwiUlRWSUV2ZW50XCIsICgpID0+ICRmOWZjMGM1N2I5YWFlZDljJGV4cG9ydCQ2YjQ2MjRkMjMzYzYxZmNiKTtcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDI0LCBEYWlseS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTItQ2xhdXNlXG4gKi8gdmFyICRmOWZjMGM1N2I5YWFlZDljJGV4cG9ydCQ2YjQ2MjRkMjMzYzYxZmNiO1xuKGZ1bmN0aW9uKFJUVklFdmVudCkge1xuICAgIFJUVklFdmVudFtcIk1lc3NhZ2VFcnJvclwiXSA9IFwibWVzc2FnZUVycm9yXCI7XG4gICAgUlRWSUV2ZW50W1wiRXJyb3JcIl0gPSBcImVycm9yXCI7XG4gICAgUlRWSUV2ZW50W1wiQ29ubmVjdGVkXCJdID0gXCJjb25uZWN0ZWRcIjtcbiAgICBSVFZJRXZlbnRbXCJEaXNjb25uZWN0ZWRcIl0gPSBcImRpc2Nvbm5lY3RlZFwiO1xuICAgIFJUVklFdmVudFtcIlRyYW5zcG9ydFN0YXRlQ2hhbmdlZFwiXSA9IFwidHJhbnNwb3J0U3RhdGVDaGFuZ2VkXCI7XG4gICAgUlRWSUV2ZW50W1wiQ29uZmlnXCJdID0gXCJjb25maWdcIjtcbiAgICBSVFZJRXZlbnRbXCJDb25maWdEZXNjcmliZVwiXSA9IFwiY29uZmlnRGVzY3JpYmVcIjtcbiAgICBSVFZJRXZlbnRbXCJBY3Rpb25zQXZhaWxhYmxlXCJdID0gXCJhY3Rpb25zQXZhaWxhYmxlXCI7XG4gICAgUlRWSUV2ZW50W1wiUGFydGljaXBhbnRDb25uZWN0ZWRcIl0gPSBcInBhcnRpY2lwYW50Q29ubmVjdGVkXCI7XG4gICAgUlRWSUV2ZW50W1wiUGFydGljaXBhbnRMZWZ0XCJdID0gXCJwYXJ0aWNpcGFudExlZnRcIjtcbiAgICBSVFZJRXZlbnRbXCJUcmFja1N0YXJ0ZWRcIl0gPSBcInRyYWNrU3RhcnRlZFwiO1xuICAgIFJUVklFdmVudFtcIlRyYWNrU3RvcHBlZFwiXSA9IFwidHJhY2tTdG9wcGVkXCI7XG4gICAgUlRWSUV2ZW50W1wiU2NyZWVuVHJhY2tTdGFydGVkXCJdID0gXCJzY3JlZW5UcmFja1N0YXJ0ZWRcIjtcbiAgICBSVFZJRXZlbnRbXCJTY3JlZW5UcmFja1N0b3BwZWRcIl0gPSBcInNjcmVlblRyYWNrU3RvcHBlZFwiO1xuICAgIFJUVklFdmVudFtcIlNjcmVlblNoYXJlRXJyb3JcIl0gPSBcInNjcmVlblNoYXJlRXJyb3JcIjtcbiAgICBSVFZJRXZlbnRbXCJBdmFpbGFibGVDYW1zVXBkYXRlZFwiXSA9IFwiYXZhaWxhYmxlQ2Ftc1VwZGF0ZWRcIjtcbiAgICBSVFZJRXZlbnRbXCJBdmFpbGFibGVNaWNzVXBkYXRlZFwiXSA9IFwiYXZhaWxhYmxlTWljc1VwZGF0ZWRcIjtcbiAgICBSVFZJRXZlbnRbXCJBdmFpbGFibGVTcGVha2Vyc1VwZGF0ZWRcIl0gPSBcImF2YWlsYWJsZVNwZWFrZXJzVXBkYXRlZFwiO1xuICAgIFJUVklFdmVudFtcIkNhbVVwZGF0ZWRcIl0gPSBcImNhbVVwZGF0ZWRcIjtcbiAgICBSVFZJRXZlbnRbXCJNaWNVcGRhdGVkXCJdID0gXCJtaWNVcGRhdGVkXCI7XG4gICAgUlRWSUV2ZW50W1wiU3BlYWtlclVwZGF0ZWRcIl0gPSBcInNwZWFrZXJVcGRhdGVkXCI7XG4gICAgUlRWSUV2ZW50W1wiQm90Q29ubmVjdGVkXCJdID0gXCJib3RDb25uZWN0ZWRcIjtcbiAgICBSVFZJRXZlbnRbXCJCb3RSZWFkeVwiXSA9IFwiYm90UmVhZHlcIjtcbiAgICBSVFZJRXZlbnRbXCJCb3REaXNjb25uZWN0ZWRcIl0gPSBcImJvdERpc2Nvbm5lY3RlZFwiO1xuICAgIFJUVklFdmVudFtcIkJvdFN0YXJ0ZWRTcGVha2luZ1wiXSA9IFwiYm90U3RhcnRlZFNwZWFraW5nXCI7XG4gICAgUlRWSUV2ZW50W1wiQm90U3RvcHBlZFNwZWFraW5nXCJdID0gXCJib3RTdG9wcGVkU3BlYWtpbmdcIjtcbiAgICBSVFZJRXZlbnRbXCJSZW1vdGVBdWRpb0xldmVsXCJdID0gXCJyZW1vdGVBdWRpb0xldmVsXCI7XG4gICAgUlRWSUV2ZW50W1wiVXNlclN0YXJ0ZWRTcGVha2luZ1wiXSA9IFwidXNlclN0YXJ0ZWRTcGVha2luZ1wiO1xuICAgIFJUVklFdmVudFtcIlVzZXJTdG9wcGVkU3BlYWtpbmdcIl0gPSBcInVzZXJTdG9wcGVkU3BlYWtpbmdcIjtcbiAgICBSVFZJRXZlbnRbXCJMb2NhbEF1ZGlvTGV2ZWxcIl0gPSBcImxvY2FsQXVkaW9MZXZlbFwiO1xuICAgIFJUVklFdmVudFtcIk1ldHJpY3NcIl0gPSBcIm1ldHJpY3NcIjtcbiAgICBSVFZJRXZlbnRbXCJVc2VyVHJhbnNjcmlwdFwiXSA9IFwidXNlclRyYW5zY3JpcHRcIjtcbiAgICBSVFZJRXZlbnRbXCJCb3RUcmFuc2NyaXB0XCJdID0gXCJib3RUcmFuc2NyaXB0XCI7XG4gICAgUlRWSUV2ZW50W1wiQm90TGxtVGV4dFwiXSA9IFwiYm90TGxtVGV4dFwiO1xuICAgIFJUVklFdmVudFtcIkJvdExsbVN0YXJ0ZWRcIl0gPSBcImJvdExsbVN0YXJ0ZWRcIjtcbiAgICBSVFZJRXZlbnRbXCJCb3RMbG1TdG9wcGVkXCJdID0gXCJib3RMbG1TdG9wcGVkXCI7XG4gICAgUlRWSUV2ZW50W1wiQm90VHRzVGV4dFwiXSA9IFwiYm90VHRzVGV4dFwiO1xuICAgIFJUVklFdmVudFtcIkJvdFR0c1N0YXJ0ZWRcIl0gPSBcImJvdFR0c1N0YXJ0ZWRcIjtcbiAgICBSVFZJRXZlbnRbXCJCb3RUdHNTdG9wcGVkXCJdID0gXCJib3RUdHNTdG9wcGVkXCI7XG4gICAgUlRWSUV2ZW50W1wiTExNRnVuY3Rpb25DYWxsXCJdID0gXCJsbG1GdW5jdGlvbkNhbGxcIjtcbiAgICBSVFZJRXZlbnRbXCJMTE1GdW5jdGlvbkNhbGxTdGFydFwiXSA9IFwibGxtRnVuY3Rpb25DYWxsU3RhcnRcIjtcbiAgICBSVFZJRXZlbnRbXCJMTE1Kc29uQ29tcGxldGlvblwiXSA9IFwibGxtSnNvbkNvbXBsZXRpb25cIjtcbiAgICBSVFZJRXZlbnRbXCJTdG9yYWdlSXRlbVN0b3JlZFwiXSA9IFwic3RvcmFnZUl0ZW1TdG9yZWRcIjtcbiAgICBSVFZJRXZlbnRbXCJCb3RMbG1TZWFyY2hSZXNwb25zZVwiXSA9IFwiYm90TGxtU2VhcmNoUmVzcG9uc2VcIjtcbiAgICBSVFZJRXZlbnRbXCJTZXJ2ZXJNZXNzYWdlXCJdID0gXCJzZXJ2ZXJNZXNzYWdlXCI7XG59KSgkZjlmYzBjNTdiOWFhZWQ5YyRleHBvcnQkNmI0NjI0ZDIzM2M2MWZjYiB8fCAoJGY5ZmMwYzU3YjlhYWVkOWMkZXhwb3J0JDZiNDYyNGQyMzNjNjFmY2IgPSB7fSkpO1xuXG5cbnZhciAkNzYxNGZiMjE2OGM1MjNjYyRleHBvcnRzID0ge307XG5cbiRwYXJjZWwkZXhwb3J0KCQ3NjE0ZmIyMTY4YzUyM2NjJGV4cG9ydHMsIFwiUlRWSUNsaWVudEhlbHBlclwiLCAoKSA9PiAkNzYxNGZiMjE2OGM1MjNjYyRleHBvcnQkMjNiYzYzNzI1NWIyYTQ3MSk7XG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCwgRGFpbHkuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0yLUNsYXVzZVxuICovIGNsYXNzICQ3NjE0ZmIyMTY4YzUyM2NjJGV4cG9ydCQyM2JjNjM3MjU1YjJhNDcxIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKXtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIHNldCBjbGllbnQoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgc2V0IHNlcnZpY2Uoc2VydmljZSkge1xuICAgICAgICB0aGlzLl9zZXJ2aWNlID0gc2VydmljZTtcbiAgICB9XG59XG5cblxudmFyICQ3YWZiYmQ1OWViYWE0MmJmJGV4cG9ydHMgPSB7fTtcblxuJHBhcmNlbCRleHBvcnQoJDdhZmJiZDU5ZWJhYTQyYmYkZXhwb3J0cywgXCJMb2dMZXZlbFwiLCAoKSA9PiAkN2FmYmJkNTllYmFhNDJiZiRleHBvcnQkMjQzZTYyZDc4ZDNiNTQ0ZCk7XG4kcGFyY2VsJGV4cG9ydCgkN2FmYmJkNTllYmFhNDJiZiRleHBvcnRzLCBcImxvZ2dlclwiLCAoKSA9PiAkN2FmYmJkNTllYmFhNDJiZiRleHBvcnQkYWY4OGQwMGRiZTdmNTIxKTtcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDI0LCBEYWlseS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTItQ2xhdXNlXG4gKi8gdmFyICQ3YWZiYmQ1OWViYWE0MmJmJGV4cG9ydCQyNDNlNjJkNzhkM2I1NDRkO1xuKGZ1bmN0aW9uKExvZ0xldmVsKSB7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkVSUk9SXCJdID0gMV0gPSBcIkVSUk9SXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJXQVJOXCJdID0gMl0gPSBcIldBUk5cIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIklORk9cIl0gPSAzXSA9IFwiSU5GT1wiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiREVCVUdcIl0gPSA0XSA9IFwiREVCVUdcIjtcbn0pKCQ3YWZiYmQ1OWViYWE0MmJmJGV4cG9ydCQyNDNlNjJkNzhkM2I1NDRkIHx8ICgkN2FmYmJkNTllYmFhNDJiZiRleHBvcnQkMjQzZTYyZDc4ZDNiNTQ0ZCA9IHt9KSk7XG5jbGFzcyAkN2FmYmJkNTllYmFhNDJiZiR2YXIkTG9nZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmxldmVsID0gJDdhZmJiZDU5ZWJhYTQyYmYkZXhwb3J0JDI0M2U2MmQ3OGQzYjU0NGQuREVCVUc7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcbiAgICAgICAgaWYgKCEkN2FmYmJkNTllYmFhNDJiZiR2YXIkTG9nZ2VyLmluc3RhbmNlKSAkN2FmYmJkNTllYmFhNDJiZiR2YXIkTG9nZ2VyLmluc3RhbmNlID0gbmV3ICQ3YWZiYmQ1OWViYWE0MmJmJHZhciRMb2dnZXIoKTtcbiAgICAgICAgcmV0dXJuICQ3YWZiYmQ1OWViYWE0MmJmJHZhciRMb2dnZXIuaW5zdGFuY2U7XG4gICAgfVxuICAgIHNldExldmVsKGxldmVsKSB7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gICAgZGVidWcoLi4uYXJncykge1xuICAgICAgICBpZiAodGhpcy5sZXZlbCA+PSAkN2FmYmJkNTllYmFhNDJiZiRleHBvcnQkMjQzZTYyZDc4ZDNiNTQ0ZC5ERUJVRykgY29uc29sZS5kZWJ1ZyguLi5hcmdzKTtcbiAgICB9XG4gICAgaW5mbyguLi5hcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLmxldmVsID49ICQ3YWZiYmQ1OWViYWE0MmJmJGV4cG9ydCQyNDNlNjJkNzhkM2I1NDRkLklORk8pIGNvbnNvbGUuaW5mbyguLi5hcmdzKTtcbiAgICB9XG4gICAgd2FybiguLi5hcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLmxldmVsID49ICQ3YWZiYmQ1OWViYWE0MmJmJGV4cG9ydCQyNDNlNjJkNzhkM2I1NDRkLldBUk4pIGNvbnNvbGUud2FybiguLi5hcmdzKTtcbiAgICB9XG4gICAgZXJyb3IoLi4uYXJncykge1xuICAgICAgICBpZiAodGhpcy5sZXZlbCA+PSAkN2FmYmJkNTllYmFhNDJiZiRleHBvcnQkMjQzZTYyZDc4ZDNiNTQ0ZC5FUlJPUikgY29uc29sZS5lcnJvciguLi5hcmdzKTtcbiAgICB9XG59XG5jb25zdCAkN2FmYmJkNTllYmFhNDJiZiRleHBvcnQkYWY4OGQwMGRiZTdmNTIxID0gJDdhZmJiZDU5ZWJhYTQyYmYkdmFyJExvZ2dlci5nZXRJbnN0YW5jZSgpO1xuXG5cbnZhciAkYjQ4Zjg5M2VkMTM1NGMxZSRleHBvcnRzID0ge307XG5cbiRwYXJjZWwkZXhwb3J0KCRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydHMsIFwiUlRWSV9NRVNTQUdFX0xBQkVMXCIsICgpID0+ICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQ4ODJiMTNjN2ZkYTMzOGY1KTtcbiRwYXJjZWwkZXhwb3J0KCRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydHMsIFwiUlRWSU1lc3NhZ2VUeXBlXCIsICgpID0+ICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQzOGIzZGIwNWNiZjBlMjQwKTtcbiRwYXJjZWwkZXhwb3J0KCRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydHMsIFwiUlRWSU1lc3NhZ2VcIiwgKCkgPT4gJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDY5YWE5YWIwMzM0YjIxMik7XG4kcGFyY2VsJGV4cG9ydCgkYjQ4Zjg5M2VkMTM1NGMxZSRleHBvcnRzLCBcIlJUVklBY3Rpb25SZXF1ZXN0XCIsICgpID0+ICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQzNzg1MjlkN2E4YmVhZDhiKTtcbiRwYXJjZWwkZXhwb3J0KCRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydHMsIFwiTWVzc2FnZURpc3BhdGNoZXJcIiwgKCkgPT4gJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JGU5YTk2MDY0NmNjNDMyYWEpO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQsIERhaWx5LlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMi1DbGF1c2VcbiAqLyBcblxuXG5cbmNvbnN0ICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQ4ODJiMTNjN2ZkYTMzOGY1ID0gXCJydHZpLWFpXCI7XG52YXIgJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDM4YjNkYjA1Y2JmMGUyNDA7XG4oZnVuY3Rpb24oUlRWSU1lc3NhZ2VUeXBlKSB7XG4gICAgLy8gT3V0Ym91bmRcbiAgICBSVFZJTWVzc2FnZVR5cGVbXCJDTElFTlRfUkVBRFlcIl0gPSBcImNsaWVudC1yZWFkeVwiO1xuICAgIFJUVklNZXNzYWdlVHlwZVtcIlVQREFURV9DT05GSUdcIl0gPSBcInVwZGF0ZS1jb25maWdcIjtcbiAgICBSVFZJTWVzc2FnZVR5cGVbXCJHRVRfQ09ORklHXCJdID0gXCJnZXQtY29uZmlnXCI7XG4gICAgUlRWSU1lc3NhZ2VUeXBlW1wiREVTQ1JJQkVfQ09ORklHXCJdID0gXCJkZXNjcmliZS1jb25maWdcIjtcbiAgICBSVFZJTWVzc2FnZVR5cGVbXCJERVNDUklCRV9BQ1RJT05TXCJdID0gXCJkZXNjcmliZS1hY3Rpb25zXCI7XG4gICAgUlRWSU1lc3NhZ2VUeXBlW1wiRElTQ09OTkVDVF9CT1RcIl0gPSBcImRpc2Nvbm5lY3QtYm90XCI7XG4gICAgUlRWSU1lc3NhZ2VUeXBlW1wiQUNUSU9OXCJdID0gXCJhY3Rpb25cIjtcbiAgICAvLyBJbmJvdW5kXG4gICAgUlRWSU1lc3NhZ2VUeXBlW1wiQk9UX1JFQURZXCJdID0gXCJib3QtcmVhZHlcIjtcbiAgICBSVFZJTWVzc2FnZVR5cGVbXCJFUlJPUlwiXSA9IFwiZXJyb3JcIjtcbiAgICBSVFZJTWVzc2FnZVR5cGVbXCJFUlJPUl9SRVNQT05TRVwiXSA9IFwiZXJyb3ItcmVzcG9uc2VcIjtcbiAgICBSVFZJTWVzc2FnZVR5cGVbXCJDT05GSUdcIl0gPSBcImNvbmZpZ1wiO1xuICAgIFJUVklNZXNzYWdlVHlwZVtcIkNPTkZJR19BVkFJTEFCTEVcIl0gPSBcImNvbmZpZy1hdmFpbGFibGVcIjtcbiAgICBSVFZJTWVzc2FnZVR5cGVbXCJDT05GSUdfRVJST1JcIl0gPSBcImNvbmZpZy1lcnJvclwiO1xuICAgIFJUVklNZXNzYWdlVHlwZVtcIkFDVElPTlNfQVZBSUxBQkxFXCJdID0gXCJhY3Rpb25zLWF2YWlsYWJsZVwiO1xuICAgIFJUVklNZXNzYWdlVHlwZVtcIkFDVElPTl9SRVNQT05TRVwiXSA9IFwiYWN0aW9uLXJlc3BvbnNlXCI7XG4gICAgUlRWSU1lc3NhZ2VUeXBlW1wiTUVUUklDU1wiXSA9IFwibWV0cmljc1wiO1xuICAgIFJUVklNZXNzYWdlVHlwZVtcIlVTRVJfVFJBTlNDUklQVElPTlwiXSA9IFwidXNlci10cmFuc2NyaXB0aW9uXCI7XG4gICAgUlRWSU1lc3NhZ2VUeXBlW1wiQk9UX1RSQU5TQ1JJUFRJT05cIl0gPSBcImJvdC10cmFuc2NyaXB0aW9uXCI7XG4gICAgUlRWSU1lc3NhZ2VUeXBlW1wiVVNFUl9TVEFSVEVEX1NQRUFLSU5HXCJdID0gXCJ1c2VyLXN0YXJ0ZWQtc3BlYWtpbmdcIjtcbiAgICBSVFZJTWVzc2FnZVR5cGVbXCJVU0VSX1NUT1BQRURfU1BFQUtJTkdcIl0gPSBcInVzZXItc3RvcHBlZC1zcGVha2luZ1wiO1xuICAgIFJUVklNZXNzYWdlVHlwZVtcIkJPVF9TVEFSVEVEX1NQRUFLSU5HXCJdID0gXCJib3Qtc3RhcnRlZC1zcGVha2luZ1wiO1xuICAgIFJUVklNZXNzYWdlVHlwZVtcIkJPVF9TVE9QUEVEX1NQRUFLSU5HXCJdID0gXCJib3Qtc3RvcHBlZC1zcGVha2luZ1wiO1xuICAgIC8vIFNlcnZpY2Utc3BlY2lmaWNcbiAgICBSVFZJTWVzc2FnZVR5cGVbXCJVU0VSX0xMTV9URVhUXCJdID0gXCJ1c2VyLWxsbS10ZXh0XCI7XG4gICAgUlRWSU1lc3NhZ2VUeXBlW1wiQk9UX0xMTV9URVhUXCJdID0gXCJib3QtbGxtLXRleHRcIjtcbiAgICBSVFZJTWVzc2FnZVR5cGVbXCJCT1RfTExNX1NUQVJURURcIl0gPSBcImJvdC1sbG0tc3RhcnRlZFwiO1xuICAgIFJUVklNZXNzYWdlVHlwZVtcIkJPVF9MTE1fU1RPUFBFRFwiXSA9IFwiYm90LWxsbS1zdG9wcGVkXCI7XG4gICAgUlRWSU1lc3NhZ2VUeXBlW1wiQk9UX1RUU19URVhUXCJdID0gXCJib3QtdHRzLXRleHRcIjtcbiAgICBSVFZJTWVzc2FnZVR5cGVbXCJCT1RfVFRTX1NUQVJURURcIl0gPSBcImJvdC10dHMtc3RhcnRlZFwiO1xuICAgIFJUVklNZXNzYWdlVHlwZVtcIkJPVF9UVFNfU1RPUFBFRFwiXSA9IFwiYm90LXR0cy1zdG9wcGVkXCI7XG4gICAgUlRWSU1lc3NhZ2VUeXBlW1wiQk9UX0xMTV9TRUFSQ0hfUkVTUE9OU0VcIl0gPSBcImJvdC1sbG0tc2VhcmNoLXJlc3BvbnNlXCI7XG4gICAgLy8gU3RvcmFnZVxuICAgIFJUVklNZXNzYWdlVHlwZVtcIlNUT1JBR0VfSVRFTV9TVE9SRURcIl0gPSBcInN0b3JhZ2UtaXRlbS1zdG9yZWRcIjtcbiAgICAvLyBTZXJ2ZXItdG8tY2xpZW50IG1lc3NhZ2VzXG4gICAgUlRWSU1lc3NhZ2VUeXBlW1wiU0VSVkVSX01FU1NBR0VcIl0gPSBcInNlcnZlci1tZXNzYWdlXCI7XG59KSgkYjQ4Zjg5M2VkMTM1NGMxZSRleHBvcnQkMzhiM2RiMDVjYmYwZTI0MCB8fCAoJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDM4YjNkYjA1Y2JmMGUyNDAgPSB7fSkpO1xuY2xhc3MgJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDY5YWE5YWIwMzM0YjIxMiB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgZGF0YSwgaWQpe1xuICAgICAgICB0aGlzLmxhYmVsID0gJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDg4MmIxM2M3ZmRhMzM4ZjU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuaWQgPSBpZCB8fCAoMCwgJGVJTkRrJHY0KSgpLnNsaWNlKDAsIDgpO1xuICAgIH1cbiAgICAvLyBPdXRib3VuZCBtZXNzYWdlIHR5cGVzXG4gICAgc3RhdGljIGNsaWVudFJlYWR5KCkge1xuICAgICAgICByZXR1cm4gbmV3ICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQ2OWFhOWFiMDMzNGIyMTIoJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDM4YjNkYjA1Y2JmMGUyNDAuQ0xJRU5UX1JFQURZLCB7fSk7XG4gICAgfVxuICAgIHN0YXRpYyB1cGRhdGVDb25maWcoY29uZmlnLCBpbnRlcnJ1cHQgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbmV3ICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQ2OWFhOWFiMDMzNGIyMTIoJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDM4YjNkYjA1Y2JmMGUyNDAuVVBEQVRFX0NPTkZJRywge1xuICAgICAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgICAgICBpbnRlcnJ1cHQ6IGludGVycnVwdFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGRlc2NyaWJlQ29uZmlnKCkge1xuICAgICAgICByZXR1cm4gbmV3ICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQ2OWFhOWFiMDMzNGIyMTIoJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDM4YjNkYjA1Y2JmMGUyNDAuREVTQ1JJQkVfQ09ORklHLCB7fSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRCb3RDb25maWcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDY5YWE5YWIwMzM0YjIxMigkYjQ4Zjg5M2VkMTM1NGMxZSRleHBvcnQkMzhiM2RiMDVjYmYwZTI0MC5HRVRfQ09ORklHLCB7fSk7XG4gICAgfVxuICAgIHN0YXRpYyBkZXNjcmliZUFjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDY5YWE5YWIwMzM0YjIxMigkYjQ4Zjg5M2VkMTM1NGMxZSRleHBvcnQkMzhiM2RiMDVjYmYwZTI0MC5ERVNDUklCRV9BQ1RJT05TLCB7fSk7XG4gICAgfVxuICAgIHN0YXRpYyBkaXNjb25uZWN0Qm90KCkge1xuICAgICAgICByZXR1cm4gbmV3ICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQ2OWFhOWFiMDMzNGIyMTIoJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDM4YjNkYjA1Y2JmMGUyNDAuRElTQ09OTkVDVF9CT1QsIHt9KTtcbiAgICB9XG4gICAgc3RhdGljIGVycm9yKG1lc3NhZ2UsIGZhdGFsID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkYjQ4Zjg5M2VkMTM1NGMxZSRleHBvcnQkNjlhYTlhYjAzMzRiMjEyKCRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQzOGIzZGIwNWNiZjBlMjQwLkVSUk9SLCB7XG4gICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgZmF0YWw6IGZhdGFsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQzNzg1MjlkN2E4YmVhZDhiIGV4dGVuZHMgJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDY5YWE5YWIwMzM0YjIxMiB7XG4gICAgY29uc3RydWN0b3IoZGF0YSl7XG4gICAgICAgIHN1cGVyKCRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQzOGIzZGIwNWNiZjBlMjQwLkFDVElPTiwgZGF0YSk7XG4gICAgfVxufVxuY2xhc3MgJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JGU5YTk2MDY0NmNjNDMyYWEge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCl7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuX2djVGltZSA9IDEwMDAwOyAvLyBIb3cgbG9uZyB0byB3YWl0IGJlZm9yZSByZXNvbHZpbmcgdGhlIG1lc3NhZ2VcbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBkaXNwYXRjaChtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+e1xuICAgICAgICAgICAgdGhpcy5fcXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICByZWplY3Q6IHJlamVjdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAoMCwgJDdhZmJiZDU5ZWJhYTQyYmYkZXhwb3J0JGFmODhkMDBkYmU3ZjUyMSkuZGVidWcoXCJbTWVzc2FnZURpc3BhdGNoZXJdIGRpc3BhdGNoXCIsIG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9jbGllbnQuc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuX2djKCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBhc3luYyBkaXNwYXRjaEFjdGlvbihhY3Rpb24sIG9uTWVzc2FnZSkge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGFjdGlvbixcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICByZWplY3Q6IHJlamVjdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAoMCwgJDdhZmJiZDU5ZWJhYTQyYmYkZXhwb3J0JGFmODhkMDBkYmU3ZjUyMSkuZGVidWcoXCJbTWVzc2FnZURpc3BhdGNoZXJdIGFjdGlvblwiLCBhY3Rpb24pO1xuICAgICAgICBpZiAodGhpcy5fY2xpZW50LmNvbm5lY3RlZCkgLy8gU2VuZCBtZXNzYWdlIHRvIHRyYW5zcG9ydCB3aGVuIGNvbm5lY3RlZFxuICAgICAgICB0aGlzLl9jbGllbnQuc2VuZE1lc3NhZ2UoYWN0aW9uKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NsaWVudC5wYXJhbXMuZW5kcG9pbnRzPy5hY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAoMCwgJDdhZmJiZDU5ZWJhYTQyYmYkZXhwb3J0JGFmODhkMDBkYmU3ZjUyMSkuZXJyb3IoXCJbTWVzc2FnZURpc3BhdGNoZXJdIEFjdGlvbiBlbmRwb2ludCBpcyByZXF1aXJlZCB3aGVuIGRpc3BhdGNoaW5nIGFjdGlvbiBpbiBkaXNjb25uZWN0ZWQgc3RhdGVcIik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3ICgwLCAkOGVhZDdiMzNiODQwMjc1MSRleHBvcnQkYmU4MzlmMDEwMGNkMzEzMikoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFjdGlvblVybCA9IHRoaXMuX2NsaWVudC5jb25zdHJ1Y3RVcmwoXCJhY3Rpb25cIik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIERpc3BhdGNoIGFjdGlvbiB2aWEgSFRUUCB3aGVuIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgICAgIGF3YWl0ICgwLCAkNGJiMzQ5ZjIyYWVlNTE4NSRleHBvcnQkODcyOGI2MGVhNTdiZjQzZSkoYWN0aW9uVXJsLCBhY3Rpb24sIHRoaXMuX2NsaWVudC5wYXJhbXMsIChyZXNwb25zZSk9PntcbiAgICAgICAgICAgICAgICAgICAgb25NZXNzYWdlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE9uIEhUVFAgc3VjY2VzcyAocmVzb2x2ZSksIHNlbmQgYGFjdGlvbmAgbWVzc2FnZSAoZm9yIGNhbGxiYWNrcylcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBvbk1lc3NhZ2UobmV3ICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQ2OWFhOWFiMDMzNGIyMTIoJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDM4YjNkYjA1Y2JmMGUyNDAuRVJST1JfUkVTUE9OU0UsIGBBY3Rpb24gZW5kcG9pbnQgJyR7YWN0aW9uVXJsfScgcmV0dXJuZWQgYW4gZXJyb3IgcmVzcG9uc2VgLCBhY3Rpb24uaWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9nYygpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgX3Jlc29sdmVSZWplY3QobWVzc2FnZSwgcmVzb2x2ZSA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgcXVldWVkTWVzc2FnZSA9IHRoaXMuX3F1ZXVlLmZpbmQoKG1zZyk9Pm1zZy5tZXNzYWdlLmlkID09PSBtZXNzYWdlLmlkKTtcbiAgICAgICAgaWYgKHF1ZXVlZE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgKDAsICQ3YWZiYmQ1OWViYWE0MmJmJGV4cG9ydCRhZjg4ZDAwZGJlN2Y1MjEpLmRlYnVnKFwiW01lc3NhZ2VEaXNwYXRjaGVyXSBSZXNvbHZlXCIsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHF1ZXVlZE1lc3NhZ2UucmVzb2x2ZShtZXNzYWdlLnR5cGUgPT09ICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQzOGIzZGIwNWNiZjBlMjQwLkFDVElPTl9SRVNQT05TRSA/IG1lc3NhZ2UgOiBtZXNzYWdlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKDAsICQ3YWZiYmQ1OWViYWE0MmJmJGV4cG9ydCRhZjg4ZDAwZGJlN2Y1MjEpLmRlYnVnKFwiW01lc3NhZ2VEaXNwYXRjaGVyXSBSZWplY3RcIiwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcXVldWVkTWVzc2FnZS5yZWplY3QobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgbWVzc2FnZSBmcm9tIHF1ZXVlXG4gICAgICAgICAgICB0aGlzLl9xdWV1ZSA9IHRoaXMuX3F1ZXVlLmZpbHRlcigobXNnKT0+bXNnLm1lc3NhZ2UuaWQgIT09IG1lc3NhZ2UuaWQpO1xuICAgICAgICAgICAgKDAsICQ3YWZiYmQ1OWViYWE0MmJmJGV4cG9ydCRhZjg4ZDAwZGJlN2Y1MjEpLmRlYnVnKFwiW01lc3NhZ2VEaXNwYXRjaGVyXSBRdWV1ZVwiLCB0aGlzLl9xdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIHJlc29sdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVJlamVjdChtZXNzYWdlLCB0cnVlKTtcbiAgICB9XG4gICAgcmVqZWN0KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVSZWplY3QobWVzc2FnZSwgZmFsc2UpO1xuICAgIH1cbiAgICBfZ2MoKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gdGhpcy5fcXVldWUuZmlsdGVyKChtc2cpPT57XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIG1zZy50aW1lc3RhbXAgPCB0aGlzLl9nY1RpbWU7XG4gICAgICAgIH0pO1xuICAgICAgICAoMCwgJDdhZmJiZDU5ZWJhYTQyYmYkZXhwb3J0JGFmODhkMDBkYmU3ZjUyMSkuZGVidWcoXCJbTWVzc2FnZURpc3BhdGNoZXJdIEdDXCIsIHRoaXMuX3F1ZXVlKTtcbiAgICB9XG59XG5cblxudmFyICQ0MDg2ZjA2NDQyZmNiN2Q3JGV4cG9ydHMgPSB7fTtcblxuJHBhcmNlbCRleHBvcnQoJDQwODZmMDY0NDJmY2I3ZDckZXhwb3J0cywgXCJUcmFuc3BvcnRcIiwgKCkgPT4gJDQwODZmMDY0NDJmY2I3ZDckZXhwb3J0JDg2NDk1YjA4MWZlZjhlNTIpO1xuJHBhcmNlbCRleHBvcnQoJDQwODZmMDY0NDJmY2I3ZDckZXhwb3J0cywgXCJUcmFuc3BvcnRXcmFwcGVyXCIsICgpID0+ICQ0MDg2ZjA2NDQyZmNiN2Q3JGV4cG9ydCQ4MmI2ZWRlMTYwYTY0YTNjKTtcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDI0LCBEYWlseS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTItQ2xhdXNlXG4gKi8gY2xhc3MgJDQwODZmMDY0NDJmY2I3ZDckZXhwb3J0JDg2NDk1YjA4MWZlZjhlNTIge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gXCJkaXNjb25uZWN0ZWRcIjtcbiAgICAgICAgdGhpcy5fZXhwaXJ5ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgZXhwaXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhwaXJ5O1xuICAgIH1cbn1cbmNsYXNzICQ0MDg2ZjA2NDQyZmNiN2Q3JGV4cG9ydCQ4MmI2ZWRlMTYwYTY0YTNjIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpe1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgIHRoaXMuX3Byb3h5ID0gbmV3IFByb3h5KHRoaXMuX3RyYW5zcG9ydCwge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik9PntcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldFtwcm9wXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnJNc2c7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChTdHJpbmcocHJvcCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzYWJsZSBtZXRob2RzIHRoYXQgbW9kaWZ5IHRoZSBsaWZlY3ljbGUgb2YgdGhlIGNhbGwuIFRoZXNlIG9wZXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBwZXJmb3JtZWQgdmlhIHRoZSBSVFZJIGNsaWVudCBpbiBvcmRlciB0byBrZWVwIHN0YXRlIGluIHN5bmMuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5pdGlhbGl6ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyck1zZyA9IGBEaXJlY3QgY2FsbHMgdG8gaW5pdGlhbGl6ZSgpIGFyZSBkaXNhYmxlZCBhbmQgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBSVFZJQ2xpZW50LmA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5pdERldmljZXNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJNc2cgPSBgRGlyZWN0IGNhbGxzIHRvIGluaXREZXZpY2VzKCkgYXJlIGRpc2FibGVkLiBQbGVhc2UgdXNlIHRoZSBSVFZJQ2xpZW50LmluaXREZXZpY2VzKCkgd3JhcHBlciBvciBsZXQgUlRWSUNsaWVudC5jb25uZWN0KCkgY2FsbCBpdCBmb3IgeW91LmA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2VuZFJlYWR5TWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyck1zZyA9IGBEaXJlY3QgY2FsbHMgdG8gc2VuZFJlYWR5TWVzc2FnZSgpIGFyZSBkaXNhYmxlZCBhbmQgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBSVFZJQ2xpZW50LmA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY29ubmVjdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyck1zZyA9IGBEaXJlY3QgY2FsbHMgdG8gY29ubmVjdCgpIGFyZSBkaXNhYmxlZC4gUGxlYXNlIHVzZSB0aGUgUlRWSUNsaWVudC5jb25uZWN0KCkgd3JhcHBlci5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRpc2Nvbm5lY3RcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJNc2cgPSBgRGlyZWN0IGNhbGxzIHRvIGRpc2Nvbm5lY3QoKSBhcmUgZGlzYWJsZWQuIFBsZWFzZSB1c2UgdGhlIFJUVklDbGllbnQuZGlzY29ubmVjdCgpIHdyYXBwZXIuYDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyTXNnKSByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3J3YXJkIG90aGVyIG1ldGhvZCBjYWxsc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGb3J3YXJkIHByb3BlcnR5IGFjY2Vzc1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBwcm94eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3h5O1xuICAgIH1cbn1cblxuXG52YXIgJGE3YzMyNGE3MzMwM2FkNTUkdmFyJF9fZGVjb3JhdGUgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKWlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5jb25zdCAkYTdjMzI0YTczMzAzYWQ1NSR2YXIkZGVmYXVsdEVuZHBvaW50cyA9IHtcbiAgICBjb25uZWN0OiBcIi9jb25uZWN0XCIsXG4gICAgYWN0aW9uOiBcIi9hY3Rpb25cIlxufTtcbmNsYXNzICRhN2MzMjRhNzMzMDNhZDU1JHZhciRSVFZJRXZlbnRFbWl0dGVyIGV4dGVuZHMgKDAsICRlSU5EayRldmVudHMpIHtcbn1cbmNsYXNzICRhN2MzMjRhNzMzMDNhZDU1JGV4cG9ydCRmYTQyYTAxYzFkNjBmNGExIGV4dGVuZHMgJGE3YzMyNGE3MzMwM2FkNTUkdmFyJFJUVklFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMucGFyYW1zLFxuICAgICAgICAgICAgZW5kcG9pbnRzOiB7XG4gICAgICAgICAgICAgICAgLi4uJGE3YzMyNGE3MzMwM2FkNTUkdmFyJGRlZmF1bHRFbmRwb2ludHMsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5wYXJhbXMuZW5kcG9pbnRzID8/IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2hlbHBlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0ID0gb3B0aW9ucy50cmFuc3BvcnQ7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFdyYXBwZXIgPSBuZXcgKDAsICQ0MDg2ZjA2NDQyZmNiN2Q3JGV4cG9ydCQ4MmI2ZWRlMTYwYTY0YTNjKSh0aGlzLl90cmFuc3BvcnQpO1xuICAgICAgICAvLyBXcmFwIHRyYW5zcG9ydCBjYWxsYmFja3Mgd2l0aCBldmVudCB0cmlnZ2Vyc1xuICAgICAgICAvLyBUaGlzIGFsbG93cyBmb3IgZWl0aGVyIGZ1bmN0aW9uYWwgY2FsbGJhY2tzIG9yIC5vbiAvIC5vZmYgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIGNvbnN0IHdyYXBwZWRDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLmNhbGxiYWNrcyxcbiAgICAgICAgICAgIG9uTWVzc2FnZUVycm9yOiAobWVzc2FnZSk9PntcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5jYWxsYmFja3M/Lm9uTWVzc2FnZUVycm9yPy4obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCgwLCAkZjlmYzBjNTdiOWFhZWQ5YyRleHBvcnQkNmI0NjI0ZDIzM2M2MWZjYikuTWVzc2FnZUVycm9yLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkVycm9yOiAobWVzc2FnZSk9PntcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5jYWxsYmFja3M/Lm9uRXJyb3I/LihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoKDAsICRmOWZjMGM1N2I5YWFlZDljJGV4cG9ydCQ2YjQ2MjRkMjMzYzYxZmNiKS5FcnJvciwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgJDdhZmJiZDU5ZWJhYTQyYmYkZXhwb3J0JGFmODhkMDBkYmU3ZjUyMSkuZGVidWcoXCJDb3VsZCBub3QgZW1pdCBlcnJvclwiLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IG1lc3NhZ2UuZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YT8uZmF0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsICQ3YWZiYmQ1OWViYWE0MmJmJGV4cG9ydCRhZjg4ZDAwZGJlN2Y1MjEpLmVycm9yKFwiRmF0YWwgZXJyb3IgcmVwb3J0ZWQuIERpc2Nvbm5lY3RpbmcuLi5cIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNvbm5lY3RlZDogKCk9PntcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5jYWxsYmFja3M/Lm9uQ29ubmVjdGVkPy4oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoKDAsICRmOWZjMGM1N2I5YWFlZDljJGV4cG9ydCQ2YjQ2MjRkMjMzYzYxZmNiKS5Db25uZWN0ZWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRGlzY29ubmVjdGVkOiAoKT0+e1xuICAgICAgICAgICAgICAgIG9wdGlvbnM/LmNhbGxiYWNrcz8ub25EaXNjb25uZWN0ZWQ/LigpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgoMCwgJGY5ZmMwYzU3YjlhYWVkOWMkZXhwb3J0JDZiNDYyNGQyMzNjNjFmY2IpLkRpc2Nvbm5lY3RlZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25UcmFuc3BvcnRTdGF0ZUNoYW5nZWQ6IChzdGF0ZSk9PntcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5jYWxsYmFja3M/Lm9uVHJhbnNwb3J0U3RhdGVDaGFuZ2VkPy4oc3RhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgoMCwgJGY5ZmMwYzU3YjlhYWVkOWMkZXhwb3J0JDZiNDYyNGQyMzNjNjFmY2IpLlRyYW5zcG9ydFN0YXRlQ2hhbmdlZCwgc3RhdGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQ29uZmlnOiAoY29uZmlnKT0+e1xuICAgICAgICAgICAgICAgIG9wdGlvbnM/LmNhbGxiYWNrcz8ub25Db25maWc/Lihjb25maWcpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgoMCwgJGY5ZmMwYzU3YjlhYWVkOWMkZXhwb3J0JDZiNDYyNGQyMzNjNjFmY2IpLkNvbmZpZywgY29uZmlnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNvbmZpZ0Rlc2NyaWJlOiAoY29uZmlnRGVzY3JpcHRpb24pPT57XG4gICAgICAgICAgICAgICAgb3B0aW9ucz8uY2FsbGJhY2tzPy5vbkNvbmZpZ0Rlc2NyaWJlPy4oY29uZmlnRGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgoMCwgJGY5ZmMwYzU3YjlhYWVkOWMkZXhwb3J0JDZiNDYyNGQyMzNjNjFmY2IpLkNvbmZpZ0Rlc2NyaWJlLCBjb25maWdEZXNjcmlwdGlvbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25BY3Rpb25zQXZhaWxhYmxlOiAoYWN0aW9uc0F2YWlsYWJsZSk9PntcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5jYWxsYmFja3M/Lm9uQWN0aW9uc0F2YWlsYWJsZT8uKGFjdGlvbnNBdmFpbGFibGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgoMCwgJGY5ZmMwYzU3YjlhYWVkOWMkZXhwb3J0JDZiNDYyNGQyMzNjNjFmY2IpLkFjdGlvbnNBdmFpbGFibGUsIGFjdGlvbnNBdmFpbGFibGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUGFydGljaXBhbnRKb2luZWQ6IChwKT0+e1xuICAgICAgICAgICAgICAgIG9wdGlvbnM/LmNhbGxiYWNrcz8ub25QYXJ0aWNpcGFudEpvaW5lZD8uKHApO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgoMCwgJGY5ZmMwYzU3YjlhYWVkOWMkZXhwb3J0JDZiNDYyNGQyMzNjNjFmY2IpLlBhcnRpY2lwYW50Q29ubmVjdGVkLCBwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblBhcnRpY2lwYW50TGVmdDogKHApPT57XG4gICAgICAgICAgICAgICAgb3B0aW9ucz8uY2FsbGJhY2tzPy5vblBhcnRpY2lwYW50TGVmdD8uKHApO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgoMCwgJGY5ZmMwYzU3YjlhYWVkOWMkZXhwb3J0JDZiNDYyNGQyMzNjNjFmY2IpLlBhcnRpY2lwYW50TGVmdCwgcCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25UcmFja1N0YXJ0ZWQ6ICh0cmFjaywgcCk9PntcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5jYWxsYmFja3M/Lm9uVHJhY2tTdGFydGVkPy4odHJhY2ssIHApO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgoMCwgJGY5ZmMwYzU3YjlhYWVkOWMkZXhwb3J0JDZiNDYyNGQyMzNjNjFmY2IpLlRyYWNrU3RhcnRlZCwgdHJhY2ssIHApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uVHJhY2tTdG9wcGVkOiAodHJhY2ssIHApPT57XG4gICAgICAgICAgICAgICAgb3B0aW9ucz8uY2FsbGJhY2tzPy5vblRyYWNrU3RvcHBlZD8uKHRyYWNrLCBwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoKDAsICRmOWZjMGM1N2I5YWFlZDljJGV4cG9ydCQ2YjQ2MjRkMjMzYzYxZmNiKS5UcmFja1N0b3BwZWQsIHRyYWNrLCBwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblNjcmVlblRyYWNrU3RhcnRlZDogKHRyYWNrLCBwKT0+e1xuICAgICAgICAgICAgICAgIG9wdGlvbnM/LmNhbGxiYWNrcz8ub25TY3JlZW5UcmFja1N0YXJ0ZWQ/Lih0cmFjaywgcCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCgwLCAkZjlmYzBjNTdiOWFhZWQ5YyRleHBvcnQkNmI0NjI0ZDIzM2M2MWZjYikuU2NyZWVuVHJhY2tTdGFydGVkLCB0cmFjaywgcCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25TY3JlZW5UcmFja1N0b3BwZWQ6ICh0cmFjaywgcCk9PntcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5jYWxsYmFja3M/Lm9uU2NyZWVuVHJhY2tTdG9wcGVkPy4odHJhY2ssIHApO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgoMCwgJGY5ZmMwYzU3YjlhYWVkOWMkZXhwb3J0JDZiNDYyNGQyMzNjNjFmY2IpLlNjcmVlblRyYWNrU3RvcHBlZCwgdHJhY2ssIHApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uU2NyZWVuU2hhcmVFcnJvcjogKGVycm9yTWVzc2FnZSk9PntcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5jYWxsYmFja3M/Lm9uU2NyZWVuU2hhcmVFcnJvcj8uKGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCgwLCAkZjlmYzBjNTdiOWFhZWQ5YyRleHBvcnQkNmI0NjI0ZDIzM2M2MWZjYikuU2NyZWVuU2hhcmVFcnJvciwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkF2YWlsYWJsZUNhbXNVcGRhdGVkOiAoY2Ftcyk9PntcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5jYWxsYmFja3M/Lm9uQXZhaWxhYmxlQ2Ftc1VwZGF0ZWQ/LihjYW1zKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoKDAsICRmOWZjMGM1N2I5YWFlZDljJGV4cG9ydCQ2YjQ2MjRkMjMzYzYxZmNiKS5BdmFpbGFibGVDYW1zVXBkYXRlZCwgY2Ftcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25BdmFpbGFibGVNaWNzVXBkYXRlZDogKG1pY3MpPT57XG4gICAgICAgICAgICAgICAgb3B0aW9ucz8uY2FsbGJhY2tzPy5vbkF2YWlsYWJsZU1pY3NVcGRhdGVkPy4obWljcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCgwLCAkZjlmYzBjNTdiOWFhZWQ5YyRleHBvcnQkNmI0NjI0ZDIzM2M2MWZjYikuQXZhaWxhYmxlTWljc1VwZGF0ZWQsIG1pY3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQXZhaWxhYmxlU3BlYWtlcnNVcGRhdGVkOiAoc3BlYWtlcnMpPT57XG4gICAgICAgICAgICAgICAgb3B0aW9ucz8uY2FsbGJhY2tzPy5vbkF2YWlsYWJsZVNwZWFrZXJzVXBkYXRlZD8uKHNwZWFrZXJzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoKDAsICRmOWZjMGM1N2I5YWFlZDljJGV4cG9ydCQ2YjQ2MjRkMjMzYzYxZmNiKS5BdmFpbGFibGVTcGVha2Vyc1VwZGF0ZWQsIHNwZWFrZXJzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNhbVVwZGF0ZWQ6IChjYW0pPT57XG4gICAgICAgICAgICAgICAgb3B0aW9ucz8uY2FsbGJhY2tzPy5vbkNhbVVwZGF0ZWQ/LihjYW0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgoMCwgJGY5ZmMwYzU3YjlhYWVkOWMkZXhwb3J0JDZiNDYyNGQyMzNjNjFmY2IpLkNhbVVwZGF0ZWQsIGNhbSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25NaWNVcGRhdGVkOiAobWljKT0+e1xuICAgICAgICAgICAgICAgIG9wdGlvbnM/LmNhbGxiYWNrcz8ub25NaWNVcGRhdGVkPy4obWljKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoKDAsICRmOWZjMGM1N2I5YWFlZDljJGV4cG9ydCQ2YjQ2MjRkMjMzYzYxZmNiKS5NaWNVcGRhdGVkLCBtaWMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uU3BlYWtlclVwZGF0ZWQ6IChzcGVha2VyKT0+e1xuICAgICAgICAgICAgICAgIG9wdGlvbnM/LmNhbGxiYWNrcz8ub25TcGVha2VyVXBkYXRlZD8uKHNwZWFrZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgoMCwgJGY5ZmMwYzU3YjlhYWVkOWMkZXhwb3J0JDZiNDYyNGQyMzNjNjFmY2IpLlNwZWFrZXJVcGRhdGVkLCBzcGVha2VyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkJvdENvbm5lY3RlZDogKHApPT57XG4gICAgICAgICAgICAgICAgb3B0aW9ucz8uY2FsbGJhY2tzPy5vbkJvdENvbm5lY3RlZD8uKHApO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgoMCwgJGY5ZmMwYzU3YjlhYWVkOWMkZXhwb3J0JDZiNDYyNGQyMzNjNjFmY2IpLkJvdENvbm5lY3RlZCwgcCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25Cb3RSZWFkeTogKGJvdFJlYWR5RGF0YSk9PntcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5jYWxsYmFja3M/Lm9uQm90UmVhZHk/Lihib3RSZWFkeURhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgoMCwgJGY5ZmMwYzU3YjlhYWVkOWMkZXhwb3J0JDZiNDYyNGQyMzNjNjFmY2IpLkJvdFJlYWR5LCBib3RSZWFkeURhdGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQm90RGlzY29ubmVjdGVkOiAocCk9PntcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5jYWxsYmFja3M/Lm9uQm90RGlzY29ubmVjdGVkPy4ocCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCgwLCAkZjlmYzBjNTdiOWFhZWQ5YyRleHBvcnQkNmI0NjI0ZDIzM2M2MWZjYikuQm90RGlzY29ubmVjdGVkLCBwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkJvdFN0YXJ0ZWRTcGVha2luZzogKCk9PntcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5jYWxsYmFja3M/Lm9uQm90U3RhcnRlZFNwZWFraW5nPy4oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoKDAsICRmOWZjMGM1N2I5YWFlZDljJGV4cG9ydCQ2YjQ2MjRkMjMzYzYxZmNiKS5Cb3RTdGFydGVkU3BlYWtpbmcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQm90U3RvcHBlZFNwZWFraW5nOiAoKT0+e1xuICAgICAgICAgICAgICAgIG9wdGlvbnM/LmNhbGxiYWNrcz8ub25Cb3RTdG9wcGVkU3BlYWtpbmc/LigpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgoMCwgJGY5ZmMwYzU3YjlhYWVkOWMkZXhwb3J0JDZiNDYyNGQyMzNjNjFmY2IpLkJvdFN0b3BwZWRTcGVha2luZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZW1vdGVBdWRpb0xldmVsOiAobGV2ZWwsIHApPT57XG4gICAgICAgICAgICAgICAgb3B0aW9ucz8uY2FsbGJhY2tzPy5vblJlbW90ZUF1ZGlvTGV2ZWw/LihsZXZlbCwgcCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCgwLCAkZjlmYzBjNTdiOWFhZWQ5YyRleHBvcnQkNmI0NjI0ZDIzM2M2MWZjYikuUmVtb3RlQXVkaW9MZXZlbCwgbGV2ZWwsIHApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uVXNlclN0YXJ0ZWRTcGVha2luZzogKCk9PntcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5jYWxsYmFja3M/Lm9uVXNlclN0YXJ0ZWRTcGVha2luZz8uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCgwLCAkZjlmYzBjNTdiOWFhZWQ5YyRleHBvcnQkNmI0NjI0ZDIzM2M2MWZjYikuVXNlclN0YXJ0ZWRTcGVha2luZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25Vc2VyU3RvcHBlZFNwZWFraW5nOiAoKT0+e1xuICAgICAgICAgICAgICAgIG9wdGlvbnM/LmNhbGxiYWNrcz8ub25Vc2VyU3RvcHBlZFNwZWFraW5nPy4oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoKDAsICRmOWZjMGM1N2I5YWFlZDljJGV4cG9ydCQ2YjQ2MjRkMjMzYzYxZmNiKS5Vc2VyU3RvcHBlZFNwZWFraW5nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkxvY2FsQXVkaW9MZXZlbDogKGxldmVsKT0+e1xuICAgICAgICAgICAgICAgIG9wdGlvbnM/LmNhbGxiYWNrcz8ub25Mb2NhbEF1ZGlvTGV2ZWw/LihsZXZlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCgwLCAkZjlmYzBjNTdiOWFhZWQ5YyRleHBvcnQkNmI0NjI0ZDIzM2M2MWZjYikuTG9jYWxBdWRpb0xldmVsLCBsZXZlbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25Vc2VyVHJhbnNjcmlwdDogKGRhdGEpPT57XG4gICAgICAgICAgICAgICAgb3B0aW9ucz8uY2FsbGJhY2tzPy5vblVzZXJUcmFuc2NyaXB0Py4oZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCgwLCAkZjlmYzBjNTdiOWFhZWQ5YyRleHBvcnQkNmI0NjI0ZDIzM2M2MWZjYikuVXNlclRyYW5zY3JpcHQsIGRhdGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQm90VHJhbnNjcmlwdDogKHRleHQpPT57XG4gICAgICAgICAgICAgICAgb3B0aW9ucz8uY2FsbGJhY2tzPy5vbkJvdFRyYW5zY3JpcHQ/Lih0ZXh0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoKDAsICRmOWZjMGM1N2I5YWFlZDljJGV4cG9ydCQ2YjQ2MjRkMjMzYzYxZmNiKS5Cb3RUcmFuc2NyaXB0LCB0ZXh0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkJvdExsbVRleHQ6ICh0ZXh0KT0+e1xuICAgICAgICAgICAgICAgIG9wdGlvbnM/LmNhbGxiYWNrcz8ub25Cb3RMbG1UZXh0Py4odGV4dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCgwLCAkZjlmYzBjNTdiOWFhZWQ5YyRleHBvcnQkNmI0NjI0ZDIzM2M2MWZjYikuQm90TGxtVGV4dCwgdGV4dCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25Cb3RMbG1TdGFydGVkOiAoKT0+e1xuICAgICAgICAgICAgICAgIG9wdGlvbnM/LmNhbGxiYWNrcz8ub25Cb3RMbG1TdGFydGVkPy4oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoKDAsICRmOWZjMGM1N2I5YWFlZDljJGV4cG9ydCQ2YjQ2MjRkMjMzYzYxZmNiKS5Cb3RMbG1TdGFydGVkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkJvdExsbVN0b3BwZWQ6ICgpPT57XG4gICAgICAgICAgICAgICAgb3B0aW9ucz8uY2FsbGJhY2tzPy5vbkJvdExsbVN0b3BwZWQ/LigpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgoMCwgJGY5ZmMwYzU3YjlhYWVkOWMkZXhwb3J0JDZiNDYyNGQyMzNjNjFmY2IpLkJvdExsbVN0b3BwZWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQm90VHRzVGV4dDogKHRleHQpPT57XG4gICAgICAgICAgICAgICAgb3B0aW9ucz8uY2FsbGJhY2tzPy5vbkJvdFR0c1RleHQ/Lih0ZXh0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoKDAsICRmOWZjMGM1N2I5YWFlZDljJGV4cG9ydCQ2YjQ2MjRkMjMzYzYxZmNiKS5Cb3RUdHNUZXh0LCB0ZXh0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkJvdFR0c1N0YXJ0ZWQ6ICgpPT57XG4gICAgICAgICAgICAgICAgb3B0aW9ucz8uY2FsbGJhY2tzPy5vbkJvdFR0c1N0YXJ0ZWQ/LigpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgoMCwgJGY5ZmMwYzU3YjlhYWVkOWMkZXhwb3J0JDZiNDYyNGQyMzNjNjFmY2IpLkJvdFR0c1N0YXJ0ZWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQm90VHRzU3RvcHBlZDogKCk9PntcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5jYWxsYmFja3M/Lm9uQm90VHRzU3RvcHBlZD8uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCgwLCAkZjlmYzBjNTdiOWFhZWQ5YyRleHBvcnQkNmI0NjI0ZDIzM2M2MWZjYikuQm90VHRzU3RvcHBlZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25TdG9yYWdlSXRlbVN0b3JlZDogKGRhdGEpPT57XG4gICAgICAgICAgICAgICAgb3B0aW9ucz8uY2FsbGJhY2tzPy5vblN0b3JhZ2VJdGVtU3RvcmVkPy4oZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCgwLCAkZjlmYzBjNTdiOWFhZWQ5YyRleHBvcnQkNmI0NjI0ZDIzM2M2MWZjYikuU3RvcmFnZUl0ZW1TdG9yZWQsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBVcGRhdGUgb3B0aW9ucyB0byByZWZlcmVuY2Ugd3JhcHBlZCBjYWxsYmFja3MgYW5kIGNvbmZpZyBkZWZhdWx0c1xuICAgICAgICB0aGlzLl9vcHRpb25zID0ge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGNhbGxiYWNrczogd3JhcHBlZENhbGxiYWNrcyxcbiAgICAgICAgICAgIGVuYWJsZU1pYzogb3B0aW9ucy5lbmFibGVNaWMgPz8gdHJ1ZSxcbiAgICAgICAgICAgIGVuYWJsZUNhbTogb3B0aW9ucy5lbmFibGVDYW0gPz8gZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSW5zdGFudGlhdGUgdGhlIHRyYW5zcG9ydCBjbGFzcyBhbmQgYmluZCBtZXNzYWdlIGhhbmRsZXJcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuICAgICAgICAvLyBHZXQgcGFja2FnZSB2ZXJzaW9uIG51bWJlclxuICAgICAgICAoMCwgJDdhZmJiZDU5ZWJhYTQyYmYkZXhwb3J0JGFmODhkMDBkYmU3ZjUyMSkuZGVidWcoXCJbUlRWSSBDbGllbnRdIEluaXRpYWxpemVkXCIsIHRoaXMudmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0cnVjdFVybChlbmRwb2ludCkge1xuICAgICAgICBpZiAoIXRoaXMucGFyYW1zLmJhc2VVcmwpIHRocm93IG5ldyAkOGVhZDdiMzNiODQwMjc1MSRleHBvcnQkNTliNDc4NmYzMzNhYWMwMihcIkJhc2UgVVJMIG5vdCBzZXQuIFBsZWFzZSBzZXQgcnR2aUNsaWVudC5wYXJhbXMuYmFzZVVybFwiKTtcbiAgICAgICAgY29uc3QgYmFzZVVybCA9IHRoaXMucGFyYW1zLmJhc2VVcmwucmVwbGFjZSgvXFwvKyQvLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIGJhc2VVcmwgKyAodGhpcy5wYXJhbXMuZW5kcG9pbnRzPy5bZW5kcG9pbnRdID8/IFwiXCIpO1xuICAgIH1cbiAgICBzZXRMb2dMZXZlbChsZXZlbCkge1xuICAgICAgICAoMCwgJDdhZmJiZDU5ZWJhYTQyYmYkZXhwb3J0JGFmODhkMDBkYmU3ZjUyMSkuc2V0TGV2ZWwobGV2ZWwpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0gVHJhbnNwb3J0IG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGxvY2FsIG1lZGlhIGRldmljZXNcbiAgICAgKi8gYXN5bmMgaW5pdERldmljZXMoKSB7XG4gICAgICAgICgwLCAkN2FmYmJkNTllYmFhNDJiZiRleHBvcnQkYWY4OGQwMGRiZTdmNTIxKS5kZWJ1ZyhcIltSVFZJIENsaWVudF0gSW5pdGlhbGl6aW5nIGRldmljZXMuLi5cIik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3RyYW5zcG9ydC5pbml0RGV2aWNlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHRoZSB2b2ljZSBjbGllbnQgc2Vzc2lvbiB3aXRoIGNob3NlbiB0cmFuc3BvcnRcbiAgICAgKiBDYWxsIGFzeW5jIChhd2FpdCkgdG8gaGFuZGxlIGVycm9yc1xuICAgICAqLyBhc3luYyBjb25uZWN0KCkge1xuICAgICAgICBpZiAoW1xuICAgICAgICAgICAgXCJhdXRoZW50aWNhdGluZ1wiLFxuICAgICAgICAgICAgXCJjb25uZWN0aW5nXCIsXG4gICAgICAgICAgICBcImNvbm5lY3RlZFwiLFxuICAgICAgICAgICAgXCJyZWFkeVwiXG4gICAgICAgIF0uaW5jbHVkZXModGhpcy5fdHJhbnNwb3J0LnN0YXRlKSkgdGhyb3cgbmV3ICQ4ZWFkN2IzM2I4NDAyNzUxJGV4cG9ydCQ1OWI0Nzg2ZjMzM2FhYzAyKFwiVm9pY2UgY2xpZW50IGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZC4gUGxlYXNlIGNhbGwgZGlzY29ubmVjdCgpIGJlZm9yZSBzdGFydGluZyBhZ2Fpbi5cIik7XG4gICAgICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgLy8gRXN0YWJsaXNoIHRyYW5zcG9ydCBzZXNzaW9uIGFuZCBhd2FpdCBib3QgcmVhZHkgc2lnbmFsXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+e1xuICAgICAgICAgICAgKGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHJhbnNwb3J0LnN0YXRlID09PSBcImRpc2Nvbm5lY3RlZFwiKSBhd2FpdCB0aGlzLl90cmFuc3BvcnQuaW5pdERldmljZXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc3BvcnQuc3RhdGUgPSBcImF1dGhlbnRpY2F0aW5nXCI7XG4gICAgICAgICAgICAgICAgLy8gU2V0IGEgdGltZXIgZm9yIHRoZSBib3QgdG8gZW50ZXIgYSByZWFkeSBzdGF0ZSwgb3RoZXJ3aXNlIGFib3J0IHRoZSBhdHRlbXB0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMudGltZW91dCkgdGhpcy5faGFuZHNoYWtlVGltZW91dCA9IHNldFRpbWVvdXQoYXN5bmMgKCk9PntcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWJvcnRDb250cm9sbGVyPy5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNwb3J0LnN0YXRlID0gXCJlcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3ICQ4ZWFkN2IzM2I4NDAyNzUxJGV4cG9ydCRjNjc5OTJmYTY4NGE4MWE2KCkpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMuX29wdGlvbnMudGltZW91dCk7XG4gICAgICAgICAgICAgICAgbGV0IGF1dGhCdW5kbGU7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VzdG9tQ29ubmVjdEhhbmRsZXIgPSB0aGlzLl9vcHRpb25zLmN1c3RvbUNvbm5lY3RIYW5kbGVyO1xuICAgICAgICAgICAgICAgICgwLCAkN2FmYmJkNTllYmFhNDJiZiRleHBvcnQkYWY4OGQwMGRiZTdmNTIxKS5kZWJ1ZyhcIltSVFZJIENsaWVudF0gU3RhcnQgcGFyYW1zXCIsIHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5wYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3REYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50aGlzLnBhcmFtcy5yZXF1ZXN0RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ0dmlfY2xpZW50X3ZlcnNpb246IHRoaXMudmVyc2lvblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFyYW1zLmJhc2VVcmwgJiYgIXRoaXMucGFyYW1zLmVuZHBvaW50cz8uY29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBiYXNlVXJsIGFuZCBlbmRwb2ludHMuY29ubmVjdCBhcmUgbm90IHNldCwgYnlwYXNzIHRoZSBoYW5kc2hha2UgYW5kIGNvbm5lY3QgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB1c2VmdWwgd2l0aCB0cmFuc3BvcnRzIHRoYXQgZG8gbm90IHJlcXVpcmUgc2VydmljZSBzaWRlIGF1dGgsIGVzcGVjaWFsbHkgaW4gbG9jYWwgZGV2ZWxvcG1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogdGhpcyBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHByb2R1Y3Rpb24gdXNlLCBzZWUgW2RvY3MgbGlua11cbiAgICAgICAgICAgICAgICAgICAgKDAsICQ3YWZiYmQ1OWViYWE0MmJmJGV4cG9ydCRhZjg4ZDAwZGJlN2Y1MjEpLmRlYnVnKFwiW1JUVkkgQ2xpZW50XSBDb25uZWN0aW5nIGRpcmVjdGx5IChza2lwcGluZyBoYW5kc2hha2UgLyBhdXRoKS4uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2hhbmRzaGFrZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RVcmwgPSB0aGlzLmNvbnN0cnVjdFVybChcImNvbm5lY3RcIik7XG4gICAgICAgICAgICAgICAgICAgICgwLCAkN2FmYmJkNTllYmFhNDJiZiRleHBvcnQkYWY4OGQwMGRiZTdmNTIxKS5kZWJ1ZyhcIltSVFZJIENsaWVudF0gQ29ubmVjdGluZy4uLlwiLCBjb25uZWN0VXJsKTtcbiAgICAgICAgICAgICAgICAgICAgKDAsICQ3YWZiYmQ1OWViYWE0MmJmJGV4cG9ydCRhZjg4ZDAwZGJlN2Y1MjEpLmRlYnVnKFwiW1JUVkkgQ2xpZW50XSBTdGFydCBwYXJhbXNcIiwgdGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1c3RvbUNvbm5lY3RIYW5kbGVyKSBhdXRoQnVuZGxlID0gYXdhaXQgY3VzdG9tQ29ubmVjdEhhbmRsZXIodGhpcy5wYXJhbXMsIHRoaXMuX2hhbmRzaGFrZVRpbWVvdXQsIHRoaXMuX2Fib3J0Q29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGF1dGhCdW5kbGUgPSBhd2FpdCBmZXRjaChjb25uZWN0VXJsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImNvcnNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoKHRoaXMucGFyYW1zLmhlYWRlcnMgPz8gbmV3IEhlYWRlcnMoKSkuZW50cmllcygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiB0aGlzLnBhcmFtcy5jb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRoaXMucGFyYW1zLnNlcnZpY2VzID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmljZXM6IHRoaXMucGFyYW1zLnNlcnZpY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5wYXJhbXMucmVxdWVzdERhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IHRoaXMuX2Fib3J0Q29udHJvbGxlcj8uc2lnbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChyZXMpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2hhbmRzaGFrZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMub2spIHJldHVybiByZXMuanNvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9oYW5kc2hha2VUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBlcnJvcnMgaWYgdGhlIHJlcXVlc3Qgd2FzIG5vdCBhYm9ydGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWJvcnRDb250cm9sbGVyPy5zaWduYWwuYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNwb3J0LnN0YXRlID0gXCJlcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yUmVzcCA9IGF3YWl0IGUuanNvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgJDhlYWQ3YjMzYjg0MDI3NTEkZXhwb3J0JGU3NTQ0YWI4MTIyMzhhNjEoZXJyb3JSZXNwLmluZm8gPz8gZXJyb3JSZXNwLmRldGFpbCA/PyBlLnN0YXR1c1RleHQsIGUuc3RhdHVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgcmVqZWN0KG5ldyAkOGVhZDdiMzNiODQwMjc1MSRleHBvcnQkZTc1NDRhYjgxMjIzOGE2MSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAoMCwgJDdhZmJiZDU5ZWJhYTQyYmYkZXhwb3J0JGFmODhkMDBkYmU3ZjUyMSkuZGVidWcoXCJbUlRWSSBDbGllbnRdIEF1dGggYnVuZGxlIHJlY2VpdmVkXCIsIGF1dGhCdW5kbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl90cmFuc3BvcnQuY29ubmVjdChhdXRoQnVuZGxlLCB0aGlzLl9hYm9ydENvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl90cmFuc3BvcnQuc2VuZFJlYWR5TWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2hhbmRzaGFrZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3QgdGhlIHZvaWNlIGNsaWVudCBmcm9tIHRoZSB0cmFuc3BvcnRcbiAgICAgKiBSZXNldCAvIHJlaW5pdGlhbGl6ZSB0cmFuc3BvcnQgYW5kIGFib3J0IGFueSBwZW5kaW5nIHJlcXVlc3RzXG4gICAgICovIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hYm9ydENvbnRyb2xsZXIpIHRoaXMuX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5faGFuZHNoYWtlVGltZW91dCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX3RyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VEaXNwYXRjaGVyID0gbmV3ICgwLCAkYjQ4Zjg5M2VkMTM1NGMxZSRleHBvcnQkZTlhOTYwNjQ2Y2M0MzJhYSkodGhpcyk7XG4gICAgfVxuICAgIF9pbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQuaW5pdGlhbGl6ZSh0aGlzLl9vcHRpb25zLCB0aGlzLmhhbmRsZU1lc3NhZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBtZXNzYWdlIGRpc3BhdGNoIHF1ZXVlIGZvciBhc3luYyBtZXNzYWdlIGhhbmRsaW5nXG4gICAgICAgIHRoaXMuX21lc3NhZ2VEaXNwYXRjaGVyID0gbmV3ICgwLCAkYjQ4Zjg5M2VkMTM1NGMxZSRleHBvcnQkZTlhOTYwNjQ2Y2M0MzJhYSkodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgdHJhbnNwb3J0XG4gICAgICovIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBcImNvbm5lY3RlZFwiLFxuICAgICAgICAgICAgXCJyZWFkeVwiXG4gICAgICAgIF0uaW5jbHVkZXModGhpcy5fdHJhbnNwb3J0LnN0YXRlKTtcbiAgICB9XG4gICAgZ2V0IHRyYW5zcG9ydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydFdyYXBwZXIucHJveHk7XG4gICAgfVxuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5zdGF0ZTtcbiAgICB9XG4gICAgZ2V0IHZlcnNpb24oKSB7XG4gICAgICAgIHJldHVybiAoMCwgKC8qQF9fUFVSRV9fKi8kcGFyY2VsJGludGVyb3BEZWZhdWx0KCRlM2JhZDljYzI1ZTMyN2Y3JGV4cG9ydHMpKSkudmVyc2lvbjtcbiAgICB9XG4gICAgLy8gLS0tLS0tIERldmljZSBtZXRob2RzXG4gICAgYXN5bmMgZ2V0QWxsTWljcygpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3RyYW5zcG9ydC5nZXRBbGxNaWNzKCk7XG4gICAgfVxuICAgIGFzeW5jIGdldEFsbENhbXMoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl90cmFuc3BvcnQuZ2V0QWxsQ2FtcygpO1xuICAgIH1cbiAgICBhc3luYyBnZXRBbGxTcGVha2VycygpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3RyYW5zcG9ydC5nZXRBbGxTcGVha2VycygpO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0ZWRNaWMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuc2VsZWN0ZWRNaWM7XG4gICAgfVxuICAgIGdldCBzZWxlY3RlZENhbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5zZWxlY3RlZENhbTtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkU3BlYWtlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5zZWxlY3RlZFNwZWFrZXI7XG4gICAgfVxuICAgIHVwZGF0ZU1pYyhtaWNJZCkge1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQudXBkYXRlTWljKG1pY0lkKTtcbiAgICB9XG4gICAgdXBkYXRlQ2FtKGNhbUlkKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydC51cGRhdGVDYW0oY2FtSWQpO1xuICAgIH1cbiAgICB1cGRhdGVTcGVha2VyKHNwZWFrZXJJZCkge1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQudXBkYXRlU3BlYWtlcihzcGVha2VySWQpO1xuICAgIH1cbiAgICBlbmFibGVNaWMoZW5hYmxlKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydC5lbmFibGVNaWMoZW5hYmxlKTtcbiAgICB9XG4gICAgZ2V0IGlzTWljRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5pc01pY0VuYWJsZWQ7XG4gICAgfVxuICAgIGVuYWJsZUNhbShlbmFibGUpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0LmVuYWJsZUNhbShlbmFibGUpO1xuICAgIH1cbiAgICBnZXQgaXNDYW1FbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmlzQ2FtRW5hYmxlZDtcbiAgICB9XG4gICAgdHJhY2tzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LnRyYWNrcygpO1xuICAgIH1cbiAgICBlbmFibGVTY3JlZW5TaGFyZShlbmFibGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5lbmFibGVTY3JlZW5TaGFyZShlbmFibGUpO1xuICAgIH1cbiAgICBnZXQgaXNTaGFyaW5nU2NyZWVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmlzU2hhcmluZ1NjcmVlbjtcbiAgICB9XG4gICAgLy8gLS0tLS0tIENvbmZpZyBtZXRob2RzXG4gICAgLyoqXG4gICAgICogUmVxdWVzdCB0aGUgYm90IHRvIHNlbmQgdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvblxuICAgICAqIEByZXR1cm5zIFByb21pc2U8UlRWSUNsaWVudENvbmZpZ09wdGlvbltdPiAtIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBib3QncyBjb25maWd1cmF0aW9uXG4gICAgICovIGFzeW5jIGdldENvbmZpZygpIHtcbiAgICAgICAgY29uc3QgY29uZmlnTXNnID0gYXdhaXQgdGhpcy5fbWVzc2FnZURpc3BhdGNoZXIuZGlzcGF0Y2goKDAsICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQ2OWFhOWFiMDMzNGIyMTIpLmdldEJvdENvbmZpZygpKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZ01zZy5kYXRhLmNvbmZpZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHBpcGVsaW5lIGFuZCBzZXJ2aWNlc1xuICAgICAqIEBwYXJhbSBjb25maWcgLSBSVFZJQ2xpZW50Q29uZmlnT3B0aW9uW10gcGFydGlhbCBvYmplY3Qgd2l0aCB0aGUgbmV3IGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0gaW50ZXJydXB0IC0gYm9vbGVhbiBmbGFnIHRvIGludGVycnVwdCB0aGUgY3VycmVudCBwaXBlbGluZSwgb3Igd2FpdCB1bnRpbCB0aGUgbmV4dCB0dXJuXG4gICAgICogQHJldHVybnMgUHJvbWlzZTxSVFZJTWVzc2FnZT4gLSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgdXBkYXRlZCBjb25maWd1cmF0aW9uXG4gICAgICovIGFzeW5jIHVwZGF0ZUNvbmZpZyhjb25maWcsIGludGVycnVwdCA9IGZhbHNlKSB7XG4gICAgICAgICgwLCAkN2FmYmJkNTllYmFhNDJiZiRleHBvcnQkYWY4OGQwMGRiZTdmNTIxKS5kZWJ1ZyhcIltSVFZJIENsaWVudF0gVXBkYXRpbmcgY29uZmlnXCIsIGNvbmZpZyk7XG4gICAgICAgIC8vIE9ubHkgc2VuZCB0aGUgcGFydGlhbCBjb25maWcgaWYgdGhlIGJvdCBpcyByZWFkeSB0byBwcmV2ZW50XG4gICAgICAgIC8vIHBvdGVudGlhbCByYWNpbmcgY29uZGl0aW9ucyB3aGlsc3QgcGlwZWxpbmUgaXMgaW5zdGFudGlhdGluZ1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVzc2FnZURpc3BhdGNoZXIuZGlzcGF0Y2goKDAsICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQ2OWFhOWFiMDMzNGIyMTIpLnVwZGF0ZUNvbmZpZyhjb25maWcsIGludGVycnVwdCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGJvdCBkZXNjcmliZSB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlPHVua25vd24+IC0gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGJvdCdzIGNvbmZpZ3VyYXRpb24gZGVzY3JpcHRpb25cbiAgICAgKi8gYXN5bmMgZGVzY3JpYmVDb25maWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlRGlzcGF0Y2hlci5kaXNwYXRjaCgoMCwgJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDY5YWE5YWIwMzM0YjIxMikuZGVzY3JpYmVDb25maWcoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBzcGVjaWZpZWQgc2VydmljZSBrZXlcbiAgICAgKiBAcGFyYW0gc2VydmljZUtleSAtIFNlcnZpY2UgbmFtZSB0byBnZXQgb3B0aW9ucyBmb3IgKGUuZy4gXCJsbG1cIilcbiAgICAgKiBAcGFyYW0gY29uZmlnPyAtIE9wdGlvbmFsIFJUVklDbGllbnRDb25maWdPcHRpb25bXSB0byBxdWVyeSAodnMuIHVzaW5nIHJlbW90ZSBjb25maWcpXG4gICAgICogQHJldHVybnMgUlRWSUNsaWVudENvbmZpZ09wdGlvbiB8IHVuZGVmaW5lZCAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBhcnJheSBmb3IgdGhlIHNlcnZpY2Ugd2l0aCBzcGVjaWZpZWQga2V5IG9yIHVuZGVmaW5lZFxuICAgICAqLyBhc3luYyBnZXRTZXJ2aWNlT3B0aW9uc0Zyb21Db25maWcoc2VydmljZUtleSwgY29uZmlnKSB7XG4gICAgICAgIGlmICghY29uZmlnICYmIHRoaXMuc3RhdGUgIT09IFwicmVhZHlcIikgdGhyb3cgbmV3ICQ4ZWFkN2IzM2I4NDAyNzUxJGV4cG9ydCQ4ODVmYjk2Yjg1MGU4ZmJiKFwiZ2V0U2VydmljZU9wdGlvbnNGcm9tQ29uZmlnIGNhbGxlZCB3aXRob3V0IGNvbmZpZyBhcnJheSBiZWZvcmUgYm90IGlzIHJlYWR5XCIpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKT0+e1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSByZWdpc3RlcmVkIHNlcnZpY2Ugd2l0aCBuYW1lIHNlcnZpY2VcbiAgICAgICAgICAgIGlmICghc2VydmljZUtleSkge1xuICAgICAgICAgICAgICAgICgwLCAkN2FmYmJkNTllYmFhNDJiZiRleHBvcnQkYWY4OGQwMGRiZTdmNTIxKS5kZWJ1ZyhcIlRhcmdldCBzZXJ2aWNlIG5hbWUgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhc3NlZENvbmZpZyA9IGNvbmZpZyA/PyBhd2FpdCB0aGlzLmdldENvbmZpZygpO1xuICAgICAgICAgICAgLy8gRmluZCBtYXRjaGluZyBzZXJ2aWNlIG5hbWUgaW4gdGhlIGNvbmZpZyBhbmQgdXBkYXRlIHRoZSBtZXNzYWdlc1xuICAgICAgICAgICAgY29uc3QgY29uZmlnU2VydmljZUtleSA9IHBhc3NlZENvbmZpZy5maW5kKChjb25maWcpPT5jb25maWcuc2VydmljZSA9PT0gc2VydmljZUtleSk7XG4gICAgICAgICAgICBpZiAoIWNvbmZpZ1NlcnZpY2VLZXkpIHtcbiAgICAgICAgICAgICAgICAoMCwgJDdhZmJiZDU5ZWJhYTQyYmYkZXhwb3J0JGFmODhkMDBkYmU3ZjUyMSkuZGVidWcoXCJObyBzZXJ2aWNlIHdpdGggbmFtZSBcIiArIHNlcnZpY2VLZXkgKyBcIiBub3QgZm91bmQgaW4gY29uZmlnXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXR1cm4gYSBuZXcgb2JqZWN0LCBhcyB0byBub3QgbXV0YXRlIGV4aXN0aW5nIHN0YXRlXG4gICAgICAgICAgICByZXR1cm4gY29uZmlnU2VydmljZUtleTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29uZmlndXJhdGlvbiBvcHRpb24gdmFsdWUgKHVua25vd24pIGZvciBzcGVjaWZpZWQgc2VydmljZSBrZXkgYW5kIG9wdGlvbiBuYW1lXG4gICAgICogQHBhcmFtIHNlcnZpY2VLZXkgLSBTZXJ2aWNlIG5hbWUgdG8gZ2V0IG9wdGlvbnMgZm9yIChlLmcuIFwibGxtXCIpXG4gICAgICogQG9wdGlvbmFsIG9wdGlvbiBOYW1lIG9mIG9wdGlvbiByZXR1cm4gZnJvbSB0aGUgY29uZmlnIChlLmcuIFwibW9kZWxcIilcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlPHVua25vd24gfCB1bmRlZmluZWQ+IC0gU2VydmljZSBjb25maWd1cmF0aW9uIG9wdGlvbiB2YWx1ZSBvciB1bmRlZmluZWRcbiAgICAgKi8gYXN5bmMgZ2V0U2VydmljZU9wdGlvblZhbHVlRnJvbUNvbmZpZyhzZXJ2aWNlS2V5LCBvcHRpb24sIGNvbmZpZykge1xuICAgICAgICBjb25zdCBjb25maWdTZXJ2aWNlS2V5ID0gYXdhaXQgdGhpcy5nZXRTZXJ2aWNlT3B0aW9uc0Zyb21Db25maWcoc2VydmljZUtleSwgY29uZmlnKTtcbiAgICAgICAgaWYgKCFjb25maWdTZXJ2aWNlS2V5KSB7XG4gICAgICAgICAgICAoMCwgJDdhZmJiZDU5ZWJhYTQyYmYkZXhwb3J0JGFmODhkMDBkYmU3ZjUyMSkuZGVidWcoXCJTZXJ2aWNlIHdpdGggbmFtZSBcIiArIHNlcnZpY2VLZXkgKyBcIiBub3QgZm91bmQgaW4gY29uZmlnXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIG1hdGNoaW5nIG9wdGlvbiBrZXkgaW4gdGhlIHNlcnZpY2UgY29uZmlnXG4gICAgICAgIGNvbnN0IG9wdGlvblZhbHVlID0gY29uZmlnU2VydmljZUtleS5vcHRpb25zLmZpbmQoKG8pPT5vLm5hbWUgPT09IG9wdGlvbik7XG4gICAgICAgIHJldHVybiBvcHRpb25WYWx1ZSA/IG9wdGlvblZhbHVlLnZhbHVlIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBfdXBkYXRlT3JBZGRPcHRpb24oZXhpc3RpbmdPcHRpb25zLCBuZXdPcHRpb24pIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdPcHRpb25JbmRleCA9IGV4aXN0aW5nT3B0aW9ucy5maW5kSW5kZXgoKGl0ZW0pPT5pdGVtLm5hbWUgPT09IG5ld09wdGlvbi5uYW1lKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nT3B0aW9uSW5kZXggIT09IC0xKSAvLyBVcGRhdGUgZXhpc3Rpbmcgb3B0aW9uXG4gICAgICAgIHJldHVybiBleGlzdGluZ09wdGlvbnMubWFwKChpdGVtLCBpbmRleCk9PmluZGV4ID09PSBleGlzdGluZ09wdGlvbkluZGV4ID8ge1xuICAgICAgICAgICAgICAgIC4uLml0ZW0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ld09wdGlvbi52YWx1ZVxuICAgICAgICAgICAgfSA6IGl0ZW0pO1xuICAgICAgICBlbHNlIC8vIEFkZCBuZXcgb3B0aW9uXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi5leGlzdGluZ09wdGlvbnMsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogbmV3T3B0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ld09wdGlvbi52YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbmZpZyB3aXRoIHVwZGF0ZWQgb3B0aW9uKHMpIGZvciBzcGVjaWZpZWQgc2VydmljZSBrZXkgYW5kIG9wdGlvbiBuYW1lXG4gICAgICogTm90ZTogZG9lcyBub3QgdXBkYXRlIGN1cnJlbnQgY29uZmlnLCBvbmx5IHJldHVybnMgYSBuZXcgb2JqZWN0IChjYWxsIHVwZGF0ZUNvbmZpZyB0byBhcHBseSBjaGFuZ2VzKVxuICAgICAqIEBwYXJhbSBzZXJ2aWNlS2V5IC0gU2VydmljZSBuYW1lIHRvIGdldCBvcHRpb25zIGZvciAoZS5nLiBcImxsbVwiKVxuICAgICAqIEBwYXJhbSBvcHRpb24gLSBTZXJ2aWNlIG5hbWUgdG8gZ2V0IG9wdGlvbnMgZm9yIChlLmcuIFwibW9kZWxcIilcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gT3B0aW9uYWwgUlRWSUNsaWVudENvbmZpZ09wdGlvbltdIHRvIHVwZGF0ZSAodnMuIHVzaW5nIGN1cnJlbnQgY29uZmlnKVxuICAgICAqIEByZXR1cm5zIFByb21pc2U8UlRWSUNsaWVudENvbmZpZ09wdGlvbltdIHwgdW5kZWZpbmVkPiAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBhcnJheSB3aXRoIHVwZGF0ZWQgb3B0aW9uKHMpIG9yIHVuZGVmaW5lZFxuICAgICAqLyBhc3luYyBzZXRTZXJ2aWNlT3B0aW9uSW5Db25maWcoc2VydmljZUtleSwgb3B0aW9uLCBjb25maWcpIHtcbiAgICAgICAgY29uc3QgbmV3Q29uZmlnID0gKDAsICRlSU5EayRjbG9uZWRlZXApKGNvbmZpZyA/PyBhd2FpdCB0aGlzLmdldENvbmZpZygpKTtcbiAgICAgICAgY29uc3Qgc2VydmljZU9wdGlvbnMgPSBhd2FpdCB0aGlzLmdldFNlcnZpY2VPcHRpb25zRnJvbUNvbmZpZyhzZXJ2aWNlS2V5LCBuZXdDb25maWcpO1xuICAgICAgICBpZiAoIXNlcnZpY2VPcHRpb25zKSB7XG4gICAgICAgICAgICAoMCwgJDdhZmJiZDU5ZWJhYTQyYmYkZXhwb3J0JGFmODhkMDBkYmU3ZjUyMSkuZGVidWcoXCJTZXJ2aWNlIHdpdGggbmFtZSAnXCIgKyBzZXJ2aWNlS2V5ICsgXCInIG5vdCBmb3VuZCBpbiBjb25maWdcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3Q29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnNBcnJheSA9IEFycmF5LmlzQXJyYXkob3B0aW9uKSA/IG9wdGlvbiA6IFtcbiAgICAgICAgICAgIG9wdGlvblxuICAgICAgICBdO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdCBvZiBvcHRpb25zQXJyYXkpe1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdJdGVtID0gbmV3Q29uZmlnLmZpbmQoKGl0ZW0pPT5pdGVtLnNlcnZpY2UgPT09IHNlcnZpY2VLZXkpO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZE9wdGlvbnMgPSBleGlzdGluZ0l0ZW0gPyB0aGlzLl91cGRhdGVPckFkZE9wdGlvbihleGlzdGluZ0l0ZW0ub3B0aW9ucywgb3B0KSA6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG9wdC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3B0LnZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0l0ZW0pIGV4aXN0aW5nSXRlbS5vcHRpb25zID0gdXBkYXRlZE9wdGlvbnM7XG4gICAgICAgICAgICBlbHNlIG5ld0NvbmZpZy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzZXJ2aWNlOiBzZXJ2aWNlS2V5LFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHVwZGF0ZWRPcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3Q29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbmZpZyBvYmplY3Qgd2l0aCB1cGRhdGVkIHByb3BlcnRpZXMgZnJvbSBwYXNzZWQgYXJyYXkuXG4gICAgICogQHBhcmFtIGNvbmZpZ09wdGlvbnMgLSBBcnJheSBvZiBSVFZJQ2xpZW50Q29uZmlnT3B0aW9uW10gdG8gdXBkYXRlXG4gICAgICogQHBhcmFtIGNvbmZpZz8gLSBPcHRpb25hbCBSVFZJQ2xpZW50Q29uZmlnT3B0aW9uW10gdG8gdXBkYXRlICh2cy4gdXNpbmcgY3VycmVudCBjb25maWcpXG4gICAgICogQHJldHVybnMgUHJvbWlzZTxSVFZJQ2xpZW50Q29uZmlnT3B0aW9uW10+IC0gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAgICovIGFzeW5jIHNldENvbmZpZ09wdGlvbnMoY29uZmlnT3B0aW9ucywgY29uZmlnKSB7XG4gICAgICAgIGxldCBhY2N1bXVsYXRvciA9ICgwLCAkZUlORGskY2xvbmVkZWVwKShjb25maWcgPz8gYXdhaXQgdGhpcy5nZXRDb25maWcoKSk7XG4gICAgICAgIGZvciAoY29uc3QgY29uZmlnT3B0aW9uIG9mIGNvbmZpZ09wdGlvbnMpYWNjdW11bGF0b3IgPSBhd2FpdCB0aGlzLnNldFNlcnZpY2VPcHRpb25JbkNvbmZpZyhjb25maWdPcHRpb24uc2VydmljZSwgY29uZmlnT3B0aW9uLm9wdGlvbnMsIGFjY3VtdWxhdG9yKSB8fCBhY2N1bXVsYXRvcjtcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cbiAgICAvLyAtLS0tLS0gQWN0aW9uc1xuICAgIC8qKlxuICAgICAqIERpc3BhdGNoIGFuIGFjdGlvbiBtZXNzYWdlIHRvIHRoZSBib3Qgb3IgaHR0cCBzaW5nbGUtdHVybiBlbmRwb2ludFxuICAgICAqLyBhc3luYyBhY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlRGlzcGF0Y2hlci5kaXNwYXRjaEFjdGlvbihuZXcgKDAsICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQzNzg1MjlkN2E4YmVhZDhiKShhY3Rpb24pLCB0aGlzLmhhbmRsZU1lc3NhZ2UuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIGF2YWlsYWJsZSAvIHJlZ2lzdGVyZWQgYWN0aW9ucyB0aGUgYm90IGhhc1xuICAgICAqIEByZXR1cm5zIFByb21pc2U8dW5rbm93bj4gLSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgYm90J3MgYWN0aW9uc1xuICAgICAqLyBhc3luYyBkZXNjcmliZUFjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlRGlzcGF0Y2hlci5kaXNwYXRjaCgoMCwgJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDY5YWE5YWIwMzM0YjIxMikuZGVzY3JpYmVBY3Rpb25zKCkpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0gVHJhbnNwb3J0IG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHNlc3Npb24gZXhwaXJ5IHRpbWUgZm9yIHRoZSB0cmFuc3BvcnQgc2Vzc2lvbiAoaWYgYXBwbGljYWJsZSlcbiAgICAgKiBAcmV0dXJucyBudW1iZXIgLSBFeHBpcnkgdGltZSBpbiBtaWxsaXNlY29uZHNcbiAgICAgKi8gZ2V0IHRyYW5zcG9ydEV4cGlyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5leHBpcnk7XG4gICAgfVxuICAgIC8vIC0tLS0tLSBNZXNzYWdlc1xuICAgIC8qKlxuICAgICAqIERpcmVjdGx5IHNlbmQgYSBtZXNzYWdlIHRvIHRoZSBib3QgdmlhIHRoZSB0cmFuc3BvcnRcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIFJUVklNZXNzYWdlIG9iamVjdCB0byBzZW5kXG4gICAgICovIHNlbmRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0LnNlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0cyB0aGUgYm90LCBidXQga2VlcHMgdGhlIHNlc3Npb24gYWxpdmVcbiAgICAgKi8gZGlzY29ubmVjdEJvdCgpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0LnNlbmRNZXNzYWdlKG5ldyAoMCwgJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDY5YWE5YWIwMzM0YjIxMikoKDAsICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQzOGIzZGIwNWNiZjBlMjQwKS5ESVNDT05ORUNUX0JPVCwge30pKTtcbiAgICB9XG4gICAgaGFuZGxlTWVzc2FnZShldikge1xuICAgICAgICAoMCwgJDdhZmJiZDU5ZWJhYTQyYmYkZXhwb3J0JGFmODhkMDBkYmU3ZjUyMSkuZGVidWcoXCJbUlRWSSBNZXNzYWdlXVwiLCBldik7XG4gICAgICAgIHN3aXRjaChldi50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgKDAsICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQzOGIzZGIwNWNiZjBlMjQwKS5CT1RfUkVBRFk6XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2hhbmRzaGFrZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0UmVzb2x2ZT8uKGV2LmRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzPy5vbkJvdFJlYWR5Py4oZXYuZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICgwLCAkYjQ4Zjg5M2VkMTM1NGMxZSRleHBvcnQkMzhiM2RiMDVjYmYwZTI0MCkuQ09ORklHX0FWQUlMQUJMRTpcbiAgICAgICAgICAgICAgICB0aGlzLl9tZXNzYWdlRGlzcGF0Y2hlci5yZXNvbHZlKGV2KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmNhbGxiYWNrcz8ub25Db25maWdEZXNjcmliZT8uKGV2LmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoMCwgJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDM4YjNkYjA1Y2JmMGUyNDApLkNPTkZJRzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSB0aGlzLl9tZXNzYWdlRGlzcGF0Y2hlci5yZXNvbHZlKGV2KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5jYWxsYmFja3M/Lm9uQ29uZmlnPy4ocmVzcC5kYXRhLmNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgKDAsICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQzOGIzZGIwNWNiZjBlMjQwKS5BQ1RJT05TX0FWQUlMQUJMRTpcbiAgICAgICAgICAgICAgICB0aGlzLl9tZXNzYWdlRGlzcGF0Y2hlci5yZXNvbHZlKGV2KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmNhbGxiYWNrcz8ub25BY3Rpb25zQXZhaWxhYmxlPy4oZXYuZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICgwLCAkYjQ4Zjg5M2VkMTM1NGMxZSRleHBvcnQkMzhiM2RiMDVjYmYwZTI0MCkuQUNUSU9OX1JFU1BPTlNFOlxuICAgICAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VEaXNwYXRjaGVyLnJlc29sdmUoZXYpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoMCwgJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDM4YjNkYjA1Y2JmMGUyNDApLkVSUk9SX1JFU1BPTlNFOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHRoaXMuX21lc3NhZ2VEaXNwYXRjaGVyLnJlamVjdChldik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzPy5vbk1lc3NhZ2VFcnJvcj8uKHJlc3ApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICgwLCAkYjQ4Zjg5M2VkMTM1NGMxZSRleHBvcnQkMzhiM2RiMDVjYmYwZTI0MCkuRVJST1I6XG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5jYWxsYmFja3M/Lm9uRXJyb3I/Lihldik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICgwLCAkYjQ4Zjg5M2VkMTM1NGMxZSRleHBvcnQkMzhiM2RiMDVjYmYwZTI0MCkuVVNFUl9TVEFSVEVEX1NQRUFLSU5HOlxuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzPy5vblVzZXJTdGFydGVkU3BlYWtpbmc/LigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoMCwgJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDM4YjNkYjA1Y2JmMGUyNDApLlVTRVJfU1RPUFBFRF9TUEVBS0lORzpcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmNhbGxiYWNrcz8ub25Vc2VyU3RvcHBlZFNwZWFraW5nPy4oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgKDAsICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQzOGIzZGIwNWNiZjBlMjQwKS5CT1RfU1RBUlRFRF9TUEVBS0lORzpcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmNhbGxiYWNrcz8ub25Cb3RTdGFydGVkU3BlYWtpbmc/LigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoMCwgJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDM4YjNkYjA1Y2JmMGUyNDApLkJPVF9TVE9QUEVEX1NQRUFLSU5HOlxuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzPy5vbkJvdFN0b3BwZWRTcGVha2luZz8uKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICgwLCAkYjQ4Zjg5M2VkMTM1NGMxZSRleHBvcnQkMzhiM2RiMDVjYmYwZTI0MCkuVVNFUl9UUkFOU0NSSVBUSU9OOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgVHJhbnNjcmlwdERhdGEgPSBldi5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmNhbGxiYWNrcz8ub25Vc2VyVHJhbnNjcmlwdD8uKFRyYW5zY3JpcHREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAoMCwgJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDM4YjNkYjA1Y2JmMGUyNDApLkJPVF9UUkFOU0NSSVBUSU9OOlxuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzPy5vbkJvdFRyYW5zY3JpcHQ/Lihldi5kYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgKDAsICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQzOGIzZGIwNWNiZjBlMjQwKS5CT1RfTExNX1RFWFQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5jYWxsYmFja3M/Lm9uQm90TGxtVGV4dD8uKGV2LmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoMCwgJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDM4YjNkYjA1Y2JmMGUyNDApLkJPVF9MTE1fU1RBUlRFRDpcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmNhbGxiYWNrcz8ub25Cb3RMbG1TdGFydGVkPy4oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgKDAsICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQzOGIzZGIwNWNiZjBlMjQwKS5CT1RfTExNX1NUT1BQRUQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5jYWxsYmFja3M/Lm9uQm90TGxtU3RvcHBlZD8uKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICgwLCAkYjQ4Zjg5M2VkMTM1NGMxZSRleHBvcnQkMzhiM2RiMDVjYmYwZTI0MCkuQk9UX1RUU19URVhUOlxuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzPy5vbkJvdFR0c1RleHQ/Lihldi5kYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgKDAsICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQzOGIzZGIwNWNiZjBlMjQwKS5CT1RfVFRTX1NUQVJURUQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5jYWxsYmFja3M/Lm9uQm90VHRzU3RhcnRlZD8uKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICgwLCAkYjQ4Zjg5M2VkMTM1NGMxZSRleHBvcnQkMzhiM2RiMDVjYmYwZTI0MCkuQk9UX1RUU19TVE9QUEVEOlxuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzPy5vbkJvdFR0c1N0b3BwZWQ/LigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoMCwgJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDM4YjNkYjA1Y2JmMGUyNDApLkJPVF9MTE1fU0VBUkNIX1JFU1BPTlNFOlxuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzPy5vbkJvdExsbVNlYXJjaFJlc3BvbnNlPy4oZXYuZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCgwLCAkZjlmYzBjNTdiOWFhZWQ5YyRleHBvcnQkNmI0NjI0ZDIzM2M2MWZjYikuQm90TGxtU2VhcmNoUmVzcG9uc2UsIGV2LmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoMCwgJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDM4YjNkYjA1Y2JmMGUyNDApLk1FVFJJQ1M6XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCgwLCAkZjlmYzBjNTdiOWFhZWQ5YyRleHBvcnQkNmI0NjI0ZDIzM2M2MWZjYikuTWV0cmljcywgZXYuZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5jYWxsYmFja3M/Lm9uTWV0cmljcz8uKGV2LmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoMCwgJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDM4YjNkYjA1Y2JmMGUyNDApLlNUT1JBR0VfSVRFTV9TVE9SRUQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5jYWxsYmFja3M/Lm9uU3RvcmFnZUl0ZW1TdG9yZWQ/Lihldi5kYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgKDAsICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQzOGIzZGIwNWNiZjBlMjQwKS5TRVJWRVJfTUVTU0FHRTpcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmNhbGxiYWNrcz8ub25TZXJ2ZXJNZXNzYWdlPy4oZXYuZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCgwLCAkZjlmYzBjNTdiOWFhZWQ5YyRleHBvcnQkNmI0NjI0ZDIzM2M2MWZjYikuU2VydmVyTWVzc2FnZSwgZXYuZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhc3MgbWVzc2FnZSB0byByZWdpc3RlcmVkIGhlbHBlcnNcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBoZWxwZXIgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9oZWxwZXJzKSlpZiAoaGVscGVyLmdldE1lc3NhZ2VUeXBlcygpLmluY2x1ZGVzKGV2LnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXIuaGFuZGxlTWVzc2FnZShldik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkgdGhpcy5fb3B0aW9ucy5jYWxsYmFja3M/Lm9uR2VuZXJpY01lc3NhZ2U/Lihldi5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gLS0tLS0tIEhlbHBlcnNcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIG5ldyBoZWxwZXIgdG8gdGhlIGNsaWVudFxuICAgICAqIFRoaXMgKG9wdGlvbmFsbHkpIHByb3ZpZGVzIGEgd2F5IHRvIHJlZmVyZW5jZSBoZWxwZXJzIGRpcmVjdGx5XG4gICAgICogZnJvbSB0aGUgY2xpZW50IGFuZCB1c2UgdGhlIGV2ZW50IGRpc3BhdGNoZXJcbiAgICAgKiBAcGFyYW0gc2VydmljZSAtIFRhcmdldCBzZXJ2aWNlIGZvciB0aGlzIGhlbHBlclxuICAgICAqIEBwYXJhbSBoZWxwZXIgLSBIZWxwZXIgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyBSVFZJQ2xpZW50SGVscGVyIC0gUmVnaXN0ZXJlZCBoZWxwZXIgaW5zdGFuY2VcbiAgICAgKi8gcmVnaXN0ZXJIZWxwZXIoc2VydmljZSwgaGVscGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9oZWxwZXJzW3NlcnZpY2VdKSB0aHJvdyBuZXcgRXJyb3IoYEhlbHBlciB3aXRoIG5hbWUgJyR7c2VydmljZX0nIGFscmVhZHkgcmVnaXN0ZXJlZGApO1xuICAgICAgICAvLyBDaGVjayBoZWxwZXIgaXMgaW5zdGFuY2Ugb2YgUlRWSUNsaWVudEhlbHBlclxuICAgICAgICBpZiAoIShoZWxwZXIgaW5zdGFuY2VvZiAoMCwgJDc2MTRmYjIxNjhjNTIzY2MkZXhwb3J0JDIzYmM2MzcyNTViMmE0NzEpKSkgdGhyb3cgbmV3IEVycm9yKGBIZWxwZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSVFZJQ2xpZW50SGVscGVyYCk7XG4gICAgICAgIGhlbHBlci5zZXJ2aWNlID0gc2VydmljZTtcbiAgICAgICAgaGVscGVyLmNsaWVudCA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2hlbHBlcnNbc2VydmljZV0gPSBoZWxwZXI7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWxwZXJzW3NlcnZpY2VdO1xuICAgIH1cbiAgICBnZXRIZWxwZXIoc2VydmljZSkge1xuICAgICAgICBjb25zdCBoZWxwZXIgPSB0aGlzLl9oZWxwZXJzW3NlcnZpY2VdO1xuICAgICAgICBpZiAoIWhlbHBlcikge1xuICAgICAgICAgICAgKDAsICQ3YWZiYmQ1OWViYWE0MmJmJGV4cG9ydCRhZjg4ZDAwZGJlN2Y1MjEpLmRlYnVnKGBIZWxwZXIgdGFyZ2V0aW5nIHNlcnZpY2UgJyR7c2VydmljZX0nIG5vdCBmb3VuZGApO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVscGVyO1xuICAgIH1cbiAgICB1bnJlZ2lzdGVySGVscGVyKHNlcnZpY2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oZWxwZXJzW3NlcnZpY2VdKSByZXR1cm47XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9oZWxwZXJzW3NlcnZpY2VdO1xuICAgIH1cbn1cbiRhN2MzMjRhNzMzMDNhZDU1JHZhciRfX2RlY29yYXRlKFtcbiAgICAoMCwgJDE2ZjAxOWQ0ZDE2OTE3ZGYkZXhwb3J0JGYxNTg2NzIxMDI0YzRkYWIpXG5dLCAkYTdjMzI0YTczMzAzYWQ1NSRleHBvcnQkZmE0MmEwMWMxZDYwZjRhMS5wcm90b3R5cGUsIFwiZ2V0Q29uZmlnXCIsIG51bGwpO1xuJGE3YzMyNGE3MzMwM2FkNTUkdmFyJF9fZGVjb3JhdGUoW1xuICAgICgwLCAkMTZmMDE5ZDRkMTY5MTdkZiRleHBvcnQkZjE1ODY3MjEwMjRjNGRhYilcbl0sICRhN2MzMjRhNzMzMDNhZDU1JGV4cG9ydCRmYTQyYTAxYzFkNjBmNGExLnByb3RvdHlwZSwgXCJ1cGRhdGVDb25maWdcIiwgbnVsbCk7XG4kYTdjMzI0YTczMzAzYWQ1NSR2YXIkX19kZWNvcmF0ZShbXG4gICAgKDAsICQxNmYwMTlkNGQxNjkxN2RmJGV4cG9ydCRmMTU4NjcyMTAyNGM0ZGFiKVxuXSwgJGE3YzMyNGE3MzMwM2FkNTUkZXhwb3J0JGZhNDJhMDFjMWQ2MGY0YTEucHJvdG90eXBlLCBcImRlc2NyaWJlQ29uZmlnXCIsIG51bGwpO1xuJGE3YzMyNGE3MzMwM2FkNTUkdmFyJF9fZGVjb3JhdGUoW1xuICAgICgwLCAkMTZmMDE5ZDRkMTY5MTdkZiRleHBvcnQkZjE1ODY3MjEwMjRjNGRhYilcbl0sICRhN2MzMjRhNzMzMDNhZDU1JGV4cG9ydCRmYTQyYTAxYzFkNjBmNGExLnByb3RvdHlwZSwgXCJkZXNjcmliZUFjdGlvbnNcIiwgbnVsbCk7XG4kYTdjMzI0YTczMzAzYWQ1NSR2YXIkX19kZWNvcmF0ZShbXG4gICAgKDAsICQxNmYwMTlkNGQxNjkxN2RmJGV4cG9ydCQ1YzM1YjRmZTZmYThjOWE2KShcImNvbm5lY3RlZFwiLCBcInJlYWR5XCIpXG5dLCAkYTdjMzI0YTczMzAzYWQ1NSRleHBvcnQkZmE0MmEwMWMxZDYwZjRhMS5wcm90b3R5cGUsIFwidHJhbnNwb3J0RXhwaXJ5XCIsIG51bGwpO1xuJGE3YzMyNGE3MzMwM2FkNTUkdmFyJF9fZGVjb3JhdGUoW1xuICAgICgwLCAkMTZmMDE5ZDRkMTY5MTdkZiRleHBvcnQkZjE1ODY3MjEwMjRjNGRhYilcbl0sICRhN2MzMjRhNzMzMDNhZDU1JGV4cG9ydCRmYTQyYTAxYzFkNjBmNGExLnByb3RvdHlwZSwgXCJzZW5kTWVzc2FnZVwiLCBudWxsKTtcbiRhN2MzMjRhNzMzMDNhZDU1JHZhciRfX2RlY29yYXRlKFtcbiAgICAoMCwgJDE2ZjAxOWQ0ZDE2OTE3ZGYkZXhwb3J0JGYxNTg2NzIxMDI0YzRkYWIpXG5dLCAkYTdjMzI0YTczMzAzYWQ1NSRleHBvcnQkZmE0MmEwMWMxZDYwZjRhMS5wcm90b3R5cGUsIFwiZGlzY29ubmVjdEJvdFwiLCBudWxsKTtcblxuXG5cblxuXG52YXIgJDA5MDhmNjkzZTNlMDcyNGMkZXhwb3J0cyA9IHt9O1xuXG4kcGFyY2VsJGV4cG9ydCgkMDkwOGY2OTNlM2UwNzI0YyRleHBvcnRzLCBcIkxMTU1lc3NhZ2VUeXBlXCIsICgpID0+ICQwOTA4ZjY5M2UzZTA3MjRjJGV4cG9ydCQ0NDFiY2QyZTEwNzYyNzYwKTtcbiRwYXJjZWwkZXhwb3J0KCQwOTA4ZjY5M2UzZTA3MjRjJGV4cG9ydHMsIFwiTExNQWN0aW9uVHlwZVwiLCAoKSA9PiAkMDkwOGY2OTNlM2UwNzI0YyRleHBvcnQkNDNjZGZiMjZmNzkwNDUxKTtcbiRwYXJjZWwkZXhwb3J0KCQwOTA4ZjY5M2UzZTA3MjRjJGV4cG9ydHMsIFwiTExNSGVscGVyXCIsICgpID0+ICQwOTA4ZjY5M2UzZTA3MjRjJGV4cG9ydCQzY2YzOWE2MmQwNzZkZDVjKTtcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDI0LCBEYWlseS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTItQ2xhdXNlXG4gKi8gXG5cblxuXG52YXIgJDA5MDhmNjkzZTNlMDcyNGMkZXhwb3J0JDQ0MWJjZDJlMTA3NjI3NjA7XG4oZnVuY3Rpb24oTExNTWVzc2FnZVR5cGUpIHtcbiAgICBMTE1NZXNzYWdlVHlwZVtcIkxMTV9GVU5DVElPTl9DQUxMXCJdID0gXCJsbG0tZnVuY3Rpb24tY2FsbFwiO1xuICAgIExMTU1lc3NhZ2VUeXBlW1wiTExNX0ZVTkNUSU9OX0NBTExfU1RBUlRcIl0gPSBcImxsbS1mdW5jdGlvbi1jYWxsLXN0YXJ0XCI7XG4gICAgTExNTWVzc2FnZVR5cGVbXCJMTE1fRlVOQ1RJT05fQ0FMTF9SRVNVTFRcIl0gPSBcImxsbS1mdW5jdGlvbi1jYWxsLXJlc3VsdFwiO1xuICAgIExMTU1lc3NhZ2VUeXBlW1wiTExNX0pTT05fQ09NUExFVElPTlwiXSA9IFwibGxtLWpzb24tY29tcGxldGlvblwiO1xufSkoJDA5MDhmNjkzZTNlMDcyNGMkZXhwb3J0JDQ0MWJjZDJlMTA3NjI3NjAgfHwgKCQwOTA4ZjY5M2UzZTA3MjRjJGV4cG9ydCQ0NDFiY2QyZTEwNzYyNzYwID0ge30pKTtcbnZhciAkMDkwOGY2OTNlM2UwNzI0YyRleHBvcnQkNDNjZGZiMjZmNzkwNDUxO1xuKGZ1bmN0aW9uKExMTUFjdGlvblR5cGUpIHtcbiAgICBMTE1BY3Rpb25UeXBlW1wiQVBQRU5EX1RPX01FU1NBR0VTXCJdID0gXCJhcHBlbmRfdG9fbWVzc2FnZXNcIjtcbiAgICBMTE1BY3Rpb25UeXBlW1wiR0VUX0NPTlRFWFRcIl0gPSBcImdldF9jb250ZXh0XCI7XG4gICAgTExNQWN0aW9uVHlwZVtcIlNFVF9DT05URVhUXCJdID0gXCJzZXRfY29udGV4dFwiO1xuICAgIExMTUFjdGlvblR5cGVbXCJSVU5cIl0gPSBcInJ1blwiO1xufSkoJDA5MDhmNjkzZTNlMDcyNGMkZXhwb3J0JDQzY2RmYjI2Zjc5MDQ1MSB8fCAoJDA5MDhmNjkzZTNlMDcyNGMkZXhwb3J0JDQzY2RmYjI2Zjc5MDQ1MSA9IHt9KSk7XG5jbGFzcyAkMDkwOGY2OTNlM2UwNzI0YyRleHBvcnQkM2NmMzlhNjJkMDc2ZGQ1YyBleHRlbmRzICgwLCAkNzYxNGZiMjE2OGM1MjNjYyRleHBvcnQkMjNiYzYzNzI1NWIyYTQ3MSkge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpe1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fZnVuY3Rpb25DYWxsQ2FsbGJhY2sgPSBudWxsO1xuICAgIH1cbiAgICBnZXRNZXNzYWdlVHlwZXMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKCQwOTA4ZjY5M2UzZTA3MjRjJGV4cG9ydCQ0NDFiY2QyZTEwNzYyNzYwKTtcbiAgICB9XG4gICAgLy8gLS0tIEFjdGlvbnNcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgYm90J3MgY3VycmVudCBMTE0gY29udGV4dC5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlPExMTUNvbnRleHQ+XG4gICAgICovIGFzeW5jIGdldENvbnRleHQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbGllbnQuc3RhdGUgIT09IFwicmVhZHlcIikgdGhyb3cgbmV3ICQ4ZWFkN2IzM2I4NDAyNzUxJGV4cG9ydCQ4ODVmYjk2Yjg1MGU4ZmJiKFwiZ2V0Q29udGV4dCBjYWxsZWQgd2hpbGUgdHJhbnNwb3J0IG5vdCBpbiByZWFkeSBzdGF0ZVwiKTtcbiAgICAgICAgY29uc3QgYWN0aW9uUmVzcG9uc2VNc2cgPSBhd2FpdCB0aGlzLl9jbGllbnQuYWN0aW9uKHtcbiAgICAgICAgICAgIHNlcnZpY2U6IHRoaXMuX3NlcnZpY2UsXG4gICAgICAgICAgICBhY3Rpb246ICQwOTA4ZjY5M2UzZTA3MjRjJGV4cG9ydCQ0M2NkZmIyNmY3OTA0NTEuR0VUX0NPTlRFWFRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhY3Rpb25SZXNwb25zZU1zZy5kYXRhLnJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBib3QncyBMTE0gY29udGV4dC5cbiAgICAgKiBJZiB0aGlzIGlzIGNhbGxlZCB3aGlsZSB0aGUgdHJhbnNwb3J0IGlzIG5vdCBpbiB0aGUgcmVhZHkgc3RhdGUsIHRoZSBsb2NhbCBjb250ZXh0IHdpbGwgYmUgdXBkYXRlZFxuICAgICAqIEBwYXJhbSBjb250ZXh0IExMTUNvbnRleHQgLSBUaGUgbmV3IGNvbnRleHRcbiAgICAgKiBAcGFyYW0gaW50ZXJydXB0IGJvb2xlYW4gLSBXaGV0aGVyIHRvIGludGVycnVwdCB0aGUgYm90LCBvciB3YWl0IHVudGlsIGl0IGhhcyBmaW5pc2hlZCBzcGVha2luZ1xuICAgICAqIEByZXR1cm5zIFByb21pc2U8Ym9vbGVhbj5cbiAgICAgKi8gYXN5bmMgc2V0Q29udGV4dChjb250ZXh0LCBpbnRlcnJ1cHQgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5fY2xpZW50LnN0YXRlICE9PSBcInJlYWR5XCIpIHRocm93IG5ldyAkOGVhZDdiMzNiODQwMjc1MSRleHBvcnQkODg1ZmI5NmI4NTBlOGZiYihcInNldENvbnRleHQgY2FsbGVkIHdoaWxlIHRyYW5zcG9ydCBub3QgaW4gcmVhZHkgc3RhdGVcIik7XG4gICAgICAgIGNvbnN0IGFjdGlvblJlc3BvbnNlID0gYXdhaXQgdGhpcy5fY2xpZW50LmFjdGlvbih7XG4gICAgICAgICAgICBzZXJ2aWNlOiB0aGlzLl9zZXJ2aWNlLFxuICAgICAgICAgICAgYWN0aW9uOiAkMDkwOGY2OTNlM2UwNzI0YyRleHBvcnQkNDNjZGZiMjZmNzkwNDUxLlNFVF9DT05URVhULFxuICAgICAgICAgICAgYXJndW1lbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm1lc3NhZ2VzXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0Lm1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaW50ZXJydXB0XCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbnRlcnJ1cHRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gISFhY3Rpb25SZXNwb25zZS5kYXRhLnJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwZW5kIGEgbmV3IG1lc3NhZ2UgdG8gdGhlIExMTSBjb250ZXh0LlxuICAgICAqIElmIHRoaXMgaXMgY2FsbGVkIHdoaWxlIHRoZSB0cmFuc3BvcnQgaXMgbm90IGluIHRoZSByZWFkeSBzdGF0ZSwgdGhlIGxvY2FsIGNvbnRleHQgd2lsbCBiZSB1cGRhdGVkXG4gICAgICogQHBhcmFtIGNvbnRleHQgTExNQ29udGV4dE1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gcnVuSW1tZWRpYXRlbHkgYm9vbGVhbiAtIHdhaXQgdW50aWwgcGlwZWxpbmUgaXMgaWRsZSBiZWZvcmUgcnVubmluZ1xuICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgKi8gYXN5bmMgYXBwZW5kVG9NZXNzYWdlcyhtZXNzYWdlLCBydW5JbW1lZGlhdGVseSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbGllbnQuc3RhdGUgIT09IFwicmVhZHlcIikgdGhyb3cgbmV3ICQ4ZWFkN2IzM2I4NDAyNzUxJGV4cG9ydCQ4ODVmYjk2Yjg1MGU4ZmJiKFwic2V0Q29udGV4dCBjYWxsZWQgd2hpbGUgdHJhbnNwb3J0IG5vdCBpbiByZWFkeSBzdGF0ZVwiKTtcbiAgICAgICAgY29uc3QgYWN0aW9uUmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9jbGllbnQuYWN0aW9uKHtcbiAgICAgICAgICAgIHNlcnZpY2U6IHRoaXMuX3NlcnZpY2UsXG4gICAgICAgICAgICBhY3Rpb246ICQwOTA4ZjY5M2UzZTA3MjRjJGV4cG9ydCQ0M2NkZmIyNmY3OTA0NTEuQVBQRU5EX1RPX01FU1NBR0VTLFxuICAgICAgICAgICAgYXJndW1lbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm1lc3NhZ2VzXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJydW5faW1tZWRpYXRlbHlcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJ1bkltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICEhYWN0aW9uUmVzcG9uc2UuZGF0YS5yZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1biB0aGUgYm90J3MgY3VycmVudCBMTE0gY29udGV4dC5cbiAgICAgKiBVc2VmdWwgd2hlbiBhcHBlbmRpbmcgbWVzc2FnZXMgdG8gdGhlIGNvbnRleHQgd2l0aG91dCBydW5JbW1lZGlhdGVseSBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBXaWxsIGRvIG5vdGhpbmcgaWYgdGhlIGJvdCBpcyBub3QgaW4gdGhlIHJlYWR5IHN0YXRlLlxuICAgICAqIEBwYXJhbSBpbnRlcnJ1cHQgYm9vbGVhbiAtIFdoZXRoZXIgdG8gaW50ZXJydXB0IHRoZSBib3QsIG9yIHdhaXQgdW50aWwgaXQgaGFzIGZpbmlzaGVkIHNwZWFraW5nXG4gICAgICogQHJldHVybnMgUHJvbWlzZTx1bmtub3duPlxuICAgICAqLyBhc3luYyBydW4oaW50ZXJydXB0ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NsaWVudC5zdGF0ZSAhPT0gXCJyZWFkeVwiKSByZXR1cm47XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuYWN0aW9uKHtcbiAgICAgICAgICAgIHNlcnZpY2U6IHRoaXMuX3NlcnZpY2UsXG4gICAgICAgICAgICBhY3Rpb246ICQwOTA4ZjY5M2UzZTA3MjRjJGV4cG9ydCQ0M2NkZmIyNmY3OTA0NTEuUlVOLFxuICAgICAgICAgICAgYXJndW1lbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImludGVycnVwdFwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW50ZXJydXB0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gLS0tIEhhbmRsZXJzXG4gICAgLyoqXG4gICAgICogSWYgdGhlIExMTSB3YW50cyB0byBjYWxsIGEgZnVuY3Rpb24sIFJUVkkgd2lsbCBpbnZva2UgdGhlIGNhbGxiYWNrIGRlZmluZWRcbiAgICAgKiBoZXJlLiBXaGF0ZXZlciB0aGUgY2FsbGJhY2sgcmV0dXJucyB3aWxsIGJlIHNlbnQgdG8gdGhlIExMTSBhcyB0aGUgZnVuY3Rpb24gcmVzdWx0LlxuICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi8gaGFuZGxlRnVuY3Rpb25DYWxsKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2Z1bmN0aW9uQ2FsbENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIGhhbmRsZU1lc3NhZ2UoZXYpIHtcbiAgICAgICAgc3dpdGNoKGV2LnR5cGUpe1xuICAgICAgICAgICAgY2FzZSAkMDkwOGY2OTNlM2UwNzI0YyRleHBvcnQkNDQxYmNkMmUxMDc2Mjc2MC5MTE1fSlNPTl9DT01QTEVUSU9OOlxuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzPy5vbkxMTUpzb25Db21wbGV0aW9uPy4oZXYuZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xpZW50LmVtaXQoKDAsICRmOWZjMGM1N2I5YWFlZDljJGV4cG9ydCQ2YjQ2MjRkMjMzYzYxZmNiKS5MTE1Kc29uQ29tcGxldGlvbiwgZXYuZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICQwOTA4ZjY5M2UzZTA3MjRjJGV4cG9ydCQ0NDFiY2QyZTEwNzYyNzYwLkxMTV9GVU5DVElPTl9DQUxMOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZCA9IGV2LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzPy5vbkxMTUZ1bmN0aW9uQ2FsbD8uKGV2LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGllbnQuZW1pdCgoMCwgJGY5ZmMwYzU3YjlhYWVkOWMkZXhwb3J0JDZiNDYyNGQyMzNjNjFmY2IpLkxMTUZ1bmN0aW9uQ2FsbCwgZXYuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9mdW5jdGlvbkNhbGxDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm4gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBkLmZ1bmN0aW9uX25hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBkLmFyZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2xpZW50LnN0YXRlID09PSBcInJlYWR5XCIpIHRoaXMuX2Z1bmN0aW9uQ2FsbENhbGxiYWNrKGZuKS50aGVuKChyZXN1bHQpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xpZW50LnNlbmRNZXNzYWdlKG5ldyAoMCwgJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDY5YWE5YWIwMzM0YjIxMikoJDA5MDhmNjkzZTNlMDcyNGMkZXhwb3J0JDQ0MWJjZDJlMTA3NjI3NjAuTExNX0ZVTkNUSU9OX0NBTExfUkVTVUxULCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX25hbWU6IGQuZnVuY3Rpb25fbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsX2lkOiBkLnRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBkLmFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHRocm93IG5ldyAkOGVhZDdiMzNiODQwMjc1MSRleHBvcnQkODg1ZmI5NmI4NTBlOGZiYihcIkF0dGVtcHRlZCB0byBzZW5kIGEgZnVuY3Rpb24gY2FsbCByZXN1bHQgZnJvbSBib3Qgd2hpbGUgdHJhbnNwb3J0IG5vdCBpbiByZWFkeSBzdGF0ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICQwOTA4ZjY5M2UzZTA3MjRjJGV4cG9ydCQ0NDFiY2QyZTEwNzYyNzYwLkxMTV9GVU5DVElPTl9DQUxMX1NUQVJUOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IGV2LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzPy5vbkxMTUZ1bmN0aW9uQ2FsbFN0YXJ0Py4oZS5mdW5jdGlvbl9uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xpZW50LmVtaXQoKDAsICRmOWZjMGM1N2I5YWFlZDljJGV4cG9ydCQ2YjQ2MjRkMjMzYzYxZmNiKS5MTE1GdW5jdGlvbkNhbGxTdGFydCwgZS5mdW5jdGlvbl9uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuXG5cblxuXG5leHBvcnQgeyQ0YmIzNDlmMjJhZWU1MTg1JGV4cG9ydCQ4NzI4YjYwZWE1N2JmNDNlIGFzIGh0dHBBY3Rpb25HZW5lcmF0b3IsICRhN2MzMjRhNzMzMDNhZDU1JGV4cG9ydCRmYTQyYTAxYzFkNjBmNGExIGFzIFJUVklDbGllbnQsICQ4ZWFkN2IzM2I4NDAyNzUxJGV4cG9ydCQ1OWI0Nzg2ZjMzM2FhYzAyIGFzIFJUVklFcnJvciwgJDhlYWQ3YjMzYjg0MDI3NTEkZXhwb3J0JGM2Nzk5MmZhNjg0YTgxYTYgYXMgQ29ubmVjdGlvblRpbWVvdXRFcnJvciwgJDhlYWQ3YjMzYjg0MDI3NTEkZXhwb3J0JGU3NTQ0YWI4MTIyMzhhNjEgYXMgU3RhcnRCb3RFcnJvciwgJDhlYWQ3YjMzYjg0MDI3NTEkZXhwb3J0JGUwNjI0YTUxMWEyYzRlOSBhcyBUcmFuc3BvcnRTdGFydEVycm9yLCAkOGVhZDdiMzNiODQwMjc1MSRleHBvcnQkODg1ZmI5NmI4NTBlOGZiYiBhcyBCb3ROb3RSZWFkeUVycm9yLCAkOGVhZDdiMzNiODQwMjc1MSRleHBvcnQkNGVkYTRmZDI4N2ZiYmNhNSBhcyBDb25maWdVcGRhdGVFcnJvciwgJDhlYWQ3YjMzYjg0MDI3NTEkZXhwb3J0JGJlODM5ZjAxMDBjZDMxMzIgYXMgQWN0aW9uRW5kcG9pbnROb3RTZXRFcnJvciwgJGY5ZmMwYzU3YjlhYWVkOWMkZXhwb3J0JDZiNDYyNGQyMzNjNjFmY2IgYXMgUlRWSUV2ZW50LCAkNzYxNGZiMjE2OGM1MjNjYyRleHBvcnQkMjNiYzYzNzI1NWIyYTQ3MSBhcyBSVFZJQ2xpZW50SGVscGVyLCAkMDkwOGY2OTNlM2UwNzI0YyRleHBvcnQkNDQxYmNkMmUxMDc2Mjc2MCBhcyBMTE1NZXNzYWdlVHlwZSwgJDA5MDhmNjkzZTNlMDcyNGMkZXhwb3J0JDQzY2RmYjI2Zjc5MDQ1MSBhcyBMTE1BY3Rpb25UeXBlLCAkMDkwOGY2OTNlM2UwNzI0YyRleHBvcnQkM2NmMzlhNjJkMDc2ZGQ1YyBhcyBMTE1IZWxwZXIsICQ3YWZiYmQ1OWViYWE0MmJmJGV4cG9ydCQyNDNlNjJkNzhkM2I1NDRkIGFzIExvZ0xldmVsLCAkN2FmYmJkNTllYmFhNDJiZiRleHBvcnQkYWY4OGQwMGRiZTdmNTIxIGFzIGxvZ2dlciwgJGI0OGY4OTNlZDEzNTRjMWUkZXhwb3J0JDg4MmIxM2M3ZmRhMzM4ZjUgYXMgUlRWSV9NRVNTQUdFX0xBQkVMLCAkYjQ4Zjg5M2VkMTM1NGMxZSRleHBvcnQkMzhiM2RiMDVjYmYwZTI0MCBhcyBSVFZJTWVzc2FnZVR5cGUsICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQ2OWFhOWFiMDMzNGIyMTIgYXMgUlRWSU1lc3NhZ2UsICRiNDhmODkzZWQxMzU0YzFlJGV4cG9ydCQzNzg1MjlkN2E4YmVhZDhiIGFzIFJUVklBY3Rpb25SZXF1ZXN0LCAkYjQ4Zjg5M2VkMTM1NGMxZSRleHBvcnQkZTlhOTYwNjQ2Y2M0MzJhYSBhcyBNZXNzYWdlRGlzcGF0Y2hlciwgJDQwODZmMDY0NDJmY2I3ZDckZXhwb3J0JDg2NDk1YjA4MWZlZjhlNTIgYXMgVHJhbnNwb3J0LCAkNDA4NmYwNjQ0MmZjYjdkNyRleHBvcnQkODJiNmVkZTE2MGE2NGEzYyBhcyBUcmFuc3BvcnRXcmFwcGVyfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pipecat-ai/client-js/dist/index.module.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pipecat-ai/websocket-transport/dist/index.module.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@pipecat-ai/websocket-transport/dist/index.module.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DailyMediaManager: () => (/* binding */ $22ece045290c996a$export$c95c65abc5f47125),\n/* harmony export */   ProtobufFrameSerializer: () => (/* binding */ $a6c080dc51c9687f$export$4b2026f8e11b148a),\n/* harmony export */   TwilioSerializer: () => (/* binding */ $5b926fa33e35e45c$export$44a8a077420336af),\n/* harmony export */   WavMediaManager: () => (/* binding */ $fc49a56cd8739127$export$45c5b9bfba2f6304),\n/* harmony export */   WebSocketTransport: () => (/* binding */ $7f42eda74f1b1632$export$de21836fc42c6f9c)\n/* harmony export */ });\n/* harmony import */ var _daily_co_daily_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @daily-co/daily-js */ \"(ssr)/./node_modules/@daily-co/daily-js/dist/daily-esm.js\");\n/* harmony import */ var _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pipecat-ai/client-js */ \"(ssr)/./node_modules/@pipecat-ai/client-js/dist/index.module.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/@protobuf-ts/runtime/build/es2015/message-type.js\");\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js\");\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js\");\n/* harmony import */ var x_law__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! x-law */ \"(ssr)/./node_modules/x-law/dist/index.js\");\n\n\n\n\n\n\n// export * from \"./realTimeWebSocketTransport\";\n// export * from \"../../../lib/wavtools/dist/index.d.ts\";\n/**\n * Raw wav audio file contents\n * @typedef {Object} WavPackerAudioType\n * @property {Blob} blob\n * @property {string} url\n * @property {number} channelCount\n * @property {number} sampleRate\n * @property {number} duration\n */ /**\n * Utility class for assembling PCM16 \"audio/wav\" data\n * @class\n */ class $6d4b7449a1e1544a$export$13afda237b1c9846 {\n    /**\n   * Converts Float32Array of amplitude data to ArrayBuffer in Int16Array format\n   * @param {Float32Array} float32Array\n   * @returns {ArrayBuffer}\n   */ static floatTo16BitPCM(float32Array) {\n        const buffer = new ArrayBuffer(float32Array.length * 2);\n        const view = new DataView(buffer);\n        let offset = 0;\n        for(let i = 0; i < float32Array.length; i++, offset += 2){\n            let s = Math.max(-1, Math.min(1, float32Array[i]));\n            view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n        }\n        return buffer;\n    }\n    /**\n   * Concatenates two ArrayBuffers\n   * @param {ArrayBuffer} leftBuffer\n   * @param {ArrayBuffer} rightBuffer\n   * @returns {ArrayBuffer}\n   */ static mergeBuffers(leftBuffer, rightBuffer) {\n        const tmpArray = new Uint8Array(leftBuffer.byteLength + rightBuffer.byteLength);\n        tmpArray.set(new Uint8Array(leftBuffer), 0);\n        tmpArray.set(new Uint8Array(rightBuffer), leftBuffer.byteLength);\n        return tmpArray.buffer;\n    }\n    /**\n   * Packs data into an Int16 format\n   * @private\n   * @param {number} size 0 = 1x Int16, 1 = 2x Int16\n   * @param {number} arg value to pack\n   * @returns\n   */ _packData(size, arg) {\n        return [\n            new Uint8Array([\n                arg,\n                arg >> 8\n            ]),\n            new Uint8Array([\n                arg,\n                arg >> 8,\n                arg >> 16,\n                arg >> 24\n            ])\n        ][size];\n    }\n    /**\n   * Packs audio into \"audio/wav\" Blob\n   * @param {number} sampleRate\n   * @param {{bitsPerSample: number, channels: Array<Float32Array>, data: Int16Array}} audio\n   * @returns {WavPackerAudioType}\n   */ pack(sampleRate, audio) {\n        if (!audio?.bitsPerSample) throw new Error(`Missing \"bitsPerSample\"`);\n        else if (!audio?.channels) throw new Error(`Missing \"channels\"`);\n        else if (!audio?.data) throw new Error(`Missing \"data\"`);\n        const { bitsPerSample: bitsPerSample, channels: channels, data: data } = audio;\n        const output = [\n            // Header\n            'RIFF',\n            this._packData(1, 52),\n            'WAVE',\n            // chunk 1\n            'fmt ',\n            this._packData(1, 16),\n            this._packData(0, 1),\n            this._packData(0, channels.length),\n            this._packData(1, sampleRate),\n            this._packData(1, sampleRate * channels.length * bitsPerSample / 8),\n            this._packData(0, channels.length * bitsPerSample / 8),\n            this._packData(0, bitsPerSample),\n            // chunk 2\n            'data',\n            this._packData(1, channels[0].length * channels.length * bitsPerSample / 8),\n            data\n        ];\n        const blob = new Blob(output, {\n            type: 'audio/mpeg'\n        });\n        const url = URL.createObjectURL(blob);\n        return {\n            blob: blob,\n            url: url,\n            channelCount: channels.length,\n            sampleRate: sampleRate,\n            duration: data.byteLength / (channels.length * sampleRate * 2)\n        };\n    }\n}\nglobalThis.WavPacker = $6d4b7449a1e1544a$export$13afda237b1c9846;\n\n\n/**\n * Constants for help with visualization\n * Helps map frequency ranges from Fast Fourier Transform\n * to human-interpretable ranges, notably music ranges and\n * human vocal ranges.\n */ // Eighth octave frequencies\nconst $03f71ce85e00ada6$var$octave8Frequencies = [\n    4186.01,\n    4434.92,\n    4698.63,\n    4978.03,\n    5274.04,\n    5587.65,\n    5919.91,\n    6271.93,\n    6644.88,\n    7040.0,\n    7458.62,\n    7902.13\n];\n// Labels for each of the above frequencies\nconst $03f71ce85e00ada6$var$octave8FrequencyLabels = [\n    'C',\n    'C#',\n    'D',\n    'D#',\n    'E',\n    'F',\n    'F#',\n    'G',\n    'G#',\n    'A',\n    'A#',\n    'B'\n];\nconst $03f71ce85e00ada6$export$776c63898ae5b636 = [];\nconst $03f71ce85e00ada6$export$facd167cc27ea9b0 = [];\nfor(let i = 1; i <= 8; i++)for(let f = 0; f < $03f71ce85e00ada6$var$octave8Frequencies.length; f++){\n    const freq = $03f71ce85e00ada6$var$octave8Frequencies[f];\n    $03f71ce85e00ada6$export$776c63898ae5b636.push(freq / Math.pow(2, 8 - i));\n    $03f71ce85e00ada6$export$facd167cc27ea9b0.push($03f71ce85e00ada6$var$octave8FrequencyLabels[f] + i);\n}\n/**\n * Subset of the note frequencies between 32 and 2000 Hz\n * 6 octave range: C1 to B6\n */ const $03f71ce85e00ada6$var$voiceFrequencyRange = [\n    32.0,\n    2000.0\n];\nconst $03f71ce85e00ada6$export$dbc1581ed2cfa183 = $03f71ce85e00ada6$export$776c63898ae5b636.filter((_, i)=>{\n    return $03f71ce85e00ada6$export$776c63898ae5b636[i] > $03f71ce85e00ada6$var$voiceFrequencyRange[0] && $03f71ce85e00ada6$export$776c63898ae5b636[i] < $03f71ce85e00ada6$var$voiceFrequencyRange[1];\n});\nconst $03f71ce85e00ada6$export$30a6f2881311088f = $03f71ce85e00ada6$export$facd167cc27ea9b0.filter((_, i)=>{\n    return $03f71ce85e00ada6$export$776c63898ae5b636[i] > $03f71ce85e00ada6$var$voiceFrequencyRange[0] && $03f71ce85e00ada6$export$776c63898ae5b636[i] < $03f71ce85e00ada6$var$voiceFrequencyRange[1];\n});\n\n\nclass $f32f064564ee62f6$export$2c3136da0bf130f9 {\n    /**\n   * Retrieves frequency domain data from an AnalyserNode adjusted to a decibel range\n   * returns human-readable formatting and labels\n   * @param {AnalyserNode} analyser\n   * @param {number} sampleRate\n   * @param {Float32Array} [fftResult]\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {AudioAnalysisOutputType}\n   */ static getFrequencies(analyser, sampleRate, fftResult, analysisType = 'frequency', minDecibels = -100, maxDecibels = -30) {\n        if (!fftResult) {\n            fftResult = new Float32Array(analyser.frequencyBinCount);\n            analyser.getFloatFrequencyData(fftResult);\n        }\n        const nyquistFrequency = sampleRate / 2;\n        const frequencyStep = 1 / fftResult.length * nyquistFrequency;\n        let outputValues;\n        let frequencies;\n        let labels;\n        if (analysisType === 'music' || analysisType === 'voice') {\n            const useFrequencies = analysisType === 'voice' ? (0, $03f71ce85e00ada6$export$dbc1581ed2cfa183) : (0, $03f71ce85e00ada6$export$776c63898ae5b636);\n            const aggregateOutput = Array(useFrequencies.length).fill(minDecibels);\n            for(let i = 0; i < fftResult.length; i++){\n                const frequency = i * frequencyStep;\n                const amplitude = fftResult[i];\n                for(let n = useFrequencies.length - 1; n >= 0; n--)if (frequency > useFrequencies[n]) {\n                    aggregateOutput[n] = Math.max(aggregateOutput[n], amplitude);\n                    break;\n                }\n            }\n            outputValues = aggregateOutput;\n            frequencies = analysisType === 'voice' ? (0, $03f71ce85e00ada6$export$dbc1581ed2cfa183) : (0, $03f71ce85e00ada6$export$776c63898ae5b636);\n            labels = analysisType === 'voice' ? (0, $03f71ce85e00ada6$export$30a6f2881311088f) : (0, $03f71ce85e00ada6$export$facd167cc27ea9b0);\n        } else {\n            outputValues = Array.from(fftResult);\n            frequencies = outputValues.map((_, i)=>frequencyStep * i);\n            labels = frequencies.map((f)=>`${f.toFixed(2)} Hz`);\n        }\n        // We normalize to {0, 1}\n        const normalizedOutput = outputValues.map((v)=>{\n            return Math.max(0, Math.min((v - minDecibels) / (maxDecibels - minDecibels), 1));\n        });\n        const values = new Float32Array(normalizedOutput);\n        return {\n            values: values,\n            frequencies: frequencies,\n            labels: labels\n        };\n    }\n    /**\n   * Creates a new AudioAnalysis instance for an HTMLAudioElement\n   * @param {HTMLAudioElement} audioElement\n   * @param {AudioBuffer|null} [audioBuffer] If provided, will cache all frequency domain data from the buffer\n   * @returns {AudioAnalysis}\n   */ constructor(audioElement, audioBuffer = null){\n        this.fftResults = [];\n        if (audioBuffer) {\n            /**\n       * Modified from\n       * https://stackoverflow.com/questions/75063715/using-the-web-audio-api-to-analyze-a-song-without-playing\n       *\n       * We do this to populate FFT values for the audio if provided an `audioBuffer`\n       * The reason to do this is that Safari fails when using `createMediaElementSource`\n       * This has a non-zero RAM cost so we only opt-in to run it on Safari, Chrome is better\n       */ const { length: length, sampleRate: sampleRate } = audioBuffer;\n            const offlineAudioContext = new OfflineAudioContext({\n                length: length,\n                sampleRate: sampleRate\n            });\n            const source = offlineAudioContext.createBufferSource();\n            source.buffer = audioBuffer;\n            const analyser = offlineAudioContext.createAnalyser();\n            analyser.fftSize = 8192;\n            analyser.smoothingTimeConstant = 0.1;\n            source.connect(analyser);\n            // limit is :: 128 / sampleRate;\n            // but we just want 60fps - cuts ~1s from 6MB to 1MB of RAM\n            const renderQuantumInSeconds = 1 / 60;\n            const durationInSeconds = length / sampleRate;\n            const analyze = (index)=>{\n                const suspendTime = renderQuantumInSeconds * index;\n                if (suspendTime < durationInSeconds) offlineAudioContext.suspend(suspendTime).then(()=>{\n                    const fftResult = new Float32Array(analyser.frequencyBinCount);\n                    analyser.getFloatFrequencyData(fftResult);\n                    this.fftResults.push(fftResult);\n                    analyze(index + 1);\n                });\n                if (index === 1) offlineAudioContext.startRendering();\n                else offlineAudioContext.resume();\n            };\n            source.start(0);\n            analyze(1);\n            this.audio = audioElement;\n            this.context = offlineAudioContext;\n            this.analyser = analyser;\n            this.sampleRate = sampleRate;\n            this.audioBuffer = audioBuffer;\n        } else {\n            const audioContext = new AudioContext();\n            const track = audioContext.createMediaElementSource(audioElement);\n            const analyser = audioContext.createAnalyser();\n            analyser.fftSize = 8192;\n            analyser.smoothingTimeConstant = 0.1;\n            track.connect(analyser);\n            analyser.connect(audioContext.destination);\n            this.audio = audioElement;\n            this.context = audioContext;\n            this.analyser = analyser;\n            this.sampleRate = this.context.sampleRate;\n            this.audioBuffer = null;\n        }\n    }\n    /**\n   * Gets the current frequency domain data from the playing audio track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {AudioAnalysisOutputType}\n   */ getFrequencies(analysisType = 'frequency', minDecibels = -100, maxDecibels = -30) {\n        let fftResult = null;\n        if (this.audioBuffer && this.fftResults.length) {\n            const pct = this.audio.currentTime / this.audio.duration;\n            const index = Math.min(pct * this.fftResults.length | 0, this.fftResults.length - 1);\n            fftResult = this.fftResults[index];\n        }\n        return $f32f064564ee62f6$export$2c3136da0bf130f9.getFrequencies(this.analyser, this.sampleRate, fftResult, analysisType, minDecibels, maxDecibels);\n    }\n    /**\n   * Resume the internal AudioContext if it was suspended due to the lack of\n   * user interaction when the AudioAnalysis was instantiated.\n   * @returns {Promise<true>}\n   */ async resumeIfSuspended() {\n        if (this.context.state === 'suspended') await this.context.resume();\n        return true;\n    }\n}\nglobalThis.AudioAnalysis = $f32f064564ee62f6$export$2c3136da0bf130f9;\n\n\nconst $29a8a70a9466b14f$export$50b76700e2b15e9 = `\nclass StreamProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.hasStarted = false;\n    this.hasInterrupted = false;\n    this.outputBuffers = [];\n    this.bufferLength = 128;\n    this.write = { buffer: new Float32Array(this.bufferLength), trackId: null };\n    this.writeOffset = 0;\n    this.trackSampleOffsets = {};\n    this.port.onmessage = (event) => {\n      if (event.data) {\n        const payload = event.data;\n        if (payload.event === 'write') {\n          const int16Array = payload.buffer;\n          const float32Array = new Float32Array(int16Array.length);\n          for (let i = 0; i < int16Array.length; i++) {\n            float32Array[i] = int16Array[i] / 0x8000; // Convert Int16 to Float32\n          }\n          this.writeData(float32Array, payload.trackId);\n        } else if (\n          payload.event === 'offset' ||\n          payload.event === 'interrupt'\n        ) {\n          const requestId = payload.requestId;\n          const trackId = this.write.trackId;\n          const offset = this.trackSampleOffsets[trackId] || 0;\n          this.port.postMessage({\n            event: 'offset',\n            requestId,\n            trackId,\n            offset,\n          });\n          if (payload.event === 'interrupt') {\n            this.hasInterrupted = true;\n          }\n        } else {\n          throw new Error(\\`Unhandled event \"\\${payload.event}\"\\`);\n        }\n      }\n    };\n  }\n\n  writeData(float32Array, trackId = null) {\n    let { buffer } = this.write;\n    let offset = this.writeOffset;\n    for (let i = 0; i < float32Array.length; i++) {\n      buffer[offset++] = float32Array[i];\n      if (offset >= buffer.length) {\n        this.outputBuffers.push(this.write);\n        this.write = { buffer: new Float32Array(this.bufferLength), trackId };\n        buffer = this.write.buffer;\n        offset = 0;\n      }\n    }\n    this.writeOffset = offset;\n    return true;\n  }\n\n  process(inputs, outputs, parameters) {\n    const output = outputs[0];\n    const outputChannelData = output[0];\n    const outputBuffers = this.outputBuffers;\n    if (this.hasInterrupted) {\n      this.port.postMessage({ event: 'stop' });\n      return false;\n    } else if (outputBuffers.length) {\n      this.hasStarted = true;\n      const { buffer, trackId } = outputBuffers.shift();\n      for (let i = 0; i < outputChannelData.length; i++) {\n        outputChannelData[i] = buffer[i] || 0;\n      }\n      if (trackId) {\n        this.trackSampleOffsets[trackId] =\n          this.trackSampleOffsets[trackId] || 0;\n        this.trackSampleOffsets[trackId] += buffer.length;\n      }\n      return true;\n    } else if (this.hasStarted) {\n      this.port.postMessage({ event: 'stop' });\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n\nregisterProcessor('stream_processor', StreamProcessor);\n`;\nconst $29a8a70a9466b14f$var$script = new Blob([\n    $29a8a70a9466b14f$export$50b76700e2b15e9\n], {\n    type: 'application/javascript'\n});\nconst $29a8a70a9466b14f$var$src = URL.createObjectURL($29a8a70a9466b14f$var$script);\nconst $29a8a70a9466b14f$export$bfa8c596114d74df = $29a8a70a9466b14f$var$src;\n\n\n\nclass $d0a969833958d9e7$export$9698d62c78b8f366 {\n    /**\n   * Creates a new WavStreamPlayer instance\n   * @param {{sampleRate?: number}} options\n   * @returns {WavStreamPlayer}\n   */ constructor({ sampleRate: sampleRate = 44100 } = {}){\n        this.scriptSrc = (0, $29a8a70a9466b14f$export$bfa8c596114d74df);\n        this.sampleRate = sampleRate;\n        this.context = null;\n        this.stream = null;\n        this.analyser = null;\n        this.trackSampleOffsets = {};\n        this.interruptedTrackIds = {};\n    }\n    /**\n   * Connects the audio context and enables output to speakers\n   * @returns {Promise<true>}\n   */ async connect() {\n        this.context = new AudioContext({\n            sampleRate: this.sampleRate\n        });\n        if (this._speakerID) this.context.setSinkId(this._speakerID);\n        if (this.context.state === \"suspended\") await this.context.resume();\n        try {\n            await this.context.audioWorklet.addModule(this.scriptSrc);\n        } catch (e) {\n            console.error(e);\n            throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);\n        }\n        const analyser = this.context.createAnalyser();\n        analyser.fftSize = 8192;\n        analyser.smoothingTimeConstant = 0.1;\n        this.analyser = analyser;\n        return true;\n    }\n    /**\n   * Gets the current frequency domain data from the playing track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}\n   */ getFrequencies(analysisType = \"frequency\", minDecibels = -100, maxDecibels = -30) {\n        if (!this.analyser) throw new Error(\"Not connected, please call .connect() first\");\n        return (0, $f32f064564ee62f6$export$2c3136da0bf130f9).getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);\n    }\n    /**\n   * @param {string} speaker deviceId\n   */ async updateSpeaker(speaker) {\n        const _prevSpeaker = this._speakerID;\n        this._speakerID = speaker;\n        if (this.context) try {\n            if (speaker === \"default\") await this.context.setSinkId();\n            else await this.context.setSinkId(speaker);\n        } catch (e) {\n            console.error(`Could not set sinkId to ${speaker}: ${e}`);\n            this._speakerID = _prevSpeaker;\n        }\n    }\n    /**\n   * Starts audio streaming\n   * @private\n   * @returns {Promise<true>}\n   */ _start() {\n        const streamNode = new AudioWorkletNode(this.context, \"stream_processor\");\n        streamNode.connect(this.context.destination);\n        streamNode.port.onmessage = (e)=>{\n            const { event: event } = e.data;\n            if (event === \"stop\") {\n                streamNode.disconnect();\n                this.stream = null;\n            } else if (event === \"offset\") {\n                const { requestId: requestId, trackId: trackId, offset: offset } = e.data;\n                const currentTime = offset / this.sampleRate;\n                this.trackSampleOffsets[requestId] = {\n                    trackId: trackId,\n                    offset: offset,\n                    currentTime: currentTime\n                };\n            }\n        };\n        this.analyser.disconnect();\n        streamNode.connect(this.analyser);\n        this.stream = streamNode;\n        return true;\n    }\n    /**\n   * Adds 16BitPCM data to the currently playing audio stream\n   * You can add chunks beyond the current play point and they will be queued for play\n   * @param {ArrayBuffer|Int16Array} arrayBuffer\n   * @param {string} [trackId]\n   * @returns {Int16Array}\n   */ add16BitPCM(arrayBuffer, trackId = \"default\") {\n        if (typeof trackId !== \"string\") throw new Error(`trackId must be a string`);\n        else if (this.interruptedTrackIds[trackId]) return;\n        if (!this.stream) this._start();\n        let buffer;\n        if (arrayBuffer instanceof Int16Array) buffer = arrayBuffer;\n        else if (arrayBuffer instanceof ArrayBuffer) buffer = new Int16Array(arrayBuffer);\n        else throw new Error(`argument must be Int16Array or ArrayBuffer`);\n        this.stream.port.postMessage({\n            event: \"write\",\n            buffer: buffer,\n            trackId: trackId\n        });\n        return buffer;\n    }\n    /**\n   * Gets the offset (sample count) of the currently playing stream\n   * @param {boolean} [interrupt]\n   * @returns {{trackId: string|null, offset: number, currentTime: number}}\n   */ async getTrackSampleOffset(interrupt = false) {\n        if (!this.stream) return null;\n        const requestId = crypto.randomUUID();\n        this.stream.port.postMessage({\n            event: interrupt ? \"interrupt\" : \"offset\",\n            requestId: requestId\n        });\n        let trackSampleOffset;\n        while(!trackSampleOffset){\n            trackSampleOffset = this.trackSampleOffsets[requestId];\n            await new Promise((r)=>setTimeout(()=>r(), 1));\n        }\n        const { trackId: trackId } = trackSampleOffset;\n        if (interrupt && trackId) this.interruptedTrackIds[trackId] = true;\n        return trackSampleOffset;\n    }\n    /**\n   * Strips the current stream and returns the sample offset of the audio\n   * @param {boolean} [interrupt]\n   * @returns {{trackId: string|null, offset: number, currentTime: number}}\n   */ async interrupt() {\n        return this.getTrackSampleOffset(true);\n    }\n}\nglobalThis.WavStreamPlayer = $d0a969833958d9e7$export$9698d62c78b8f366;\n\n\nconst $8e1d1e6ff08f6fb5$var$AudioProcessorWorklet = `\nclass AudioProcessor extends AudioWorkletProcessor {\n\n  constructor() {\n    super();\n    this.port.onmessage = this.receive.bind(this);\n    this.initialize();\n  }\n\n  initialize() {\n    this.foundAudio = false;\n    this.recording = false;\n    this.chunks = [];\n  }\n\n  /**\n   * Concatenates sampled chunks into channels\n   * Format is chunk[Left[], Right[]]\n   */\n  readChannelData(chunks, channel = -1, maxChannels = 9) {\n    let channelLimit;\n    if (channel !== -1) {\n      if (chunks[0] && chunks[0].length - 1 < channel) {\n        throw new Error(\n          \\`Channel \\${channel} out of range: max \\${chunks[0].length}\\`\n        );\n      }\n      channelLimit = channel + 1;\n    } else {\n      channel = 0;\n      channelLimit = Math.min(chunks[0] ? chunks[0].length : 1, maxChannels);\n    }\n    const channels = [];\n    for (let n = channel; n < channelLimit; n++) {\n      const length = chunks.reduce((sum, chunk) => {\n        return sum + chunk[n].length;\n      }, 0);\n      const buffers = chunks.map((chunk) => chunk[n]);\n      const result = new Float32Array(length);\n      let offset = 0;\n      for (let i = 0; i < buffers.length; i++) {\n        result.set(buffers[i], offset);\n        offset += buffers[i].length;\n      }\n      channels[n] = result;\n    }\n    return channels;\n  }\n\n  /**\n   * Combines parallel audio data into correct format,\n   * channels[Left[], Right[]] to float32Array[LRLRLRLR...]\n   */\n  formatAudioData(channels) {\n    if (channels.length === 1) {\n      // Simple case is only one channel\n      const float32Array = channels[0].slice();\n      const meanValues = channels[0].slice();\n      return { float32Array, meanValues };\n    } else {\n      const float32Array = new Float32Array(\n        channels[0].length * channels.length\n      );\n      const meanValues = new Float32Array(channels[0].length);\n      for (let i = 0; i < channels[0].length; i++) {\n        const offset = i * channels.length;\n        let meanValue = 0;\n        for (let n = 0; n < channels.length; n++) {\n          float32Array[offset + n] = channels[n][i];\n          meanValue += channels[n][i];\n        }\n        meanValues[i] = meanValue / channels.length;\n      }\n      return { float32Array, meanValues };\n    }\n  }\n\n  /**\n   * Converts 32-bit float data to 16-bit integers\n   */\n  floatTo16BitPCM(float32Array) {\n    const buffer = new ArrayBuffer(float32Array.length * 2);\n    const view = new DataView(buffer);\n    let offset = 0;\n    for (let i = 0; i < float32Array.length; i++, offset += 2) {\n      let s = Math.max(-1, Math.min(1, float32Array[i]));\n      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n    }\n    return buffer;\n  }\n\n  /**\n   * Retrieves the most recent amplitude values from the audio stream\n   * @param {number} channel\n   */\n  getValues(channel = -1) {\n    const channels = this.readChannelData(this.chunks, channel);\n    const { meanValues } = this.formatAudioData(channels);\n    return { meanValues, channels };\n  }\n\n  /**\n   * Exports chunks as an audio/wav file\n   */\n  export() {\n    const channels = this.readChannelData(this.chunks);\n    const { float32Array, meanValues } = this.formatAudioData(channels);\n    const audioData = this.floatTo16BitPCM(float32Array);\n    return {\n      meanValues: meanValues,\n      audio: {\n        bitsPerSample: 16,\n        channels: channels,\n        data: audioData,\n      },\n    };\n  }\n\n  receive(e) {\n    const { event, id } = e.data;\n    let receiptData = {};\n    switch (event) {\n      case 'start':\n        this.recording = true;\n        break;\n      case 'stop':\n        this.recording = false;\n        break;\n      case 'clear':\n        this.initialize();\n        break;\n      case 'export':\n        receiptData = this.export();\n        break;\n      case 'read':\n        receiptData = this.getValues();\n        break;\n      default:\n        break;\n    }\n    // Always send back receipt\n    this.port.postMessage({ event: 'receipt', id, data: receiptData });\n  }\n\n  sendChunk(chunk) {\n    const channels = this.readChannelData([chunk]);\n    const { float32Array, meanValues } = this.formatAudioData(channels);\n    const rawAudioData = this.floatTo16BitPCM(float32Array);\n    const monoAudioData = this.floatTo16BitPCM(meanValues);\n    this.port.postMessage({\n      event: 'chunk',\n      data: {\n        mono: monoAudioData,\n        raw: rawAudioData,\n      },\n    });\n  }\n\n  process(inputList, outputList, parameters) {\n    // Copy input to output (e.g. speakers)\n    // Note that this creates choppy sounds with Mac products\n    const sourceLimit = Math.min(inputList.length, outputList.length);\n    for (let inputNum = 0; inputNum < sourceLimit; inputNum++) {\n      const input = inputList[inputNum];\n      const output = outputList[inputNum];\n      const channelCount = Math.min(input.length, output.length);\n      for (let channelNum = 0; channelNum < channelCount; channelNum++) {\n        input[channelNum].forEach((sample, i) => {\n          output[channelNum][i] = sample;\n        });\n      }\n    }\n    const inputs = inputList[0];\n    // There's latency at the beginning of a stream before recording starts\n    // Make sure we actually receive audio data before we start storing chunks\n    let sliceIndex = 0;\n    if (!this.foundAudio) {\n      for (const channel of inputs) {\n        sliceIndex = 0; // reset for each channel\n        if (this.foundAudio) {\n          break;\n        }\n        if (channel) {\n          for (const value of channel) {\n            if (value !== 0) {\n              // find only one non-zero entry in any channel\n              this.foundAudio = true;\n              break;\n            } else {\n              sliceIndex++;\n            }\n          }\n        }\n      }\n    }\n    if (inputs && inputs[0] && this.foundAudio && this.recording) {\n      // We need to copy the TypedArray, because the \\`process\\`\n      // internals will reuse the same buffer to hold each input\n      const chunk = inputs.map((input) => input.slice(sliceIndex));\n      this.chunks.push(chunk);\n      this.sendChunk(chunk);\n    }\n    return true;\n  }\n}\n\nregisterProcessor('audio_processor', AudioProcessor);\n`;\nconst $8e1d1e6ff08f6fb5$var$script = new Blob([\n    $8e1d1e6ff08f6fb5$var$AudioProcessorWorklet\n], {\n    type: 'application/javascript'\n});\nconst $8e1d1e6ff08f6fb5$var$src = URL.createObjectURL($8e1d1e6ff08f6fb5$var$script);\nconst $8e1d1e6ff08f6fb5$export$1f65f50a8cbff43c = $8e1d1e6ff08f6fb5$var$src;\n\n\n\n\nclass $62bc376044a05513$export$439b217ca659a877 {\n    /**\n   * Create a new WavRecorder instance\n   * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]\n   * @returns {WavRecorder}\n   */ constructor({ sampleRate: sampleRate = 44100, outputToSpeakers: outputToSpeakers = false, debug: debug = false } = {}){\n        // Script source\n        this.scriptSrc = (0, $8e1d1e6ff08f6fb5$export$1f65f50a8cbff43c);\n        // Config\n        this.sampleRate = sampleRate;\n        this.outputToSpeakers = outputToSpeakers;\n        this.debug = !!debug;\n        this._deviceChangeCallback = null;\n        this._devices = [];\n        this.deviceSelection = null;\n        // State variables\n        this.stream = null;\n        this.processor = null;\n        this.source = null;\n        this.node = null;\n        this.recording = false;\n        // Event handling with AudioWorklet\n        this._lastEventId = 0;\n        this.eventReceipts = {};\n        this.eventTimeout = 5000;\n        // Process chunks of audio\n        this._chunkProcessor = ()=>{};\n        this._chunkProcessorSize = void 0;\n        this._chunkProcessorBuffer = {\n            raw: new ArrayBuffer(0),\n            mono: new ArrayBuffer(0)\n        };\n    }\n    /**\n   * Decodes audio data from multiple formats to a Blob, url, Float32Array and AudioBuffer\n   * @param {Blob|Float32Array|Int16Array|ArrayBuffer|number[]} audioData\n   * @param {number} sampleRate\n   * @param {number} fromSampleRate\n   * @returns {Promise<DecodedAudioType>}\n   */ static async decode(audioData, sampleRate = 44100, fromSampleRate = -1) {\n        const context = new AudioContext({\n            sampleRate: sampleRate\n        });\n        let arrayBuffer;\n        let blob;\n        if (audioData instanceof Blob) {\n            if (fromSampleRate !== -1) throw new Error(`Can not specify \"fromSampleRate\" when reading from Blob`);\n            blob = audioData;\n            arrayBuffer = await blob.arrayBuffer();\n        } else if (audioData instanceof ArrayBuffer) {\n            if (fromSampleRate !== -1) throw new Error(`Can not specify \"fromSampleRate\" when reading from ArrayBuffer`);\n            arrayBuffer = audioData;\n            blob = new Blob([\n                arrayBuffer\n            ], {\n                type: 'audio/wav'\n            });\n        } else {\n            let float32Array;\n            let data;\n            if (audioData instanceof Int16Array) {\n                data = audioData;\n                float32Array = new Float32Array(audioData.length);\n                for(let i = 0; i < audioData.length; i++)float32Array[i] = audioData[i] / 0x8000;\n            } else if (audioData instanceof Float32Array) float32Array = audioData;\n            else if (audioData instanceof Array) float32Array = new Float32Array(audioData);\n            else throw new Error(`\"audioData\" must be one of: Blob, Float32Arrray, Int16Array, ArrayBuffer, Array<number>`);\n            if (fromSampleRate === -1) throw new Error(`Must specify \"fromSampleRate\" when reading from Float32Array, In16Array or Array`);\n            else if (fromSampleRate < 3000) throw new Error(`Minimum \"fromSampleRate\" is 3000 (3kHz)`);\n            if (!data) data = (0, $6d4b7449a1e1544a$export$13afda237b1c9846).floatTo16BitPCM(float32Array);\n            const audio = {\n                bitsPerSample: 16,\n                channels: [\n                    float32Array\n                ],\n                data: data\n            };\n            const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c9846)();\n            const result = packer.pack(fromSampleRate, audio);\n            blob = result.blob;\n            arrayBuffer = await blob.arrayBuffer();\n        }\n        const audioBuffer = await context.decodeAudioData(arrayBuffer);\n        const values = audioBuffer.getChannelData(0);\n        const url = URL.createObjectURL(blob);\n        return {\n            blob: blob,\n            url: url,\n            values: values,\n            audioBuffer: audioBuffer\n        };\n    }\n    /**\n   * Logs data in debug mode\n   * @param {...any} arguments\n   * @returns {true}\n   */ log() {\n        if (this.debug) this.log(...arguments);\n        return true;\n    }\n    /**\n   * Retrieves the current sampleRate for the recorder\n   * @returns {number}\n   */ getSampleRate() {\n        return this.sampleRate;\n    }\n    /**\n   * Retrieves the current status of the recording\n   * @returns {\"ended\"|\"paused\"|\"recording\"}\n   */ getStatus() {\n        if (!this.processor) return 'ended';\n        else if (!this.recording) return 'paused';\n        else return 'recording';\n    }\n    /**\n   * Sends an event to the AudioWorklet\n   * @private\n   * @param {string} name\n   * @param {{[key: string]: any}} data\n   * @param {AudioWorkletNode} [_processor]\n   * @returns {Promise<{[key: string]: any}>}\n   */ async _event(name, data = {}, _processor = null) {\n        _processor = _processor || this.processor;\n        if (!_processor) throw new Error('Can not send events without recording first');\n        const message = {\n            event: name,\n            id: this._lastEventId++,\n            data: data\n        };\n        _processor.port.postMessage(message);\n        const t0 = new Date().valueOf();\n        while(!this.eventReceipts[message.id]){\n            if (new Date().valueOf() - t0 > this.eventTimeout) throw new Error(`Timeout waiting for \"${name}\" event`);\n            await new Promise((res)=>setTimeout(()=>res(true), 1));\n        }\n        const payload = this.eventReceipts[message.id];\n        delete this.eventReceipts[message.id];\n        return payload;\n    }\n    /**\n   * Sets device change callback, remove if callback provided is `null`\n   * @param {(Array<MediaDeviceInfo & {default: boolean}>): void|null} callback\n   * @returns {true}\n   */ listenForDeviceChange(callback) {\n        if (callback === null && this._deviceChangeCallback) {\n            navigator.mediaDevices.removeEventListener('devicechange', this._deviceChangeCallback);\n            this._deviceChangeCallback = null;\n        } else if (callback !== null) {\n            // Basically a debounce; we only want this called once when devices change\n            // And we only want the most recent callback() to be executed\n            // if a few are operating at the same time\n            let lastId = 0;\n            let lastDevices = [];\n            const serializeDevices = (devices)=>devices.map((d)=>d.deviceId).sort().join(',');\n            const cb = async ()=>{\n                let id = ++lastId;\n                const devices = await this.listDevices();\n                if (id === lastId) {\n                    if (serializeDevices(lastDevices) !== serializeDevices(devices)) {\n                        lastDevices = devices;\n                        callback(devices.slice());\n                    }\n                }\n            };\n            navigator.mediaDevices.addEventListener('devicechange', cb);\n            cb();\n            this._deviceChangeCallback = cb;\n        }\n        return true;\n    }\n    /**\n   * Manually request permission to use the microphone\n   * @returns {Promise<true>}\n   */ async requestPermission() {\n        const permissionStatus = await navigator.permissions.query({\n            name: 'microphone'\n        });\n        if (permissionStatus.state === 'denied') window.alert('You must grant microphone access to use this feature.');\n        else if (permissionStatus.state === 'prompt') try {\n            const stream = await navigator.mediaDevices.getUserMedia({\n                audio: true\n            });\n            const tracks = stream.getTracks();\n            tracks.forEach((track)=>track.stop());\n        } catch (e) {\n            window.alert('You must grant microphone access to use this feature.');\n        }\n        return true;\n    }\n    /**\n   * List all eligible devices for recording, will request permission to use microphone\n   * @returns {Promise<Array<MediaDeviceInfo & {default: boolean}>>}\n   */ async listDevices() {\n        if (!navigator.mediaDevices || !('enumerateDevices' in navigator.mediaDevices)) throw new Error('Could not request user devices');\n        await this.requestPermission();\n        const devices = await navigator.mediaDevices.enumerateDevices();\n        const audioDevices = devices.filter((device)=>device.kind === 'audioinput');\n        return audioDevices;\n    // const defaultDeviceIndex = audioDevices.findIndex(\n    //   (device) => device.deviceId === 'default'\n    // );\n    // const deviceList = [];\n    // if (defaultDeviceIndex !== -1) {\n    //   let defaultDevice = audioDevices.splice(defaultDeviceIndex, 1)[0];\n    //   let existingIndex = audioDevices.findIndex(\n    //     (device) => device.groupId === defaultDevice.groupId\n    //   );\n    //   if (existingIndex !== -1) {\n    //     defaultDevice = audioDevices.splice(existingIndex, 1)[0];\n    //   }\n    //   defaultDevice.default = true;\n    //   deviceList.push(defaultDevice);\n    // }\n    // return deviceList.concat(audioDevices);\n    }\n    /**\n   * Begins a recording session and requests microphone permissions if not already granted\n   * Microphone recording indicator will appear on browser tab but status will be \"paused\"\n   * @param {string} [deviceId] if no device provided, default device will be used\n   * @returns {Promise<true>}\n   */ async begin(deviceId) {\n        if (this.processor) throw new Error(`Already connected: please call .end() to start a new session`);\n        if (!navigator.mediaDevices || !('getUserMedia' in navigator.mediaDevices)) throw new Error('Could not request user media');\n        deviceId = deviceId ?? this.deviceSelection?.deviceId;\n        try {\n            const config = {\n                audio: true\n            };\n            if (deviceId) config.audio = {\n                deviceId: {\n                    exact: deviceId\n                }\n            };\n            this.stream = await navigator.mediaDevices.getUserMedia(config);\n        } catch (err) {\n            throw new Error('Could not start media stream');\n        }\n        this.listDevices().then((devices)=>{\n            deviceId = this.stream.getAudioTracks()[0].getSettings().deviceId;\n            console.log('find current device', devices, deviceId, this.stream.getAudioTracks()[0].getSettings());\n            this.deviceSelection = devices.find((d)=>d.deviceId === deviceId);\n            console.log('current device', this.deviceSelection);\n        });\n        const context = new AudioContext({\n            sampleRate: this.sampleRate\n        });\n        const source = context.createMediaStreamSource(this.stream);\n        // Load and execute the module script.\n        try {\n            await context.audioWorklet.addModule(this.scriptSrc);\n        } catch (e) {\n            console.error(e);\n            throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);\n        }\n        const processor = new AudioWorkletNode(context, 'audio_processor');\n        processor.port.onmessage = (e)=>{\n            const { event: event, id: id, data: data } = e.data;\n            if (event === 'receipt') this.eventReceipts[id] = data;\n            else if (event === 'chunk') {\n                if (this._chunkProcessorSize) {\n                    const buffer = this._chunkProcessorBuffer;\n                    this._chunkProcessorBuffer = {\n                        raw: (0, $6d4b7449a1e1544a$export$13afda237b1c9846).mergeBuffers(buffer.raw, data.raw),\n                        mono: (0, $6d4b7449a1e1544a$export$13afda237b1c9846).mergeBuffers(buffer.mono, data.mono)\n                    };\n                    if (this._chunkProcessorBuffer.mono.byteLength >= this._chunkProcessorSize) {\n                        this._chunkProcessor(this._chunkProcessorBuffer);\n                        this._chunkProcessorBuffer = {\n                            raw: new ArrayBuffer(0),\n                            mono: new ArrayBuffer(0)\n                        };\n                    }\n                } else this._chunkProcessor(data);\n            }\n        };\n        const node = source.connect(processor);\n        const analyser = context.createAnalyser();\n        analyser.fftSize = 8192;\n        analyser.smoothingTimeConstant = 0.1;\n        node.connect(analyser);\n        if (this.outputToSpeakers) {\n            // eslint-disable-next-line no-console\n            console.warn(\"Warning: Output to speakers may affect sound quality,\\nespecially due to system audio feedback preventative measures.\\nuse only for debugging\");\n            analyser.connect(context.destination);\n        }\n        this.source = source;\n        this.node = node;\n        this.analyser = analyser;\n        this.processor = processor;\n        console.log('begin completed');\n        return true;\n    }\n    /**\n   * Gets the current frequency domain data from the recording track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}\n   */ getFrequencies(analysisType = 'frequency', minDecibels = -100, maxDecibels = -30) {\n        if (!this.processor) throw new Error('Session ended: please call .begin() first');\n        return (0, $f32f064564ee62f6$export$2c3136da0bf130f9).getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);\n    }\n    /**\n   * Pauses the recording\n   * Keeps microphone stream open but halts storage of audio\n   * @returns {Promise<true>}\n   */ async pause() {\n        if (!this.processor) throw new Error('Session ended: please call .begin() first');\n        else if (!this.recording) throw new Error('Already paused: please call .record() first');\n        if (this._chunkProcessorBuffer.raw.byteLength) this._chunkProcessor(this._chunkProcessorBuffer);\n        this.log('Pausing ...');\n        await this._event('stop');\n        this.recording = false;\n        return true;\n    }\n    /**\n   * Start recording stream and storing to memory from the connected audio source\n   * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]\n   * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio\n   * @returns {Promise<true>}\n   */ async record(chunkProcessor = ()=>{}, chunkSize = 8192) {\n        if (!this.processor) throw new Error('Session ended: please call .begin() first');\n        else if (this.recording) throw new Error('Already recording: please call .pause() first');\n        else if (typeof chunkProcessor !== 'function') throw new Error(`chunkProcessor must be a function`);\n        this._chunkProcessor = chunkProcessor;\n        this._chunkProcessorSize = chunkSize;\n        this._chunkProcessorBuffer = {\n            raw: new ArrayBuffer(0),\n            mono: new ArrayBuffer(0)\n        };\n        this.log('Recording ...');\n        await this._event('start');\n        this.recording = true;\n        return true;\n    }\n    /**\n   * Clears the audio buffer, empties stored recording\n   * @returns {Promise<true>}\n   */ async clear() {\n        if (!this.processor) throw new Error('Session ended: please call .begin() first');\n        await this._event('clear');\n        return true;\n    }\n    /**\n   * Reads the current audio stream data\n   * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}\n   */ async read() {\n        if (!this.processor) throw new Error('Session ended: please call .begin() first');\n        this.log('Reading ...');\n        const result = await this._event('read');\n        return result;\n    }\n    /**\n   * Saves the current audio stream to a file\n   * @param {boolean} [force] Force saving while still recording\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */ async save(force = false) {\n        if (!this.processor) throw new Error('Session ended: please call .begin() first');\n        if (!force && this.recording) throw new Error('Currently recording: please call .pause() first, or call .save(true) to force');\n        this.log('Exporting ...');\n        const exportData = await this._event('export');\n        const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c9846)();\n        const result = packer.pack(this.sampleRate, exportData.audio);\n        return result;\n    }\n    /**\n   * Ends the current recording session and saves the result\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */ async end() {\n        if (!this.processor) throw new Error('Session ended: please call .begin() first');\n        const _processor = this.processor;\n        this.log('Stopping ...');\n        await this._event('stop');\n        this.recording = false;\n        const tracks = this.stream.getTracks();\n        tracks.forEach((track)=>track.stop());\n        this.log('Exporting ...');\n        const exportData = await this._event('export', {}, _processor);\n        this.processor.disconnect();\n        this.source.disconnect();\n        this.node.disconnect();\n        this.analyser.disconnect();\n        this.stream = null;\n        this.processor = null;\n        this.source = null;\n        this.node = null;\n        const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c9846)();\n        const result = packer.pack(this.sampleRate, exportData.audio);\n        return result;\n    }\n    /**\n   * Performs a full cleanup of WavRecorder instance\n   * Stops actively listening via microphone and removes existing listeners\n   * @returns {Promise<true>}\n   */ async quit() {\n        this.listenForDeviceChange(null);\n        // we do not reset this on end so that selections persist across starts\n        this.deviceSelection = null;\n        if (this.processor) await this.end();\n        return true;\n    }\n}\nglobalThis.WavRecorder = $62bc376044a05513$export$439b217ca659a877;\n\n\n\n\n\nclass $5fc11d7bc0d20724$export$2934cf2d25c67a48 {\n    /**\n   * Create a new MediaStreamRecorder instance\n   * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]\n   * @returns {MediaStreamRecorder}\n   */ constructor({ sampleRate: sampleRate = 44100, outputToSpeakers: outputToSpeakers = false, debug: debug = false } = {}){\n        // Script source\n        this.scriptSrc = (0, $8e1d1e6ff08f6fb5$export$1f65f50a8cbff43c);\n        // Config\n        this.sampleRate = sampleRate;\n        this.outputToSpeakers = outputToSpeakers;\n        this.debug = !!debug;\n        // State variables\n        this.stream = null;\n        this.processor = null;\n        this.source = null;\n        this.node = null;\n        this.recording = false;\n        // Event handling with AudioWorklet\n        this._lastEventId = 0;\n        this.eventReceipts = {};\n        this.eventTimeout = 5000;\n        // Process chunks of audio\n        this._chunkProcessor = ()=>{};\n        this._chunkProcessorSize = void 0;\n        this._chunkProcessorBuffer = {\n            raw: new ArrayBuffer(0),\n            mono: new ArrayBuffer(0)\n        };\n    }\n    /**\n   * Logs data in debug mode\n   * @param {...any} arguments\n   * @returns {true}\n   */ log() {\n        if (this.debug) this.log(...arguments);\n        return true;\n    }\n    /**\n   * Retrieves the current sampleRate for the recorder\n   * @returns {number}\n   */ getSampleRate() {\n        return this.sampleRate;\n    }\n    /**\n   * Retrieves the current status of the recording\n   * @returns {\"ended\"|\"paused\"|\"recording\"}\n   */ getStatus() {\n        if (!this.processor) return \"ended\";\n        else if (!this.recording) return \"paused\";\n        else return \"recording\";\n    }\n    /**\n   * Sends an event to the AudioWorklet\n   * @private\n   * @param {string} name\n   * @param {{[key: string]: any}} data\n   * @param {AudioWorkletNode} [_processor]\n   * @returns {Promise<{[key: string]: any}>}\n   */ async _event(name, data = {}, _processor = null) {\n        _processor = _processor || this.processor;\n        if (!_processor) throw new Error(\"Can not send events without recording first\");\n        const message = {\n            event: name,\n            id: this._lastEventId++,\n            data: data\n        };\n        _processor.port.postMessage(message);\n        const t0 = new Date().valueOf();\n        while(!this.eventReceipts[message.id]){\n            if (new Date().valueOf() - t0 > this.eventTimeout) throw new Error(`Timeout waiting for \"${name}\" event`);\n            await new Promise((res)=>setTimeout(()=>res(true), 1));\n        }\n        const payload = this.eventReceipts[message.id];\n        delete this.eventReceipts[message.id];\n        return payload;\n    }\n    /**\n   * Begins a recording session for the given audioTrack\n   * Microphone recording indicator will appear on browser tab but status will be \"paused\"\n   * @param {MediaStreamTrack} [audioTrack] if no device provided, default device will be used\n   * @returns {Promise<true>}\n   */ async begin(audioTrack) {\n        if (this.processor) throw new Error(`Already connected: please call .end() to start a new session`);\n        if (!audioTrack || audioTrack.kind !== \"audio\") throw new Error(\"No audio track provided\");\n        this.stream = new MediaStream([\n            audioTrack\n        ]);\n        const context = new AudioContext({\n            sampleRate: this.sampleRate\n        });\n        const source = context.createMediaStreamSource(this.stream);\n        // Load and execute the module script.\n        try {\n            await context.audioWorklet.addModule(this.scriptSrc);\n        } catch (e) {\n            console.error(e);\n            throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);\n        }\n        const processor = new AudioWorkletNode(context, \"audio_processor\");\n        processor.port.onmessage = (e)=>{\n            const { event: event, id: id, data: data } = e.data;\n            if (event === \"receipt\") this.eventReceipts[id] = data;\n            else if (event === \"chunk\") {\n                if (this._chunkProcessorSize) {\n                    const buffer = this._chunkProcessorBuffer;\n                    this._chunkProcessorBuffer = {\n                        raw: (0, $6d4b7449a1e1544a$export$13afda237b1c9846).mergeBuffers(buffer.raw, data.raw),\n                        mono: (0, $6d4b7449a1e1544a$export$13afda237b1c9846).mergeBuffers(buffer.mono, data.mono)\n                    };\n                    if (this._chunkProcessorBuffer.mono.byteLength >= this._chunkProcessorSize) {\n                        this._chunkProcessor(this._chunkProcessorBuffer);\n                        this._chunkProcessorBuffer = {\n                            raw: new ArrayBuffer(0),\n                            mono: new ArrayBuffer(0)\n                        };\n                    }\n                } else this._chunkProcessor(data);\n            }\n        };\n        const node = source.connect(processor);\n        const analyser = context.createAnalyser();\n        analyser.fftSize = 8192;\n        analyser.smoothingTimeConstant = 0.1;\n        node.connect(analyser);\n        if (this.outputToSpeakers) {\n            // eslint-disable-next-line no-console\n            console.warn(\"Warning: Output to speakers may affect sound quality,\\nespecially due to system audio feedback preventative measures.\\nuse only for debugging\");\n            analyser.connect(context.destination);\n        }\n        this.source = source;\n        this.node = node;\n        this.analyser = analyser;\n        this.processor = processor;\n        return true;\n    }\n    /**\n   * Gets the current frequency domain data from the recording track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}\n   */ getFrequencies(analysisType = \"frequency\", minDecibels = -100, maxDecibels = -30) {\n        if (!this.processor) throw new Error(\"Session ended: please call .begin() first\");\n        return (0, $f32f064564ee62f6$export$2c3136da0bf130f9).getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);\n    }\n    /**\n   * Pauses the recording\n   * Keeps microphone stream open but halts storage of audio\n   * @returns {Promise<true>}\n   */ async pause() {\n        if (!this.processor) throw new Error(\"Session ended: please call .begin() first\");\n        else if (!this.recording) throw new Error(\"Already paused: please call .record() first\");\n        if (this._chunkProcessorBuffer.raw.byteLength) this._chunkProcessor(this._chunkProcessorBuffer);\n        this.log(\"Pausing ...\");\n        await this._event(\"stop\");\n        this.recording = false;\n        return true;\n    }\n    /**\n   * Start recording stream and storing to memory from the connected audio source\n   * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]\n   * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio\n   * @returns {Promise<true>}\n   */ async record(chunkProcessor = ()=>{}, chunkSize = 8192) {\n        if (!this.processor) throw new Error(\"Session ended: please call .begin() first\");\n        else if (this.recording) throw new Error(\"Already recording: HELLO please call .pause() first\");\n        else if (typeof chunkProcessor !== \"function\") throw new Error(`chunkProcessor must be a function`);\n        this._chunkProcessor = chunkProcessor;\n        this._chunkProcessorSize = chunkSize;\n        this._chunkProcessorBuffer = {\n            raw: new ArrayBuffer(0),\n            mono: new ArrayBuffer(0)\n        };\n        this.log(\"Recording ...\");\n        await this._event(\"start\");\n        this.recording = true;\n        return true;\n    }\n    /**\n   * Clears the audio buffer, empties stored recording\n   * @returns {Promise<true>}\n   */ async clear() {\n        if (!this.processor) throw new Error(\"Session ended: please call .begin() first\");\n        await this._event(\"clear\");\n        return true;\n    }\n    /**\n   * Reads the current audio stream data\n   * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}\n   */ async read() {\n        if (!this.processor) throw new Error(\"Session ended: please call .begin() first\");\n        this.log(\"Reading ...\");\n        const result = await this._event(\"read\");\n        return result;\n    }\n    /**\n   * Saves the current audio stream to a file\n   * @param {boolean} [force] Force saving while still recording\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */ async save(force = false) {\n        if (!this.processor) throw new Error(\"Session ended: please call .begin() first\");\n        if (!force && this.recording) throw new Error(\"Currently recording: please call .pause() first, or call .save(true) to force\");\n        this.log(\"Exporting ...\");\n        const exportData = await this._event(\"export\");\n        const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c9846)();\n        const result = packer.pack(this.sampleRate, exportData.audio);\n        return result;\n    }\n    /**\n   * Ends the current recording session and saves the result\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */ async end() {\n        if (!this.processor) throw new Error(\"Session ended: please call .begin() first\");\n        const _processor = this.processor;\n        this.log(\"Stopping ...\");\n        await this._event(\"stop\");\n        this.recording = false;\n        this.log(\"Exporting ...\");\n        const exportData = await this._event(\"export\", {}, _processor);\n        this.processor.disconnect();\n        this.source.disconnect();\n        this.node.disconnect();\n        this.analyser.disconnect();\n        this.stream = null;\n        this.processor = null;\n        this.source = null;\n        this.node = null;\n        const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c9846)();\n        const result = packer.pack(this.sampleRate, exportData.audio);\n        return result;\n    }\n    /**\n   * Performs a full cleanup of WavRecorder instance\n   * Stops actively listening via microphone and removes existing listeners\n   * @returns {Promise<true>}\n   */ async quit() {\n        this.listenForDeviceChange(null);\n        if (this.processor) await this.end();\n        return true;\n    }\n}\nglobalThis.WavRecorder = WavRecorder;\n\n\n\n\nvar $fc49a56cd8739127$var$__extends =  false || function() {\n    var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf || ({\n            __proto__: []\n        }) instanceof Array && function(d, b) {\n            d.__proto__ = b;\n        } || function(d, b) {\n            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n        };\n        return extendStatics(d, b);\n    };\n    return function(d, b) {\n        if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nvar $fc49a56cd8739127$var$__awaiter =  false || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar $fc49a56cd8739127$var$__generator =  false || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nvar $fc49a56cd8739127$export$4a0c46dbbe2ddb67 = /** @class */ function() {\n    function MediaManager() {\n        this._callbacks = {};\n        this._micEnabled = true;\n        this._camEnabled = false;\n    }\n    MediaManager.prototype.setUserAudioCallback = function(userAudioCallback) {\n        this._userAudioCallback = userAudioCallback;\n    };\n    MediaManager.prototype.setRTVIOptions = function(options, override) {\n        var _a, _b, _c;\n        if (override === void 0) override = false;\n        if (this._options && !override) return;\n        this._options = options;\n        this._callbacks = (_a = options.callbacks) !== null && _a !== void 0 ? _a : {};\n        this._micEnabled = (_b = options.enableMic) !== null && _b !== void 0 ? _b : true;\n        this._camEnabled = (_c = options.enableCam) !== null && _c !== void 0 ? _c : false;\n    };\n    return MediaManager;\n}();\nvar $fc49a56cd8739127$export$45c5b9bfba2f6304 = /** @class */ function(_super) {\n    $fc49a56cd8739127$var$__extends(WavMediaManager, _super);\n    function WavMediaManager(recorderChunkSize, recorderSampleRate) {\n        if (recorderChunkSize === void 0) recorderChunkSize = undefined;\n        if (recorderSampleRate === void 0) recorderSampleRate = 24000;\n        var _this = _super.call(this) || this;\n        _this._initialized = false;\n        _this._recorderChunkSize = undefined;\n        _this._recorderChunkSize = recorderChunkSize;\n        _this._wavRecorder = new (0, $62bc376044a05513$export$439b217ca659a877)({\n            sampleRate: recorderSampleRate\n        });\n        _this._wavStreamPlayer = new (0, $d0a969833958d9e7$export$9698d62c78b8f366)({\n            sampleRate: 24000\n        });\n        return _this;\n    }\n    WavMediaManager.prototype.initialize = function() {\n        return $fc49a56cd8739127$var$__awaiter(this, void 0, Promise, function() {\n            return $fc49a56cd8739127$var$__generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this._wavRecorder.begin()\n                        ];\n                    case 1:\n                        _a.sent();\n                        this._wavRecorder.listenForDeviceChange(null);\n                        this._wavRecorder.listenForDeviceChange(this._handleAvailableDevicesUpdated.bind(this));\n                        return [\n                            4 /*yield*/ ,\n                            this._wavStreamPlayer.connect()\n                        ];\n                    case 2:\n                        _a.sent();\n                        this._initialized = true;\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    WavMediaManager.prototype.connect = function() {\n        return $fc49a56cd8739127$var$__awaiter(this, void 0, Promise, function() {\n            var isAlreadyRecording;\n            return $fc49a56cd8739127$var$__generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        if (!!this._initialized) return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            this.initialize()\n                        ];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        isAlreadyRecording = this._wavRecorder.getStatus() == \"recording\";\n                        if (!(this._micEnabled && !isAlreadyRecording)) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            this._startRecording()\n                        ];\n                    case 3:\n                        _a.sent();\n                        _a.label = 4;\n                    case 4:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    WavMediaManager.prototype.disconnect = function() {\n        return $fc49a56cd8739127$var$__awaiter(this, void 0, Promise, function() {\n            return $fc49a56cd8739127$var$__generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        if (!this._initialized) return [\n                            2 /*return*/ \n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            this._wavRecorder.end()\n                        ];\n                    case 1:\n                        _a.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this._wavStreamPlayer.interrupt()\n                        ];\n                    case 2:\n                        _a.sent();\n                        this._initialized = false;\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    WavMediaManager.prototype.userStartedSpeaking = function() {\n        return $fc49a56cd8739127$var$__awaiter(this, void 0, Promise, function() {\n            return $fc49a56cd8739127$var$__generator(this, function(_a) {\n                return [\n                    2 /*return*/ ,\n                    this._wavStreamPlayer.interrupt()\n                ];\n            });\n        });\n    };\n    WavMediaManager.prototype.bufferBotAudio = function(data, id) {\n        return this._wavStreamPlayer.add16BitPCM(data, id);\n    };\n    WavMediaManager.prototype.getAllMics = function() {\n        return this._wavRecorder.listDevices();\n    };\n    WavMediaManager.prototype.getAllCams = function() {\n        // TODO: Video not supported yet\n        return Promise.resolve([]);\n    };\n    WavMediaManager.prototype.getAllSpeakers = function() {\n        // TODO: Implement speaker support\n        return Promise.resolve([]);\n    };\n    WavMediaManager.prototype.updateMic = function(micId) {\n        return $fc49a56cd8739127$var$__awaiter(this, void 0, Promise, function() {\n            var prevMic, curMic;\n            var _a, _b;\n            return $fc49a56cd8739127$var$__generator(this, function(_c) {\n                switch(_c.label){\n                    case 0:\n                        prevMic = this._wavRecorder.deviceSelection;\n                        return [\n                            4 /*yield*/ ,\n                            this._wavRecorder.end()\n                        ];\n                    case 1:\n                        _c.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this._wavRecorder.begin(micId)\n                        ];\n                    case 2:\n                        _c.sent();\n                        if (!this._micEnabled) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            this._startRecording()\n                        ];\n                    case 3:\n                        _c.sent();\n                        _c.label = 4;\n                    case 4:\n                        curMic = this._wavRecorder.deviceSelection;\n                        if (curMic && prevMic && prevMic.label !== curMic.label) (_b = (_a = this._callbacks).onMicUpdated) === null || _b === void 0 || _b.call(_a, curMic);\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    WavMediaManager.prototype.updateCam = function(camId) {\n    // TODO: Video not supported yet\n    };\n    WavMediaManager.prototype.updateSpeaker = function(speakerId) {\n    // TODO: Implement speaker support\n    };\n    Object.defineProperty(WavMediaManager.prototype, \"selectedMic\", {\n        get: function() {\n            var _a;\n            return (_a = this._wavRecorder.deviceSelection) !== null && _a !== void 0 ? _a : {};\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(WavMediaManager.prototype, \"selectedCam\", {\n        get: function() {\n            // TODO: Video not supported yet\n            return {};\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(WavMediaManager.prototype, \"selectedSpeaker\", {\n        get: function() {\n            // TODO: Implement speaker support\n            return {};\n        },\n        enumerable: false,\n        configurable: true\n    });\n    WavMediaManager.prototype.enableMic = function(enable) {\n        return $fc49a56cd8739127$var$__awaiter(this, void 0, Promise, function() {\n            var _this = this;\n            return $fc49a56cd8739127$var$__generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        this._micEnabled = enable;\n                        if (!this._wavRecorder.stream) return [\n                            2 /*return*/ \n                        ];\n                        this._wavRecorder.stream.getAudioTracks().forEach(function(track) {\n                            var _a, _b;\n                            track.enabled = enable;\n                            if (!enable) (_b = (_a = _this._callbacks).onTrackStopped) === null || _b === void 0 || _b.call(_a, track, $fc49a56cd8739127$var$localParticipant());\n                        });\n                        if (!enable) return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            this._startRecording()\n                        ];\n                    case 1:\n                        _a.sent();\n                        return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                    case 2:\n                        return [\n                            4 /*yield*/ ,\n                            this._wavRecorder.pause()\n                        ];\n                    case 3:\n                        _a.sent();\n                        _a.label = 4;\n                    case 4:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    WavMediaManager.prototype.enableCam = function(enable) {\n    // TODO: Video not supported yet\n    };\n    Object.defineProperty(WavMediaManager.prototype, \"isCamEnabled\", {\n        get: function() {\n            // TODO: Video not supported yet\n            return false;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(WavMediaManager.prototype, \"isMicEnabled\", {\n        get: function() {\n            return this._micEnabled;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    WavMediaManager.prototype.tracks = function() {\n        var _a;\n        var tracks = (_a = this._wavRecorder.stream) === null || _a === void 0 ? void 0 : _a.getTracks()[0];\n        return {\n            local: tracks ? {\n                audio: tracks\n            } : {}\n        };\n    };\n    WavMediaManager.prototype._startRecording = function() {\n        return $fc49a56cd8739127$var$__awaiter(this, void 0, void 0, function() {\n            var track;\n            var _this = this;\n            var _a, _b, _c;\n            return $fc49a56cd8739127$var$__generator(this, function(_d) {\n                switch(_d.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this._wavRecorder.record(function(data) {\n                                _this._userAudioCallback(data.mono);\n                            }, this._recorderChunkSize)\n                        ];\n                    case 1:\n                        _d.sent();\n                        track = (_a = this._wavRecorder.stream) === null || _a === void 0 ? void 0 : _a.getAudioTracks()[0];\n                        if (track) (_c = (_b = this._callbacks).onTrackStarted) === null || _c === void 0 || _c.call(_b, track, $fc49a56cd8739127$var$localParticipant());\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    WavMediaManager.prototype._handleAvailableDevicesUpdated = function(devices) {\n        var _a, _b, _c, _d;\n        (_b = (_a = this._callbacks).onAvailableCamsUpdated) === null || _b === void 0 || _b.call(_a, devices.filter(function(d) {\n            return d.kind === \"videoinput\";\n        }));\n        (_d = (_c = this._callbacks).onAvailableMicsUpdated) === null || _d === void 0 || _d.call(_c, devices.filter(function(d) {\n            return d.kind === \"audioinput\";\n        }));\n        // if the current device went away or we're using the default and\n        // the default changed, reset the mic.\n        var defaultDevice = devices.find(function(d) {\n            return d.deviceId === \"default\";\n        });\n        var currentDevice = this._wavRecorder.deviceSelection;\n        if (currentDevice && (!devices.some(function(d) {\n            return d.deviceId === currentDevice.deviceId;\n        }) || currentDevice.deviceId === \"default\" && currentDevice.label !== (defaultDevice === null || defaultDevice === void 0 ? void 0 : defaultDevice.label))) this.updateMic(\"\");\n    };\n    return WavMediaManager;\n}($fc49a56cd8739127$export$4a0c46dbbe2ddb67);\nvar $fc49a56cd8739127$var$localParticipant = function() {\n    return {\n        id: \"local\",\n        name: \"\",\n        local: true\n    };\n};\n\n\n\n\n\nvar $22ece045290c996a$var$__extends =  false || function() {\n    var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf || ({\n            __proto__: []\n        }) instanceof Array && function(d, b) {\n            d.__proto__ = b;\n        } || function(d, b) {\n            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n        };\n        return extendStatics(d, b);\n    };\n    return function(d, b) {\n        if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nvar $22ece045290c996a$var$__awaiter =  false || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar $22ece045290c996a$var$__generator =  false || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nvar $22ece045290c996a$export$c95c65abc5f47125 = /** @class */ function(_super) {\n    $22ece045290c996a$var$__extends(DailyMediaManager, _super);\n    function DailyMediaManager(enablePlayer, enableRecording, onTrackStartedCallback, onTrackStoppedCallback, recorderChunkSize, recorderSampleRate, playerSampleRate) {\n        if (enablePlayer === void 0) enablePlayer = true;\n        if (enableRecording === void 0) enableRecording = true;\n        if (recorderChunkSize === void 0) recorderChunkSize = undefined;\n        if (recorderSampleRate === void 0) recorderSampleRate = 24000;\n        if (playerSampleRate === void 0) playerSampleRate = 24000;\n        var _a;\n        var _this = _super.call(this) || this;\n        _this._selectedCam = {};\n        _this._selectedMic = {};\n        _this._selectedSpeaker = {};\n        _this._remoteAudioLevelInterval = null;\n        _this._recorderChunkSize = undefined;\n        _this._initialized = false;\n        _this._connected = false;\n        _this._currentAudioTrack = null;\n        _this._connectResolve = null;\n        _this.onTrackStartedCallback = onTrackStartedCallback;\n        _this.onTrackStoppedCallback = onTrackStoppedCallback;\n        _this._recorderChunkSize = recorderChunkSize;\n        _this._daily = (_a = (0, _daily_co_daily_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]).getCallInstance()) !== null && _a !== void 0 ? _a : (0, _daily_co_daily_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]).createCallObject();\n        if (enableRecording) _this._mediaStreamRecorder = new (0, $5fc11d7bc0d20724$export$2934cf2d25c67a48)({\n            sampleRate: recorderSampleRate\n        });\n        if (enablePlayer) _this._wavStreamPlayer = new (0, $d0a969833958d9e7$export$9698d62c78b8f366)({\n            sampleRate: playerSampleRate\n        });\n        _this._daily.on(\"track-started\", _this.handleTrackStarted.bind(_this));\n        _this._daily.on(\"track-stopped\", _this.handleTrackStopped.bind(_this));\n        _this._daily.on(\"available-devices-updated\", _this._handleAvailableDevicesUpdated.bind(_this));\n        _this._daily.on(\"selected-devices-updated\", _this._handleSelectedDevicesUpdated.bind(_this));\n        _this._daily.on(\"local-audio-level\", _this._handleLocalAudioLevel.bind(_this));\n        return _this;\n    }\n    DailyMediaManager.prototype.initialize = function() {\n        return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {\n            var infos, devices, cams, mics, speakers;\n            var _this = this;\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n            return $22ece045290c996a$var$__generator(this, function(_o) {\n                switch(_o.label){\n                    case 0:\n                        if (this._initialized) {\n                            console.warn(\"DailyMediaManager already initialized\");\n                            return [\n                                2 /*return*/ \n                            ];\n                        }\n                        return [\n                            4 /*yield*/ ,\n                            this._daily.startCamera({\n                                startVideoOff: !this._camEnabled,\n                                startAudioOff: !this._micEnabled\n                            })\n                        ];\n                    case 1:\n                        infos = _o.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this._daily.enumerateDevices()\n                        ];\n                    case 2:\n                        devices = _o.sent().devices;\n                        cams = devices.filter(function(d) {\n                            return d.kind === \"videoinput\";\n                        });\n                        mics = devices.filter(function(d) {\n                            return d.kind === \"audioinput\";\n                        });\n                        speakers = devices.filter(function(d) {\n                            return d.kind === \"audiooutput\";\n                        });\n                        (_b = (_a = this._callbacks).onAvailableCamsUpdated) === null || _b === void 0 || _b.call(_a, cams);\n                        (_d = (_c = this._callbacks).onAvailableMicsUpdated) === null || _d === void 0 || _d.call(_c, mics);\n                        (_f = (_e = this._callbacks).onAvailableSpeakersUpdated) === null || _f === void 0 || _f.call(_e, speakers);\n                        this._selectedCam = infos.camera;\n                        (_h = (_g = this._callbacks).onCamUpdated) === null || _h === void 0 || _h.call(_g, infos.camera);\n                        this._selectedMic = infos.mic;\n                        (_k = (_j = this._callbacks).onMicUpdated) === null || _k === void 0 || _k.call(_j, infos.mic);\n                        this._selectedSpeaker = infos.speaker;\n                        (_m = (_l = this._callbacks).onSpeakerUpdated) === null || _m === void 0 || _m.call(_l, infos.speaker);\n                        if (!!this._daily.isLocalAudioLevelObserverRunning()) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            this._daily.startLocalAudioLevelObserver(100)\n                        ];\n                    case 3:\n                        _o.sent();\n                        _o.label = 4;\n                    case 4:\n                        if (!this._wavStreamPlayer) return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            this._wavStreamPlayer.connect()\n                        ];\n                    case 5:\n                        _o.sent();\n                        if (!this._remoteAudioLevelInterval) this._remoteAudioLevelInterval = setInterval(function() {\n                            var _a;\n                            var frequencies = _this._wavStreamPlayer.getFrequencies();\n                            var aveVal = 0;\n                            if ((_a = frequencies.values) === null || _a === void 0 ? void 0 : _a.length) aveVal = frequencies.values.reduce(function(a, c) {\n                                return a + c;\n                            }, 0) / frequencies.values.length;\n                            _this._handleRemoteAudioLevel(aveVal);\n                        }, 100);\n                        _o.label = 6;\n                    case 6:\n                        this._initialized = true;\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    DailyMediaManager.prototype.connect = function() {\n        return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {\n            var _this = this;\n            return $22ece045290c996a$var$__generator(this, function(_a) {\n                if (this._connected) {\n                    console.warn(\"DailyMediaManager already connected\");\n                    return [\n                        2 /*return*/ \n                    ];\n                }\n                this._connected = true;\n                if (!this._initialized) return [\n                    2 /*return*/ ,\n                    new Promise(function(resolve) {\n                        (function() {\n                            return $22ece045290c996a$var$__awaiter(_this, void 0, void 0, function() {\n                                return $22ece045290c996a$var$__generator(this, function(_a) {\n                                    switch(_a.label){\n                                        case 0:\n                                            this._connectResolve = resolve;\n                                            return [\n                                                4 /*yield*/ ,\n                                                this.initialize()\n                                            ];\n                                        case 1:\n                                            _a.sent();\n                                            return [\n                                                2 /*return*/ \n                                            ];\n                                    }\n                                });\n                            });\n                        })();\n                    })\n                ];\n                if (this._micEnabled) this._startRecording();\n                return [\n                    2 /*return*/ \n                ];\n            });\n        });\n    };\n    DailyMediaManager.prototype.disconnect = function() {\n        return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {\n            var _a, _b;\n            return $22ece045290c996a$var$__generator(this, function(_c) {\n                switch(_c.label){\n                    case 0:\n                        if (this._remoteAudioLevelInterval) clearInterval(this._remoteAudioLevelInterval);\n                        this._remoteAudioLevelInterval = null;\n                        this._daily.leave();\n                        this._currentAudioTrack = null;\n                        return [\n                            4 /*yield*/ ,\n                            (_a = this._mediaStreamRecorder) === null || _a === void 0 ? void 0 : _a.end()\n                        ];\n                    case 1:\n                        _c.sent();\n                        (_b = this._wavStreamPlayer) === null || _b === void 0 || _b.interrupt();\n                        this._initialized = false;\n                        this._connected = false;\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    DailyMediaManager.prototype.userStartedSpeaking = function() {\n        return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {\n            var _a;\n            return $22ece045290c996a$var$__generator(this, function(_b) {\n                return [\n                    2 /*return*/ ,\n                    (_a = this._wavStreamPlayer) === null || _a === void 0 ? void 0 : _a.interrupt()\n                ];\n            });\n        });\n    };\n    DailyMediaManager.prototype.bufferBotAudio = function(data, id) {\n        var _a;\n        return (_a = this._wavStreamPlayer) === null || _a === void 0 ? void 0 : _a.add16BitPCM(data, id);\n    };\n    DailyMediaManager.prototype.getAllMics = function() {\n        return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {\n            var devices;\n            return $22ece045290c996a$var$__generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this._daily.enumerateDevices()\n                        ];\n                    case 1:\n                        devices = _a.sent().devices;\n                        return [\n                            2 /*return*/ ,\n                            devices.filter(function(device) {\n                                return device.kind === \"audioinput\";\n                            })\n                        ];\n                }\n            });\n        });\n    };\n    DailyMediaManager.prototype.getAllCams = function() {\n        return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {\n            var devices;\n            return $22ece045290c996a$var$__generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this._daily.enumerateDevices()\n                        ];\n                    case 1:\n                        devices = _a.sent().devices;\n                        return [\n                            2 /*return*/ ,\n                            devices.filter(function(device) {\n                                return device.kind === \"videoinput\";\n                            })\n                        ];\n                }\n            });\n        });\n    };\n    DailyMediaManager.prototype.getAllSpeakers = function() {\n        return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {\n            var devices;\n            return $22ece045290c996a$var$__generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this._daily.enumerateDevices()\n                        ];\n                    case 1:\n                        devices = _a.sent().devices;\n                        return [\n                            2 /*return*/ ,\n                            devices.filter(function(device) {\n                                return device.kind === \"audiooutput\";\n                            })\n                        ];\n                }\n            });\n        });\n    };\n    DailyMediaManager.prototype.updateMic = function(micId) {\n        var _this = this;\n        this._daily.setInputDevicesAsync({\n            audioDeviceId: micId\n        }).then(function(deviceInfo) {\n            _this._selectedMic = deviceInfo.mic;\n        });\n    };\n    DailyMediaManager.prototype.updateCam = function(camId) {\n        var _this = this;\n        this._daily.setInputDevicesAsync({\n            videoDeviceId: camId\n        }).then(function(deviceInfo) {\n            _this._selectedCam = deviceInfo.camera;\n        });\n    };\n    DailyMediaManager.prototype.updateSpeaker = function(speakerId) {\n        return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {\n            var sID, speakers, defaultSpeaker_1, defaultSpeakerCp;\n            var _this = this;\n            var _a, _b;\n            return $22ece045290c996a$var$__generator(this, function(_c) {\n                switch(_c.label){\n                    case 0:\n                        if (speakerId !== \"default\" && this._selectedSpeaker.deviceId === speakerId) return [\n                            2 /*return*/ \n                        ];\n                        sID = speakerId;\n                        if (!(sID === \"default\")) return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            this.getAllSpeakers()\n                        ];\n                    case 1:\n                        speakers = _c.sent();\n                        defaultSpeaker_1 = speakers.find(function(s) {\n                            return s.deviceId === \"default\";\n                        });\n                        if (!defaultSpeaker_1) {\n                            console.warn(\"No default speaker found\");\n                            return [\n                                2 /*return*/ \n                            ];\n                        }\n                        speakers.splice(speakers.indexOf(defaultSpeaker_1), 1);\n                        defaultSpeakerCp = speakers.find(function(s) {\n                            return defaultSpeaker_1.label.includes(s.label);\n                        });\n                        sID = (_a = defaultSpeakerCp === null || defaultSpeakerCp === void 0 ? void 0 : defaultSpeakerCp.deviceId) !== null && _a !== void 0 ? _a : speakerId;\n                        _c.label = 2;\n                    case 2:\n                        (_b = this._wavStreamPlayer) === null || _b === void 0 || _b.updateSpeaker(sID).then(function() {\n                            var _a, _b;\n                            _this._selectedSpeaker = {\n                                deviceId: speakerId\n                            };\n                            (_b = (_a = _this._callbacks).onSpeakerUpdated) === null || _b === void 0 || _b.call(_a, _this._selectedSpeaker);\n                        });\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    Object.defineProperty(DailyMediaManager.prototype, \"selectedMic\", {\n        get: function() {\n            return this._selectedMic;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DailyMediaManager.prototype, \"selectedCam\", {\n        get: function() {\n            return this._selectedCam;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DailyMediaManager.prototype, \"selectedSpeaker\", {\n        get: function() {\n            return this._selectedSpeaker;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    DailyMediaManager.prototype.enableMic = function(enable) {\n        return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {\n            var _a;\n            return $22ece045290c996a$var$__generator(this, function(_b) {\n                this._micEnabled = enable;\n                if (!((_a = this._daily.participants()) === null || _a === void 0 ? void 0 : _a.local)) return [\n                    2 /*return*/ \n                ];\n                this._daily.setLocalAudio(enable);\n                if (this._mediaStreamRecorder) {\n                    if (enable) {\n                        if (this._mediaStreamRecorder.getStatus() === \"paused\") this._startRecording();\n                         // else, we'll record on the track-started event\n                    } else if (this._mediaStreamRecorder.getStatus() === \"recording\") this._mediaStreamRecorder.pause();\n                }\n                return [\n                    2 /*return*/ \n                ];\n            });\n        });\n    };\n    DailyMediaManager.prototype.enableCam = function(enable) {\n        this._camEnabled = enable;\n        this._daily.setLocalVideo(enable);\n    };\n    Object.defineProperty(DailyMediaManager.prototype, \"isCamEnabled\", {\n        get: function() {\n            return this._daily.localVideo();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DailyMediaManager.prototype, \"isMicEnabled\", {\n        get: function() {\n            return this._daily.localAudio();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    DailyMediaManager.prototype.tracks = function() {\n        var _a, _b, _c, _d, _e, _f;\n        var participants = this._daily.participants();\n        return {\n            local: {\n                audio: (_c = (_b = (_a = participants === null || participants === void 0 ? void 0 : participants.local) === null || _a === void 0 ? void 0 : _a.tracks) === null || _b === void 0 ? void 0 : _b.audio) === null || _c === void 0 ? void 0 : _c.persistentTrack,\n                video: (_f = (_e = (_d = participants === null || participants === void 0 ? void 0 : participants.local) === null || _d === void 0 ? void 0 : _d.tracks) === null || _e === void 0 ? void 0 : _e.video) === null || _f === void 0 ? void 0 : _f.persistentTrack\n            }\n        };\n    };\n    DailyMediaManager.prototype._startRecording = function() {\n        var _this = this;\n        if (!this._connected || !this._mediaStreamRecorder) return;\n        try {\n            this._mediaStreamRecorder.record(function(data) {\n                _this._userAudioCallback(data.mono);\n            }, this._recorderChunkSize);\n        } catch (e) {\n            var err = e;\n            if (!err.message.includes(\"Already recording\")) console.error(\"Error starting recording\", e);\n        }\n    };\n    DailyMediaManager.prototype._handleAvailableDevicesUpdated = function(event) {\n        var _a, _b, _c, _d, _e, _f;\n        (_b = (_a = this._callbacks).onAvailableCamsUpdated) === null || _b === void 0 || _b.call(_a, event.availableDevices.filter(function(d) {\n            return d.kind === \"videoinput\";\n        }));\n        (_d = (_c = this._callbacks).onAvailableMicsUpdated) === null || _d === void 0 || _d.call(_c, event.availableDevices.filter(function(d) {\n            return d.kind === \"audioinput\";\n        }));\n        (_f = (_e = this._callbacks).onAvailableSpeakersUpdated) === null || _f === void 0 || _f.call(_e, event.availableDevices.filter(function(d) {\n            return d.kind === \"audiooutput\";\n        }));\n        if (this._selectedSpeaker.deviceId === \"default\") this.updateSpeaker(\"default\");\n    };\n    DailyMediaManager.prototype._handleSelectedDevicesUpdated = function(event) {\n        var _a, _b, _c, _d, _e, _f;\n        if (((_a = this._selectedCam) === null || _a === void 0 ? void 0 : _a.deviceId) !== event.devices.camera) {\n            this._selectedCam = event.devices.camera;\n            (_c = (_b = this._callbacks).onCamUpdated) === null || _c === void 0 || _c.call(_b, event.devices.camera);\n        }\n        if (((_d = this._selectedMic) === null || _d === void 0 ? void 0 : _d.deviceId) !== event.devices.mic) {\n            this._selectedMic = event.devices.mic;\n            (_f = (_e = this._callbacks).onMicUpdated) === null || _f === void 0 || _f.call(_e, event.devices.mic);\n        }\n    };\n    DailyMediaManager.prototype._handleLocalAudioLevel = function(ev) {\n        var _a, _b;\n        (_b = (_a = this._callbacks).onLocalAudioLevel) === null || _b === void 0 || _b.call(_a, ev.audioLevel);\n    };\n    DailyMediaManager.prototype._handleRemoteAudioLevel = function(audioLevel) {\n        var _a, _b;\n        (_b = (_a = this._callbacks).onRemoteAudioLevel) === null || _b === void 0 || _b.call(_a, audioLevel, $22ece045290c996a$var$botParticipant());\n    };\n    DailyMediaManager.prototype.handleTrackStarted = function(event) {\n        return $22ece045290c996a$var$__awaiter(this, void 0, void 0, function() {\n            var status, _a;\n            var _b, _c, _d, _e;\n            return $22ece045290c996a$var$__generator(this, function(_f) {\n                switch(_f.label){\n                    case 0:\n                        if (!((_b = event.participant) === null || _b === void 0 ? void 0 : _b.local)) return [\n                            2 /*return*/ \n                        ];\n                        if (!(event.track.kind === \"audio\")) return [\n                            3 /*break*/ ,\n                            10\n                        ];\n                        if (!this._mediaStreamRecorder) return [\n                            3 /*break*/ ,\n                            9\n                        ];\n                        status = this._mediaStreamRecorder.getStatus();\n                        _a = status;\n                        switch(_a){\n                            case \"ended\":\n                                return [\n                                    3 /*break*/ ,\n                                    1\n                                ];\n                            case \"paused\":\n                                return [\n                                    3 /*break*/ ,\n                                    3\n                                ];\n                            case \"recording\":\n                                return [\n                                    3 /*break*/ ,\n                                    4\n                                ];\n                        }\n                        return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                    case 1:\n                        return [\n                            4 /*yield*/ ,\n                            this._mediaStreamRecorder.begin(event.track)\n                        ];\n                    case 2:\n                        _f.sent();\n                        if (this._connected) {\n                            this._startRecording();\n                            if (this._connectResolve) {\n                                this._connectResolve();\n                                this._connectResolve = null;\n                            }\n                        }\n                        return [\n                            3 /*break*/ ,\n                            9\n                        ];\n                    case 3:\n                        this._startRecording();\n                        return [\n                            3 /*break*/ ,\n                            9\n                        ];\n                    case 4:\n                        if (!(this._currentAudioTrack !== event.track)) return [\n                            3 /*break*/ ,\n                            7\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            this._mediaStreamRecorder.end()\n                        ];\n                    case 5:\n                        _f.sent();\n                        return [\n                            4 /*yield*/ ,\n                            this._mediaStreamRecorder.begin(event.track)\n                        ];\n                    case 6:\n                        _f.sent();\n                        this._startRecording();\n                        return [\n                            3 /*break*/ ,\n                            8\n                        ];\n                    case 7:\n                        console.warn(\"track-started event received for current track and already recording\");\n                        _f.label = 8;\n                    case 8:\n                        return [\n                            3 /*break*/ ,\n                            9\n                        ];\n                    case 9:\n                        this._currentAudioTrack = event.track;\n                        _f.label = 10;\n                    case 10:\n                        (_d = (_c = this._callbacks).onTrackStarted) === null || _d === void 0 || _d.call(_c, event.track, event.participant ? $22ece045290c996a$var$dailyParticipantToParticipant(event.participant) : undefined);\n                        (_e = this.onTrackStartedCallback) === null || _e === void 0 || _e.call(this, event);\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    DailyMediaManager.prototype.handleTrackStopped = function(event) {\n        var _a, _b, _c, _d;\n        if (!((_a = event.participant) === null || _a === void 0 ? void 0 : _a.local)) return;\n        if (event.track.kind === \"audio\") {\n            if (this._mediaStreamRecorder && this._mediaStreamRecorder.getStatus() === \"recording\") this._mediaStreamRecorder.pause();\n        }\n        (_c = (_b = this._callbacks).onTrackStopped) === null || _c === void 0 || _c.call(_b, event.track, event.participant ? $22ece045290c996a$var$dailyParticipantToParticipant(event.participant) : undefined);\n        (_d = this.onTrackStoppedCallback) === null || _d === void 0 || _d.call(this, event);\n    };\n    return DailyMediaManager;\n}((0, $fc49a56cd8739127$export$4a0c46dbbe2ddb67));\nvar $22ece045290c996a$var$dailyParticipantToParticipant = function(p) {\n    return {\n        id: p.user_id,\n        local: p.local,\n        name: p.user_name\n    };\n};\nvar $22ece045290c996a$var$botParticipant = function() {\n    return {\n        id: \"bot\",\n        local: false,\n        name: \"Bot\"\n    };\n};\n\n\n\n\nvar $032380dbcf3f4e13$var$__extends =  false || function() {\n    var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf || ({\n            __proto__: []\n        }) instanceof Array && function(d, b) {\n            d.__proto__ = b;\n        } || function(d, b) {\n            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n        };\n        return extendStatics(d, b);\n    };\n    return function(d, b) {\n        if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nvar $032380dbcf3f4e13$var$__awaiter =  false || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar $032380dbcf3f4e13$var$__generator =  false || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nvar $032380dbcf3f4e13$var$__spreadArray =  false || function(to, from, pack) {\n    if (pack || arguments.length === 2) {\n        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar $032380dbcf3f4e13$var$readyStates = [\n    \"CONNECTING\",\n    \"OPEN\",\n    \"CLOSING\",\n    \"CLOSED\"\n];\nvar $032380dbcf3f4e13$var$KEEP_ALIVE_INTERVAL = 5000;\nvar $032380dbcf3f4e13$var$KEEP_ALIVE_TIMEOUT = 15000;\n// client side code in soupSFU has a timeout of 15 seconds for command response\n// 5 seconds seems reasonable that it provides roughly 3 retry attempts\nvar $032380dbcf3f4e13$var$WEBSOCKET_CONNECTION_TIMEOUT = 150000;\nvar $032380dbcf3f4e13$var$DEFAULT_RECONNECT_ATTEMPTS = 2;\nvar $032380dbcf3f4e13$var$MAX_RECONNECT_ATTEMPTS = 10;\nvar $032380dbcf3f4e13$var$DEFAULT_RECONNECT_INTERVAL = 1000;\nvar $032380dbcf3f4e13$var$MAX_RECONNECT_INTERVAL = 30000;\nvar $032380dbcf3f4e13$var$DEFAULT_RECONNECT_DECAY = 1.5;\nvar $032380dbcf3f4e13$var$WEBSOCKET_TIMEOUT_CODE = 4100;\nvar $032380dbcf3f4e13$var$SIG_CONNECTION_CANCELED = \"SIG_CONNECTION_CANCELED\";\nvar $032380dbcf3f4e13$var$WEBSOCKET_ERROR = \"WEBSOCKET_ERROR\";\nvar $032380dbcf3f4e13$var$LOG_LEVEL;\n(function(LOG_LEVEL) {\n    LOG_LEVEL[LOG_LEVEL[\"DEBUG\"] = 0] = \"DEBUG\";\n    LOG_LEVEL[LOG_LEVEL[\"ERROR\"] = 1] = \"ERROR\";\n    LOG_LEVEL[LOG_LEVEL[\"INFO\"] = 2] = \"INFO\";\n    LOG_LEVEL[LOG_LEVEL[\"WARN\"] = 3] = \"WARN\";\n})($032380dbcf3f4e13$var$LOG_LEVEL || ($032380dbcf3f4e13$var$LOG_LEVEL = {}));\nvar $032380dbcf3f4e13$var$rWebSocket = /** @class */ function() {\n    function rWebSocket(url, protocols) {\n        this._closedManually = false;\n        this._errored = false;\n        this._rejected = false;\n        this._timed_out = false;\n        this._initialConnectionOk = false;\n        this._ws = new WebSocket(url, protocols);\n    }\n    rWebSocket.prototype.addEventListener = function(type, listener) {\n        this._ws.addEventListener(type, listener);\n    };\n    // Add other WebSocket methods as needed\n    rWebSocket.prototype.close = function(code, reason) {\n        this._ws.close(code, reason);\n    };\n    rWebSocket.prototype.send = function(data) {\n        this._ws.send(data);\n    };\n    Object.defineProperty(rWebSocket.prototype, \"url\", {\n        // Add getters for WebSocket properties\n        get: function() {\n            return this._ws.url;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(rWebSocket.prototype, \"readyState\", {\n        get: function() {\n            return this._ws.readyState;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return rWebSocket;\n}();\n/**\n * Builds on top of Javascript Websockets\n *\n * This behaves like the Websocket library in every way, except if it fails to\n * connect or if it gets disconnected, it will try to reconnect depending on\n * the maximum number of reconnect attempts set. retry is not enabled for initial\n * connection. When initial connection fails it is best to check yourself before\n * you keep wreckin' yourself.\n *\n * It is API compatible, so when you have:\n *   ws = new WebSocket('ws://....');\n * you can replace with:\n *   ws = new ReconnectingWebSocket('ws://....');\n *\n * While it is API compatible with the NodeJS ws library, we provide the\n * following additional properties and events on the ReconnectingWebSocket.\n *\n * Events:\n *\n * connection-timeout\n * - Emitted when the web socket connection times out.\n *\n * reconnecting\n * - Emitted after a manual close of the web socket is done and before retrying\n *   the connection.\n *\n * reconnect-failed\n * - Emitted when the number of connection attempts exceeds the set number of\n *   reconnection attempts.\n *\n * keep-alive\n * - Emitted when the set keep alive interval elapses. This event may be used\n *   to have ping pong keep-alive mechanism for web socket health.\n *\n * Properties:\n *\n * keepAliveTimeout\n * - The timeout for keep-alive. Default: 15000\n *\n * keepAliveInterval\n * - The interval at which to emit keep-alive event. Default: 5000\n *\n * shouldRetryFn\n * - A callback function which should return boolean to determine if a web\n *   socket reconnection attempt should be made. When not set, connection is\n *   always retried.\n *\n * connectionTimeout\n * - The timeout interval for considering whether the connection timed out.\n *   Default: 20000 ms\n *\n * maxReconnectAttempts\n * - The maximum number of attempts to be made for reconnection. Default: 2\n *\n * reconnectInterval\n * - The interval to wait before attempting a reconnection. Default: 1000 ms\n */ var $032380dbcf3f4e13$export$4f3d0ffd941ebefb = /** @class */ function(_super) {\n    $032380dbcf3f4e13$var$__extends(ReconnectingWebSocket, _super);\n    function ReconnectingWebSocket(address, protocols, options) {\n        if (options === void 0) options = {};\n        var _a;\n        var _this = _super.call(this) || this;\n        if (!address) throw new Error(\"Need a valid WebSocket URL\");\n        _this._ws = null;\n        _this._url = address;\n        _this._protocols = protocols;\n        _this._parseBlobToJson = (_a = options === null || options === void 0 ? void 0 : options.parseBlobToJson) !== null && _a !== void 0 ? _a : true;\n        _this.init();\n        return _this;\n    }\n    ReconnectingWebSocket.prototype.init = function() {\n        this._keepAliveTimeout = $032380dbcf3f4e13$var$KEEP_ALIVE_TIMEOUT;\n        this._keepAliveInterval = $032380dbcf3f4e13$var$KEEP_ALIVE_INTERVAL;\n        this._disconnected = false;\n        this._keepIntervalID = null;\n        this._shouldRetryFn = null;\n        this._connectionTimeout = $032380dbcf3f4e13$var$WEBSOCKET_CONNECTION_TIMEOUT;\n        this._reconnectAttempts = 0;\n        this._allowedReconnectAttempts = $032380dbcf3f4e13$var$DEFAULT_RECONNECT_ATTEMPTS;\n        this._reconnectInterval = $032380dbcf3f4e13$var$DEFAULT_RECONNECT_INTERVAL;\n        this._maxReconnectInterval = $032380dbcf3f4e13$var$MAX_RECONNECT_INTERVAL;\n        this._reconnectDecay = $032380dbcf3f4e13$var$DEFAULT_RECONNECT_DECAY;\n    };\n    ReconnectingWebSocket.prototype.connect = function() {\n        return $032380dbcf3f4e13$var$__awaiter(this, void 0, void 0, function() {\n            var _this = this;\n            return $032380dbcf3f4e13$var$__generator(this, function(_a) {\n                return [\n                    2 /*return*/ ,\n                    new Promise(function(resolve, reject) {\n                        _this._disconnected = false;\n                        _this.clearReconnectTimeout();\n                        var ws = new $032380dbcf3f4e13$var$rWebSocket(_this._url, _this._protocols);\n                        _this.setConnectionTimeout();\n                        ws.addEventListener(\"close\", function(evt) {\n                            var closeEvent = evt;\n                            var code = ws._timed_out ? $032380dbcf3f4e13$var$WEBSOCKET_TIMEOUT_CODE : closeEvent.code;\n                            var reason = ws._timed_out ? \"websocket connection timed out\" : closeEvent.reason;\n                            ws._timed_out = false;\n                            if (!ws._closedManually && ws._initialConnectionOk) {\n                                console.warn(\"signaling socket closed unexpectedly: \".concat(code).concat(reason ? \" \" + reason : \"\"));\n                                _this._closeSocket();\n                                _this.emit(\"close\", code, reason);\n                            } else _this.log(\"signaling socket closed\");\n                            if (!ws._closedManually && (ws._errored || ws._timed_out)) {\n                                console.warn(\"signaling socket closed on error: \".concat(code).concat(reason ? \" \" + reason : \"\"));\n                                if (!ws._rejected) {\n                                    ws._rejected = true;\n                                    var err = new Error(\"WebSocket connection error (\".concat(code, \"): \").concat(reason));\n                                    err.name = $032380dbcf3f4e13$var$WEBSOCKET_ERROR;\n                                    reject(err);\n                                }\n                            }\n                        });\n                        ws.addEventListener(\"open\", function(evt) {\n                            _this.log(\"wss connection opened to\", $032380dbcf3f4e13$var$LOG_LEVEL.DEBUG, _this._url);\n                            _this.clearConnectionTimeout();\n                            // now that the timeout closes the socket, in theory this onopen\n                            // callback should never happen in the first place, but seems\n                            // harmless to leave these safeguards in\n                            if (ws._rejected || ws._timed_out) return;\n                            if (ws._closedManually || _this._ws && _this._ws !== ws) {\n                                ws._rejected = true;\n                                ws.close();\n                                var err = Error(\"wss connection interrupted by disconnect or newer connection\");\n                                err.name = $032380dbcf3f4e13$var$SIG_CONNECTION_CANCELED;\n                                reject(err);\n                                return;\n                            }\n                            ws._initialConnectionOk = _this._url;\n                            _this._lastMsgRecvTime = Date.now();\n                            if (_this._keepAliveInterval) _this._keepIntervalID = setInterval(function() {\n                                return _this.checkSocketHealthAndSendKeepAlive();\n                            }, _this._keepAliveInterval);\n                            _this._ws = ws;\n                            _this.emit(\"open\");\n                            resolve(ws);\n                        });\n                        ws.addEventListener(\"error\", function(evt) {\n                            // fyi: evt is an Event here, with 0 amount of helpful info. If there\n                            //   happens to be info about the error, it's included in the\n                            //   accompanying close event (because that make sense. shakes head)\n                            //   SO. We do not reject here. Instead, we just set the _errored\n                            //   flag on the socket so when the close event occurs, it knows to\n                            //   reject the promise\n                            if (!ws._closedManually) {\n                                var wsTarget = evt.currentTarget;\n                                _this.log(\"websocket error event: \".concat(wsTarget === null || wsTarget === void 0 ? void 0 : wsTarget.url));\n                            }\n                            ws._errored = true;\n                        });\n                        ws.addEventListener(\"message\", function(msg) {\n                            _this._handleMessage(msg);\n                        });\n                    })\n                ];\n            });\n        });\n    };\n    ReconnectingWebSocket.prototype.setConnectionTimeout = function() {\n        var _this = this;\n        this._connectionTimeoutID = setTimeout(function() {\n            return $032380dbcf3f4e13$var$__awaiter(_this, void 0, void 0, function() {\n                return $032380dbcf3f4e13$var$__generator(this, function(_a) {\n                    switch(_a.label){\n                        case 0:\n                            this.log(\"Connection reconnect attempt timed out.\");\n                            this.emit(\"connection-timeout\");\n                            this.clearConnectionTimeout();\n                            return [\n                                4 /*yield*/ ,\n                                this._closeSocket()\n                            ];\n                        case 1:\n                            _a.sent();\n                            return [\n                                2 /*return*/ \n                            ];\n                    }\n                });\n            });\n        }, this._connectionTimeout);\n    };\n    ReconnectingWebSocket.prototype.clearConnectionTimeout = function() {\n        clearTimeout(this._connectionTimeoutID);\n        this._connectionTimeoutID = undefined;\n    };\n    ReconnectingWebSocket.prototype.clearReconnectTimeout = function() {\n        clearTimeout(this._reconnectTimeoutID);\n        this._reconnectTimeoutID = undefined;\n    };\n    ReconnectingWebSocket.prototype.clearKeepAliveInterval = function() {\n        if (this._keepIntervalID) {\n            clearInterval(this._keepIntervalID);\n            this._keepIntervalID = null;\n        }\n    };\n    ReconnectingWebSocket.prototype.checkSocketHealthAndSendKeepAlive = function() {\n        return $032380dbcf3f4e13$var$__awaiter(this, void 0, void 0, function() {\n            return $032380dbcf3f4e13$var$__generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        if (!(this._ws && this._ws.readyState === WebSocket.OPEN)) return [\n                            2 /*return*/ \n                        ];\n                        if (!this._keepAliveTimeout || !this._keepAliveInterval) return [\n                            2 /*return*/ \n                        ];\n                        if (!(Date.now() - this._lastMsgRecvTime > this._keepAliveTimeout)) return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                        this.log(\"Connection is stale, need to reconnect\", $032380dbcf3f4e13$var$LOG_LEVEL.WARN);\n                        return [\n                            4 /*yield*/ ,\n                            this._closeSocket()\n                        ];\n                    case 1:\n                        _a.sent();\n                        return [\n                            2 /*return*/ \n                        ];\n                    case 2:\n                        // Only emit the keep-alive event if we haven't sent anything else recently\n                        if (Date.now() - this._lastMsgSendTime < this._keepAliveInterval) return [\n                            2 /*return*/ \n                        ];\n                        this.log(\"Emitting keep-alive\", $032380dbcf3f4e13$var$LOG_LEVEL.DEBUG);\n                        this.emit(\"keep-alive\");\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    // We use the word manually here to imply the application using this code\n    // or this code itself will decide to close the socket.\n    ReconnectingWebSocket.prototype._closeSocket = function() {\n        return $032380dbcf3f4e13$var$__awaiter(this, void 0, void 0, function() {\n            var shouldRetry, error_1;\n            var _a;\n            return $032380dbcf3f4e13$var$__generator(this, function(_b) {\n                switch(_b.label){\n                    case 0:\n                        this.log(\"Closing\");\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([\n                            1,\n                            4,\n                            ,\n                            5\n                        ]);\n                        this.clearKeepAliveInterval();\n                        this._lastMsgRecvTime = 0;\n                        if (this._ws) {\n                            this._ws._closedManually = true;\n                            this._ws.close();\n                        }\n                        shouldRetry = ((_a = this._ws) === null || _a === void 0 ? void 0 : _a._initialConnectionOk) && this._shouldRetryFn && this._shouldRetryFn();\n                        this._ws = null;\n                        if (!shouldRetry) return [\n                            3 /*break*/ ,\n                            3\n                        ];\n                        this.log(\"Emitting reconnect\", $032380dbcf3f4e13$var$LOG_LEVEL.DEBUG);\n                        this.emit(\"reconnecting\");\n                        return [\n                            4 /*yield*/ ,\n                            this.retryFailedConnection()\n                        ];\n                    case 2:\n                        _b.sent();\n                        _b.label = 3;\n                    case 3:\n                        return [\n                            3 /*break*/ ,\n                            5\n                        ];\n                    case 4:\n                        error_1 = _b.sent();\n                        this.log(\"Error while closing and retrying: \".concat(error_1), $032380dbcf3f4e13$var$LOG_LEVEL.ERROR);\n                        return [\n                            3 /*break*/ ,\n                            5\n                        ];\n                    case 5:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    ReconnectingWebSocket.prototype.retryFailedConnection = function() {\n        return $032380dbcf3f4e13$var$__awaiter(this, void 0, void 0, function() {\n            var timeout;\n            var _this = this;\n            return $032380dbcf3f4e13$var$__generator(this, function(_a) {\n                if (this._reconnectAttempts < this._allowedReconnectAttempts) {\n                    if (this._reconnectTimeoutID) {\n                        this.log(\"Retry already scheduled\");\n                        return [\n                            2 /*return*/ \n                        ];\n                    }\n                    this.log(\"Retrying failed connection\");\n                    timeout = // The timeout logic is taken from\n                    // https://github.com/joewalnes/reconnecting-websocket\n                    this._reconnectInterval * Math.pow(this._reconnectDecay, this._reconnectAttempts);\n                    timeout = timeout > this._maxReconnectInterval ? this._maxReconnectInterval : timeout;\n                    this.log(\"Reconnecting in \".concat(timeout / 1000, \" seconds\"));\n                    this._reconnectAttempts += 1;\n                    this._reconnectTimeoutID = setTimeout(function() {\n                        return _this.connect();\n                    }, timeout);\n                } else {\n                    this.log(\"Maximum connection retry attempts exceeded\", $032380dbcf3f4e13$var$LOG_LEVEL.ERROR);\n                    this.emit(\"reconnect-failed\");\n                }\n                return [\n                    2 /*return*/ \n                ];\n            });\n        });\n    };\n    ReconnectingWebSocket.prototype.log = function(msg, log_level) {\n        if (log_level === void 0) log_level = $032380dbcf3f4e13$var$LOG_LEVEL.DEBUG;\n        var args = [];\n        for(var _i = 2; _i < arguments.length; _i++)args[_i - 2] = arguments[_i];\n        switch(log_level){\n            case $032380dbcf3f4e13$var$LOG_LEVEL.DEBUG:\n                console.debug.apply(console, $032380dbcf3f4e13$var$__spreadArray([\n                    \"websocket: \".concat(msg)\n                ], args, false));\n                break;\n            case $032380dbcf3f4e13$var$LOG_LEVEL.ERROR:\n                console.error.apply(console, $032380dbcf3f4e13$var$__spreadArray([\n                    \"websocket: \".concat(msg)\n                ], args, false));\n                break;\n            case $032380dbcf3f4e13$var$LOG_LEVEL.WARN:\n                console.warn.apply(console, $032380dbcf3f4e13$var$__spreadArray([\n                    \"websocket: \".concat(msg)\n                ], args, false));\n                break;\n            case $032380dbcf3f4e13$var$LOG_LEVEL.INFO:\n            default:\n                console.log.apply(console, $032380dbcf3f4e13$var$__spreadArray([\n                    \"websocket: \".concat(msg)\n                ], args, false));\n                break;\n        }\n    };\n    ReconnectingWebSocket.prototype.send = function(data) {\n        return $032380dbcf3f4e13$var$__awaiter(this, void 0, void 0, function() {\n            return $032380dbcf3f4e13$var$__generator(this, function(_a) {\n                try {\n                    if (this._ws && this._ws.readyState === WebSocket.OPEN) {\n                        this._lastMsgSendTime = Date.now();\n                        this._ws.send(data);\n                    } else this.log(\"Failed to send data, web socket not open.\", $032380dbcf3f4e13$var$LOG_LEVEL.ERROR);\n                } catch (error) {\n                    this.log(\"Failed to send data. \".concat(error), $032380dbcf3f4e13$var$LOG_LEVEL.ERROR);\n                }\n                return [\n                    2 /*return*/ \n                ];\n            });\n        });\n    };\n    ReconnectingWebSocket.prototype.close = function() {\n        return $032380dbcf3f4e13$var$__awaiter(this, void 0, void 0, function() {\n            return $032380dbcf3f4e13$var$__generator(this, function(_a) {\n                try {\n                    this.log(\"Closing websocket\");\n                    this._disconnected = true;\n                    this.clearReconnectTimeout();\n                    this._closeSocket();\n                } catch (error) {\n                    this.log(\"Failed to close websocket. \".concat(error));\n                }\n                return [\n                    2 /*return*/ \n                ];\n            });\n        });\n    };\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"readyState\", {\n        get: function() {\n            var _a, _b;\n            return (_b = (_a = this._ws) === null || _a === void 0 ? void 0 : _a.readyState) !== null && _b !== void 0 ? _b : WebSocket.CLOSED;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"url\", {\n        get: function() {\n            return this._url;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"keepAliveTimeout\", {\n        get: function() {\n            return this._keepAliveTimeout;\n        },\n        set: function(keepAliveTimeout) {\n            if (typeof keepAliveTimeout === \"number\") {\n                this.log(\"Setting ACK freshness timeout to \".concat(keepAliveTimeout));\n                this._keepAliveTimeout = keepAliveTimeout;\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"keepAliveInterval\", {\n        get: function() {\n            return this._keepAliveInterval;\n        },\n        set: function(keepAliveInterval) {\n            if (typeof keepAliveInterval === \"number\") {\n                this.log(\"Setting keep-alive interval to \".concat(keepAliveInterval));\n                this._keepAliveInterval = keepAliveInterval;\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"shouldRetryFn\", {\n        set: function(cb) {\n            if (typeof cb === \"function\") this._shouldRetryFn = cb;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"connectionTimeout\", {\n        get: function() {\n            return this._connectionTimeout;\n        },\n        set: function(timeout) {\n            if (typeof timeout === \"number\") this._connectionTimeout = timeout;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"maxReconnectAttempts\", {\n        get: function() {\n            return this._allowedReconnectAttempts;\n        },\n        set: function(attempts) {\n            if (attempts > 0 && attempts < $032380dbcf3f4e13$var$MAX_RECONNECT_ATTEMPTS) {\n                this.log(\"Setting maximum connection retry attempts to \".concat(attempts));\n                this._allowedReconnectAttempts = attempts;\n            } else this._allowedReconnectAttempts = $032380dbcf3f4e13$var$DEFAULT_RECONNECT_ATTEMPTS;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"reconnectInterval\", {\n        get: function() {\n            return this._reconnectInterval;\n        },\n        set: function(interval) {\n            if (typeof interval === \"number\") this._reconnectInterval = interval < this._maxReconnectInterval ? interval : this._maxReconnectInterval;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ReconnectingWebSocket.prototype._handleMessage = function(event) {\n        return $032380dbcf3f4e13$var$__awaiter(this, void 0, void 0, function() {\n            var data, _parsePromise, msg;\n            var _this = this;\n            return $032380dbcf3f4e13$var$__generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        this._lastMsgRecvTime = Date.now();\n                        data = event.data;\n                        _parsePromise = new Promise(function(resolve, reject) {\n                            if (typeof data === \"string\") // Handle text message\n                            resolve(data);\n                            else if (data instanceof ArrayBuffer) {\n                                // Handle binary message\n                                var arrayBuffer = data;\n                                // Parse the ArrayBuffer as needed\n                                // Example: Convert ArrayBuffer to Uint8Array\n                                resolve(new Uint8Array(arrayBuffer));\n                            // Process the Uint8Array as needed\n                            } else if (data instanceof Blob) {\n                                if (!_this._parseBlobToJson) {\n                                    resolve(data);\n                                    return;\n                                }\n                                // Handle Blob message\n                                var blob = data;\n                                // Convert Blob to ArrayBuffer\n                                var reader_1 = new FileReader();\n                                reader_1.onload = function() {\n                                    var text = reader_1.result;\n                                    try {\n                                        var json = JSON.parse(text);\n                                        resolve(json);\n                                    } catch (e) {\n                                        console.error(\"Failed to parse JSON from Blob:\", e);\n                                    }\n                                };\n                                reader_1.readAsText(blob);\n                            }\n                        });\n                        return [\n                            4 /*yield*/ ,\n                            _parsePromise\n                        ];\n                    case 1:\n                        msg = _a.sent();\n                        this.emit(\"message\", msg);\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    return ReconnectingWebSocket;\n}((0, events__WEBPACK_IMPORTED_MODULE_2__.EventEmitter));\n[\n    \"binaryType\",\n    \"bufferedAmount\",\n    \"extensions\",\n    \"protocol\",\n    \"readyState\",\n    \"url\",\n    \"keepAliveTimeout\",\n    \"keepAliveInterval\",\n    \"shouldRetryFn\",\n    \"connectionTimeout\",\n    \"maxReconnectAttempts\",\n    \"reconnectInterval\"\n].forEach(function(property) {\n    Object.defineProperty($032380dbcf3f4e13$export$4f3d0ffd941ebefb.prototype, property, {\n        enumerable: true\n    });\n});\n[\n    \"CONNECTING\",\n    \"OPEN\",\n    \"CLOSING\",\n    \"CLOSED\"\n].forEach(function(property) {\n    Object.defineProperty($032380dbcf3f4e13$export$4f3d0ffd941ebefb.prototype, property, {\n        enumerable: true,\n        value: $032380dbcf3f4e13$var$readyStates.indexOf(property)\n    });\n});\n[\n    \"CONNECTING\",\n    \"OPEN\",\n    \"CLOSING\",\n    \"CLOSED\"\n].forEach(function(property) {\n    Object.defineProperty($032380dbcf3f4e13$export$4f3d0ffd941ebefb, property, {\n        enumerable: true,\n        value: $032380dbcf3f4e13$var$readyStates.indexOf(property)\n    });\n});\n\n\n\n\n// @generated message type with reflection information, may provide speed optimized methods\nclass $5177d56bd0c995e0$var$TextFrame$Type extends (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_4__.MessageType) {\n    constructor(){\n        super(\"pipecat.TextFrame\", [\n            {\n                no: 1,\n                name: \"id\",\n                kind: \"scalar\",\n                T: 4 /*ScalarType.UINT64*/ ,\n                L: 0 /*LongType.BIGINT*/ \n            },\n            {\n                no: 2,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"text\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.id = 0n;\n        message.name = \"\";\n        message.text = \"\";\n        if (value !== undefined) (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_5__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* uint64 id */ 1:\n                    message.id = reader.uint64().toBigInt();\n                    break;\n                case /* string name */ 2:\n                    message.name = reader.string();\n                    break;\n                case /* string text */ 3:\n                    message.text = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.UnknownFieldHandler).onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* uint64 id = 1; */ if (message.id !== 0n) writer.tag(1, (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.WireType).Varint).uint64(message.id);\n        /* string name = 2; */ if (message.name !== \"\") writer.tag(2, (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.WireType).LengthDelimited).string(message.name);\n        /* string text = 3; */ if (message.text !== \"\") writer.tag(3, (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.WireType).LengthDelimited).string(message.text);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.UnknownFieldHandler).onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\nconst $5177d56bd0c995e0$export$78410ada03f6931b = new $5177d56bd0c995e0$var$TextFrame$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass $5177d56bd0c995e0$var$AudioRawFrame$Type extends (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_4__.MessageType) {\n    constructor(){\n        super(\"pipecat.AudioRawFrame\", [\n            {\n                no: 1,\n                name: \"id\",\n                kind: \"scalar\",\n                T: 4 /*ScalarType.UINT64*/ ,\n                L: 0 /*LongType.BIGINT*/ \n            },\n            {\n                no: 2,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"audio\",\n                kind: \"scalar\",\n                T: 12 /*ScalarType.BYTES*/ \n            },\n            {\n                no: 4,\n                name: \"sample_rate\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 5,\n                name: \"num_channels\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 6,\n                name: \"pts\",\n                kind: \"scalar\",\n                opt: true,\n                T: 4 /*ScalarType.UINT64*/ ,\n                L: 0 /*LongType.BIGINT*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.id = 0n;\n        message.name = \"\";\n        message.audio = new Uint8Array(0);\n        message.sampleRate = 0;\n        message.numChannels = 0;\n        if (value !== undefined) (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_5__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* uint64 id */ 1:\n                    message.id = reader.uint64().toBigInt();\n                    break;\n                case /* string name */ 2:\n                    message.name = reader.string();\n                    break;\n                case /* bytes audio */ 3:\n                    message.audio = reader.bytes();\n                    break;\n                case /* uint32 sample_rate */ 4:\n                    message.sampleRate = reader.uint32();\n                    break;\n                case /* uint32 num_channels */ 5:\n                    message.numChannels = reader.uint32();\n                    break;\n                case /* optional uint64 pts */ 6:\n                    message.pts = reader.uint64().toBigInt();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.UnknownFieldHandler).onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* uint64 id = 1; */ if (message.id !== 0n) writer.tag(1, (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.WireType).Varint).uint64(message.id);\n        /* string name = 2; */ if (message.name !== \"\") writer.tag(2, (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.WireType).LengthDelimited).string(message.name);\n        /* bytes audio = 3; */ if (message.audio.length) writer.tag(3, (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.WireType).LengthDelimited).bytes(message.audio);\n        /* uint32 sample_rate = 4; */ if (message.sampleRate !== 0) writer.tag(4, (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.WireType).Varint).uint32(message.sampleRate);\n        /* uint32 num_channels = 5; */ if (message.numChannels !== 0) writer.tag(5, (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.WireType).Varint).uint32(message.numChannels);\n        /* optional uint64 pts = 6; */ if (message.pts !== undefined) writer.tag(6, (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.WireType).Varint).uint64(message.pts);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.UnknownFieldHandler).onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\nconst $5177d56bd0c995e0$export$51d8721de3cbff8f = new $5177d56bd0c995e0$var$AudioRawFrame$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass $5177d56bd0c995e0$var$TranscriptionFrame$Type extends (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_4__.MessageType) {\n    constructor(){\n        super(\"pipecat.TranscriptionFrame\", [\n            {\n                no: 1,\n                name: \"id\",\n                kind: \"scalar\",\n                T: 4 /*ScalarType.UINT64*/ ,\n                L: 0 /*LongType.BIGINT*/ \n            },\n            {\n                no: 2,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"text\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 5,\n                name: \"timestamp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.id = 0n;\n        message.name = \"\";\n        message.text = \"\";\n        message.userId = \"\";\n        message.timestamp = \"\";\n        if (value !== undefined) (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_5__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* uint64 id */ 1:\n                    message.id = reader.uint64().toBigInt();\n                    break;\n                case /* string name */ 2:\n                    message.name = reader.string();\n                    break;\n                case /* string text */ 3:\n                    message.text = reader.string();\n                    break;\n                case /* string user_id */ 4:\n                    message.userId = reader.string();\n                    break;\n                case /* string timestamp */ 5:\n                    message.timestamp = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.UnknownFieldHandler).onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* uint64 id = 1; */ if (message.id !== 0n) writer.tag(1, (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.WireType).Varint).uint64(message.id);\n        /* string name = 2; */ if (message.name !== \"\") writer.tag(2, (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.WireType).LengthDelimited).string(message.name);\n        /* string text = 3; */ if (message.text !== \"\") writer.tag(3, (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.WireType).LengthDelimited).string(message.text);\n        /* string user_id = 4; */ if (message.userId !== \"\") writer.tag(4, (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.WireType).LengthDelimited).string(message.userId);\n        /* string timestamp = 5; */ if (message.timestamp !== \"\") writer.tag(5, (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.WireType).LengthDelimited).string(message.timestamp);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.UnknownFieldHandler).onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\nconst $5177d56bd0c995e0$export$10b388c15a5cdc8a = new $5177d56bd0c995e0$var$TranscriptionFrame$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass $5177d56bd0c995e0$var$MessageFrame$Type extends (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_4__.MessageType) {\n    constructor(){\n        super(\"pipecat.MessageFrame\", [\n            {\n                no: 1,\n                name: \"data\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.data = \"\";\n        if (value !== undefined) (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_5__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string data */ 1:\n                    message.data = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.UnknownFieldHandler).onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string data = 1; */ if (message.data !== \"\") writer.tag(1, (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.WireType).LengthDelimited).string(message.data);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.UnknownFieldHandler).onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\nconst $5177d56bd0c995e0$export$bc3f45a6d434f14a = new $5177d56bd0c995e0$var$MessageFrame$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass $5177d56bd0c995e0$var$Frame$Type extends (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_4__.MessageType) {\n    constructor(){\n        super(\"pipecat.Frame\", [\n            {\n                no: 1,\n                name: \"text\",\n                kind: \"message\",\n                oneof: \"frame\",\n                T: ()=>$5177d56bd0c995e0$export$78410ada03f6931b\n            },\n            {\n                no: 2,\n                name: \"audio\",\n                kind: \"message\",\n                oneof: \"frame\",\n                T: ()=>$5177d56bd0c995e0$export$51d8721de3cbff8f\n            },\n            {\n                no: 3,\n                name: \"transcription\",\n                kind: \"message\",\n                oneof: \"frame\",\n                T: ()=>$5177d56bd0c995e0$export$10b388c15a5cdc8a\n            },\n            {\n                no: 4,\n                name: \"message\",\n                kind: \"message\",\n                oneof: \"frame\",\n                T: ()=>$5177d56bd0c995e0$export$bc3f45a6d434f14a\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.frame = {\n            oneofKind: undefined\n        };\n        if (value !== undefined) (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_5__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* pipecat.TextFrame text */ 1:\n                    message.frame = {\n                        oneofKind: \"text\",\n                        text: $5177d56bd0c995e0$export$78410ada03f6931b.internalBinaryRead(reader, reader.uint32(), options, message.frame.text)\n                    };\n                    break;\n                case /* pipecat.AudioRawFrame audio */ 2:\n                    message.frame = {\n                        oneofKind: \"audio\",\n                        audio: $5177d56bd0c995e0$export$51d8721de3cbff8f.internalBinaryRead(reader, reader.uint32(), options, message.frame.audio)\n                    };\n                    break;\n                case /* pipecat.TranscriptionFrame transcription */ 3:\n                    message.frame = {\n                        oneofKind: \"transcription\",\n                        transcription: $5177d56bd0c995e0$export$10b388c15a5cdc8a.internalBinaryRead(reader, reader.uint32(), options, message.frame.transcription)\n                    };\n                    break;\n                case /* pipecat.MessageFrame message */ 4:\n                    message.frame = {\n                        oneofKind: \"message\",\n                        message: $5177d56bd0c995e0$export$bc3f45a6d434f14a.internalBinaryRead(reader, reader.uint32(), options, message.frame.message)\n                    };\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.UnknownFieldHandler).onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* pipecat.TextFrame text = 1; */ if (message.frame.oneofKind === \"text\") $5177d56bd0c995e0$export$78410ada03f6931b.internalBinaryWrite(message.frame.text, writer.tag(1, (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.WireType).LengthDelimited).fork(), options).join();\n        /* pipecat.AudioRawFrame audio = 2; */ if (message.frame.oneofKind === \"audio\") $5177d56bd0c995e0$export$51d8721de3cbff8f.internalBinaryWrite(message.frame.audio, writer.tag(2, (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.WireType).LengthDelimited).fork(), options).join();\n        /* pipecat.TranscriptionFrame transcription = 3; */ if (message.frame.oneofKind === \"transcription\") $5177d56bd0c995e0$export$10b388c15a5cdc8a.internalBinaryWrite(message.frame.transcription, writer.tag(3, (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.WireType).LengthDelimited).fork(), options).join();\n        /* pipecat.MessageFrame message = 4; */ if (message.frame.oneofKind === \"message\") $5177d56bd0c995e0$export$bc3f45a6d434f14a.internalBinaryWrite(message.frame.message, writer.tag(4, (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.WireType).LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? (0, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_6__.UnknownFieldHandler).onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\nconst $5177d56bd0c995e0$export$b89a827e9254211a = new $5177d56bd0c995e0$var$Frame$Type();\n\n\nclass $a6c080dc51c9687f$export$4b2026f8e11b148a {\n    serialize(data) {}\n    serializeAudio(data, sampleRate, numChannels) {\n        const pcmByteArray = new Uint8Array(data);\n        const frame = (0, $5177d56bd0c995e0$export$b89a827e9254211a).create({\n            frame: {\n                oneofKind: \"audio\",\n                audio: {\n                    id: 0n,\n                    name: \"audio\",\n                    audio: pcmByteArray,\n                    sampleRate: sampleRate,\n                    numChannels: numChannels\n                }\n            }\n        });\n        return new Uint8Array((0, $5177d56bd0c995e0$export$b89a827e9254211a).toBinary(frame));\n    }\n    serializeMessage(msg) {\n        const frame = (0, $5177d56bd0c995e0$export$b89a827e9254211a).create({\n            frame: {\n                oneofKind: \"message\",\n                message: {\n                    data: JSON.stringify(msg)\n                }\n            }\n        });\n        return new Uint8Array((0, $5177d56bd0c995e0$export$b89a827e9254211a).toBinary(frame));\n    }\n    async deserialize(data) {\n        if (!(data instanceof Blob)) throw new Error(\"Unknown data type\");\n        const arrayBuffer = await data.arrayBuffer();\n        const parsed = (0, $5177d56bd0c995e0$export$b89a827e9254211a).fromBinary(new Uint8Array(arrayBuffer)).frame;\n        if (parsed.oneofKind === \"audio\") {\n            const audioVector = Array.from(parsed.audio.audio);\n            const uint8Array = new Uint8Array(audioVector);\n            const int16Array = new Int16Array(uint8Array.buffer);\n            return {\n                type: \"audio\",\n                audio: int16Array\n            };\n        } else if (parsed.oneofKind === \"message\") {\n            const msg = JSON.parse(parsed.message.data);\n            return {\n                type: \"message\",\n                message: msg\n            };\n        } else throw new Error(\"Unknown frame kind\");\n    }\n}\n\n\nclass $7f42eda74f1b1632$export$de21836fc42c6f9c extends (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.Transport) {\n    constructor({ serializer: serializer, recorderSampleRate: recorderSampleRate, playerSampleRate: playerSampleRate } = {\n        serializer: new (0, $a6c080dc51c9687f$export$4b2026f8e11b148a)(),\n        recorderSampleRate: $7f42eda74f1b1632$export$de21836fc42c6f9c.RECORDER_SAMPLE_RATE,\n        playerSampleRate: $7f42eda74f1b1632$export$de21836fc42c6f9c.PLAYER_SAMPLE_RATE\n    }){\n        super();\n        this.audioQueue = [];\n        this._mediaManager = new (0, $22ece045290c996a$export$c95c65abc5f47125)(true, true, undefined, undefined, 512, recorderSampleRate, playerSampleRate);\n        this._mediaManager.setUserAudioCallback(this.handleUserAudioStream.bind(this));\n        this._ws = null;\n        this._serializer = serializer;\n    }\n    initialize(options, messageHandler) {\n        this._options = options;\n        this._callbacks = options.callbacks ?? {};\n        this._onMessage = messageHandler;\n        this._mediaManager.setRTVIOptions(options);\n        this.state = \"disconnected\";\n    }\n    async initDevices() {\n        this.state = \"initializing\";\n        await this._mediaManager.initialize();\n        this.state = \"initialized\";\n    }\n    async connect(authBundle, abortController) {\n        this.state = \"connecting\";\n        try {\n            this._ws = this.initializeWebsocket(authBundle);\n            await this._ws.connect();\n            await this._mediaManager.connect();\n            this.state = \"connected\";\n            this._callbacks.onConnected?.();\n        } catch (error) {\n            const msg = `Failed to connect to websocket: ${error}`;\n            (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).error(msg);\n            this.state = \"error\";\n            throw new (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.TransportStartError)(msg);\n        }\n    }\n    async disconnect() {\n        this.state = \"disconnecting\";\n        await this._mediaManager.disconnect();\n        await this._ws?.close();\n        this.state = \"disconnected\";\n        this._callbacks.onDisconnected?.();\n    }\n    getAllMics() {\n        return this._mediaManager.getAllMics();\n    }\n    getAllCams() {\n        return this._mediaManager.getAllCams();\n    }\n    getAllSpeakers() {\n        return this._mediaManager.getAllSpeakers();\n    }\n    async updateMic(micId) {\n        return this._mediaManager.updateMic(micId);\n    }\n    updateCam(camId) {\n        return this._mediaManager.updateCam(camId);\n    }\n    updateSpeaker(speakerId) {\n        return this._mediaManager.updateSpeaker(speakerId);\n    }\n    get selectedMic() {\n        return this._mediaManager.selectedMic;\n    }\n    get selectedSpeaker() {\n        return this._mediaManager.selectedSpeaker;\n    }\n    enableMic(enable) {\n        this._mediaManager.enableMic(enable);\n    }\n    get isMicEnabled() {\n        return this._mediaManager.isMicEnabled;\n    }\n    get state() {\n        return this._state;\n    }\n    set state(state) {\n        if (this._state === state) return;\n        this._state = state;\n        this._callbacks.onTransportStateChanged?.(state);\n    }\n    get expiry() {\n        return this._expiry;\n    }\n    tracks() {\n        return this._mediaManager.tracks();\n    }\n    initializeWebsocket(authBundle) {\n        console.log(\"Initializing websocket\", authBundle);\n        const ws = new (0, $032380dbcf3f4e13$export$4f3d0ffd941ebefb)(`${authBundle.ws_url}`, undefined, {\n            parseBlobToJson: false\n        });\n        // disabling the keep alive, there is no API for it inside Pipecat\n        ws.keepAliveInterval = 0;\n        ws.on(\"open\", ()=>{\n            (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).debug(\"Websocket connection opened\");\n        });\n        ws.on(\"message\", async (data)=>{\n            try {\n                const parsed = await this._serializer.deserialize(data);\n                if (parsed.type === \"audio\") this._mediaManager.bufferBotAudio(parsed.audio);\n                else if (parsed.type === \"message\") {\n                    if (parsed.message.label === \"rtvi-ai\") this._onMessage(parsed.message);\n                }\n            } catch (e) {\n                (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).error(\"Failed to deserialize incoming message\", e);\n            }\n        });\n        ws.on(\"error\", (error)=>{\n            this.connectionError(`websocket error: ${error}`);\n        });\n        ws.on(\"connection-timeout\", ()=>{\n            this.connectionError(\"websocket connection timed out\");\n        });\n        ws.on(\"close\", (code)=>{\n            this.connectionError(`websocket connection closed. Code: ${code}`);\n        });\n        ws.on(\"reconnect-failed\", ()=>{\n            this.connectionError(`websocket reconnect failed`);\n        });\n        return ws;\n    }\n    sendReadyMessage() {\n        this.state = \"ready\";\n        this.sendMessage((0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.RTVIMessage).clientReady());\n    }\n    handleUserAudioStream(data) {\n        if (this.state === \"ready\") try {\n            this.flushAudioQueue();\n            this._sendAudioInput(data);\n        } catch (error) {\n            (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).error(\"Error sending audio stream to websocket:\", error);\n            this.state = \"error\";\n        }\n        else this.audioQueue.push(data);\n    }\n    flushAudioQueue() {\n        if (this.audioQueue.length <= 0) return;\n        (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).info(\"Will flush audio queue\", this.audioQueue.length);\n        while(this.audioQueue.length > 0){\n            const queuedData = this.audioQueue.shift();\n            if (queuedData) this._sendAudioInput(queuedData);\n        }\n    }\n    sendRawMessage(message) {\n        (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).debug(\"Received raw message to send to Web Socket\", message);\n        const encoded = this._serializer.serialize(message);\n        this._sendMsg(encoded);\n    }\n    sendMessage(message) {\n        (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).debug(\"Received message to send to Web Socket\", message);\n        const encoded = this._serializer.serializeMessage(message);\n        this._sendMsg(encoded);\n    }\n    async _sendAudioInput(data) {\n        try {\n            const encoded = this._serializer.serializeAudio(data, $7f42eda74f1b1632$export$de21836fc42c6f9c.RECORDER_SAMPLE_RATE, 1);\n            await this._sendMsg(encoded);\n        } catch (e) {\n            (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).error(\"Error sending audio frame\", e);\n        }\n    }\n    async _sendMsg(msg) {\n        if (!this._ws) {\n            (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).error(\"sendMsg called but WS is null\");\n            return;\n        }\n        if (this._ws.readyState !== WebSocket.OPEN) {\n            (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).error(\"attempt to send to closed socket\");\n            return;\n        }\n        if (!msg) return;\n        try {\n            await this._ws.send(msg);\n        } catch (e) {\n            (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).error(\"sendMsg error\", e);\n        }\n    }\n    connectionError(errorMsg) {\n        console.error(errorMsg);\n        this.state = \"error\";\n        this.disconnect();\n    }\n    // Not implemented\n    enableScreenShare(enable) {\n        (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).error(\"startScreenShare not implemented for WebSocketTransport\");\n        throw new Error(\"Not implemented\");\n    }\n    get isSharingScreen() {\n        (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).error(\"isSharingScreen not implemented for WebSocketTransport\");\n        return false;\n    }\n    enableCam(enable) {\n        (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).error(\"enableCam not implemented for WebSocketTransport\");\n        throw new Error(\"Not implemented\");\n    }\n    get isCamEnabled() {\n        (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).error(\"isCamEnabled not implemented for WebSocketTransport\");\n        return false;\n    }\n    get selectedCam() {\n        (0, _pipecat_ai_client_js__WEBPACK_IMPORTED_MODULE_1__.logger).error(\"selectedCam not implemented for WebSocketTransport\");\n        throw new Error(\"Not implemented\");\n    }\n}\n$7f42eda74f1b1632$export$de21836fc42c6f9c.RECORDER_SAMPLE_RATE = 16000;\n$7f42eda74f1b1632$export$de21836fc42c6f9c.PLAYER_SAMPLE_RATE = 24000;\n\n\n\n\nclass $5b926fa33e35e45c$export$44a8a077420336af {\n    serialize(data) {\n        return JSON.stringify(data);\n    }\n    serializeAudio(data, sampleRate, numChannels) {\n        const pcmSamples = new Int16Array(data);\n        const muLawSamples = (0, x_law__WEBPACK_IMPORTED_MODULE_3__.mulaw).encode(pcmSamples);\n        const base64Payload = this.arrayToBase64(muLawSamples);\n        const twilioMessage = {\n            event: \"media\",\n            media: {\n                payload: base64Payload\n            }\n        };\n        return JSON.stringify(twilioMessage);\n    }\n    serializeMessage(msg) {\n        // Twilio does not support RTVI messages, so just ignore them\n        return null;\n    }\n    arrayToBase64(bytes) {\n        let binary = \"\";\n        for(let i = 0; i < bytes.byteLength; i++)binary += String.fromCharCode(bytes[i]);\n        return btoa(binary);\n    }\n    base64ToUint8Array(base64) {\n        const binaryString = atob(base64);\n        const len = binaryString.length;\n        const bytes = new Uint8Array(len);\n        for(let i = 0; i < len; i++)bytes[i] = binaryString.charCodeAt(i);\n        return bytes;\n    }\n    async deserialize(data) {\n        const jsonMessage = JSON.parse(data); // Assuming 'data' is a JSON string\n        if (jsonMessage.event === \"clear\") return {\n            type: \"raw\",\n            message: jsonMessage\n        };\n        else if (jsonMessage.event === \"media\") {\n            // Deserialize 'media' event\n            const payload = jsonMessage.media.payload;\n            const serialized_data = this.base64ToUint8Array(payload);\n            //const decoded_audio = this.ulawToPcm(serialized_data);\n            const decoded_audio = (0, x_law__WEBPACK_IMPORTED_MODULE_3__.mulaw).decode(serialized_data);\n            return {\n                type: \"audio\",\n                audio: decoded_audio\n            };\n        } else // Deserialize other message types (assuming 'frame' has 'message' field)\n        return {\n            type: \"message\",\n            message: jsonMessage.message\n        };\n    }\n}\n\n\n\n\n\n//# sourceMappingURL=index.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBpcGVjYXQtYWkvd2Vic29ja2V0LXRyYW5zcG9ydC9kaXN0L2luZGV4Lm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXVEO0FBQzRIO0FBQ3hIO0FBQ3FKO0FBQ3BLOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLE1BQU07QUFDcEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsYUFBYTtBQUMxQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMseUVBQXlFO0FBQ3ZGLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBK0Q7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRLG1CQUFtQixxREFBcUQ7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGFBQWEsUUFBUTtBQUNyQixhQUFhLGNBQWM7QUFDM0IsYUFBYSw2QkFBNkI7QUFDMUMsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQSx1REFBdUQsUUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixhQUFhLGtCQUFrQjtBQUMvQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUNBQXlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2QkFBNkI7QUFDMUMsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRCxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QztBQUNBLE1BQU07QUFDTjtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDLHNCQUFzQiw4QkFBOEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw4QkFBOEIsZUFBZTtBQUM3QztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0JBQXNCO0FBQ3BDLGVBQWU7QUFDZixvQkFBb0IsaUNBQWlDLElBQUk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esa0VBQWtFLGVBQWU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2QkFBNkI7QUFDMUMsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YscURBQXFELFFBQVEsSUFBSSxFQUFFO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCx3QkFBd0IseURBQXlEO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckMsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUyxxQkFBcUIsaUJBQWlCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlDQUF5QztBQUNyRTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkJBQTJCO0FBQzFEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtRUFBbUU7QUFDakYsZUFBZTtBQUNmLG9CQUFvQixtR0FBbUcsSUFBSTtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtREFBbUQ7QUFDaEUsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0JBQXNCO0FBQ3JELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMscUJBQXFCO0FBQ25DLGFBQWEsa0JBQWtCO0FBQy9CLGVBQWUsU0FBUyxtQkFBbUI7QUFDM0Msa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHLEtBQUs7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMEJBQTBCLGlCQUFpQixlQUFlO0FBQ3ZFLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlDQUFpQyxpQkFBaUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esa0VBQWtFLGVBQWU7QUFDakY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1DQUFtQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2QkFBNkI7QUFDMUMsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUyxrQkFBa0IsaUJBQWlCLFVBQVU7QUFDbkUsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZiwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVMsd0RBQXdEO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUVBQW1FO0FBQ2pGLGVBQWU7QUFDZixvQkFBb0IsbUdBQW1HLElBQUk7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLHFCQUFxQjtBQUNuQyxhQUFhLGtCQUFrQjtBQUMvQixlQUFlLFNBQVMsbUJBQW1CO0FBQzNDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxLQUFLO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esa0VBQWtFLGVBQWU7QUFDakY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1DQUFtQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkJBQTZCO0FBQzFDLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVMsa0JBQWtCLGlCQUFpQixVQUFVO0FBQ25FLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2YsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTLHdEQUF3RDtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQSxzQ0FBc0MsTUFBZ0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxzQ0FBc0MsTUFBZ0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLE1BQWtDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BLHNDQUFzQyxNQUFnQztBQUN0RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNDQUFzQyxNQUFnQztBQUN0RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0MsTUFBa0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBEQUFxQiwwREFBMEQsMERBQXFCO0FBQ3JJO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQSxzQ0FBc0MsTUFBZ0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxzQ0FBc0MsTUFBZ0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLE1BQWtDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsTUFBb0M7QUFDOUU7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEVBQTBFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDLEtBQUssZ0RBQW1CO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOzs7OztBQUtEO0FBQ0EsdURBQXVELDZEQUFrQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0VBQTZCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixTQUFTLGFBQWEsU0FBUyxRQUFRLGNBQWM7QUFDeEk7QUFDQSx1REFBdUQscUVBQTBCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNENBQTRDLDBEQUFlO0FBQ3JGLDRCQUE0Qiw4Q0FBOEMsMERBQWU7QUFDekYsNEJBQTRCLDhDQUE4QywwREFBZTtBQUN6RjtBQUNBLDBDQUEwQyxxRUFBMEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCw2REFBa0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0VBQTZCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixTQUFTLGFBQWEsU0FBUyxRQUFRLGNBQWM7QUFDeEk7QUFDQSx1REFBdUQscUVBQTBCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNENBQTRDLDBEQUFlO0FBQ3JGLDRCQUE0Qiw4Q0FBOEMsMERBQWU7QUFDekYsNEJBQTRCLCtDQUErQywwREFBZTtBQUMxRixtQ0FBbUMsbURBQW1ELDBEQUFlO0FBQ3JHLG9DQUFvQyxvREFBb0QsMERBQWU7QUFDdkcsb0NBQW9DLG9EQUFvRCwwREFBZTtBQUN2RztBQUNBLDBDQUEwQyxxRUFBMEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSw2REFBa0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0VBQTZCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixTQUFTLGFBQWEsU0FBUyxRQUFRLGNBQWM7QUFDeEk7QUFDQSx1REFBdUQscUVBQTBCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNENBQTRDLDBEQUFlO0FBQ3JGLDRCQUE0Qiw4Q0FBOEMsMERBQWU7QUFDekYsNEJBQTRCLDhDQUE4QywwREFBZTtBQUN6RiwrQkFBK0IsZ0RBQWdELDBEQUFlO0FBQzlGLGlDQUFpQyxtREFBbUQsMERBQWU7QUFDbkc7QUFDQSwwQ0FBMEMscUVBQTBCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsNkRBQWtCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHdFQUE2QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsU0FBUyxhQUFhLFNBQVMsUUFBUSxjQUFjO0FBQ3hJO0FBQ0EsdURBQXVELHFFQUEwQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhDQUE4QywwREFBZTtBQUN6RjtBQUNBLDBDQUEwQyxxRUFBMEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCw2REFBa0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0VBQTZCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixTQUFTLGFBQWEsU0FBUyxRQUFRLGNBQWM7QUFDeEk7QUFDQSx1REFBdUQscUVBQTBCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsK0lBQStJLDBEQUFlO0FBQ3JNLDRDQUE0QyxpSkFBaUosMERBQWU7QUFDNU0seURBQXlELGlLQUFpSywwREFBZTtBQUN6Tyw2Q0FBNkMscUpBQXFKLDBEQUFlO0FBQ2pOO0FBQ0EsMENBQTBDLHFFQUEwQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQSw0REFBNEQsNERBQWdCO0FBQzVFLGtCQUFrQixxR0FBcUc7QUFDdkg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwyREFBMkQsTUFBTTtBQUNqRSxnQkFBZ0IseURBQWE7QUFDN0I7QUFDQSwwQkFBMEIsc0VBQTBCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGtCQUFrQjtBQUMzRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQWE7QUFDN0IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLG9CQUFvQix5REFBYTtBQUNqQztBQUNBLFNBQVM7QUFDVDtBQUNBLHFEQUFxRCxNQUFNO0FBQzNELFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsdUVBQXVFLEtBQUs7QUFDNUUsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOERBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsZ0JBQWdCLHlEQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsZ0JBQWdCLHlEQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGdCQUFnQix5REFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsd0NBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHdDQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLNFU7QUFDNVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92b2ljZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHBpcGVjYXQtYWkvd2Vic29ja2V0LXRyYW5zcG9ydC9kaXN0L2luZGV4Lm1vZHVsZS5qcz82ODIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAka1I2dEckZGFpbHljb2RhaWx5anMgZnJvbSBcIkBkYWlseS1jby9kYWlseS1qc1wiO1xuaW1wb3J0IHtsb2dnZXIgYXMgJGtSNnRHJGxvZ2dlciwgVHJhbnNwb3J0U3RhcnRFcnJvciBhcyAka1I2dEckVHJhbnNwb3J0U3RhcnRFcnJvciwgUlRWSU1lc3NhZ2UgYXMgJGtSNnRHJFJUVklNZXNzYWdlLCBUcmFuc3BvcnQgYXMgJGtSNnRHJFRyYW5zcG9ydH0gZnJvbSBcIkBwaXBlY2F0LWFpL2NsaWVudC1qc1wiO1xuaW1wb3J0IHtFdmVudEVtaXR0ZXIgYXMgJGtSNnRHJEV2ZW50RW1pdHRlcn0gZnJvbSBcImV2ZW50c1wiO1xuaW1wb3J0IHtyZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsIGFzICRrUjZ0RyRyZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsLCBVbmtub3duRmllbGRIYW5kbGVyIGFzICRrUjZ0RyRVbmtub3duRmllbGRIYW5kbGVyLCBXaXJlVHlwZSBhcyAka1I2dEckV2lyZVR5cGUsIE1lc3NhZ2VUeXBlIGFzICRrUjZ0RyRNZXNzYWdlVHlwZX0gZnJvbSBcIkBwcm90b2J1Zi10cy9ydW50aW1lXCI7XG5pbXBvcnQge211bGF3IGFzICRrUjZ0RyRtdWxhd30gZnJvbSBcIngtbGF3XCI7XG5cbi8vIGV4cG9ydCAqIGZyb20gXCIuL3JlYWxUaW1lV2ViU29ja2V0VHJhbnNwb3J0XCI7XG4vLyBleHBvcnQgKiBmcm9tIFwiLi4vLi4vLi4vbGliL3dhdnRvb2xzL2Rpc3QvaW5kZXguZC50c1wiO1xuLyoqXG4gKiBSYXcgd2F2IGF1ZGlvIGZpbGUgY29udGVudHNcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFdhdlBhY2tlckF1ZGlvVHlwZVxuICogQHByb3BlcnR5IHtCbG9ifSBibG9iXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdXJsXG4gKiBAcHJvcGVydHkge251bWJlcn0gY2hhbm5lbENvdW50XG4gKiBAcHJvcGVydHkge251bWJlcn0gc2FtcGxlUmF0ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGR1cmF0aW9uXG4gKi8gLyoqXG4gKiBVdGlsaXR5IGNsYXNzIGZvciBhc3NlbWJsaW5nIFBDTTE2IFwiYXVkaW8vd2F2XCIgZGF0YVxuICogQGNsYXNzXG4gKi8gY2xhc3MgJDZkNGI3NDQ5YTFlMTU0NGEkZXhwb3J0JDEzYWZkYTIzN2IxYzk4NDYge1xuICAgIC8qKlxuICAgKiBDb252ZXJ0cyBGbG9hdDMyQXJyYXkgb2YgYW1wbGl0dWRlIGRhdGEgdG8gQXJyYXlCdWZmZXIgaW4gSW50MTZBcnJheSBmb3JtYXRcbiAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGZsb2F0MzJBcnJheVxuICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9XG4gICAqLyBzdGF0aWMgZmxvYXRUbzE2Qml0UENNKGZsb2F0MzJBcnJheSkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoZmxvYXQzMkFycmF5Lmxlbmd0aCAqIDIpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZmxvYXQzMkFycmF5Lmxlbmd0aDsgaSsrLCBvZmZzZXQgKz0gMil7XG4gICAgICAgICAgICBsZXQgcyA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbigxLCBmbG9hdDMyQXJyYXlbaV0pKTtcbiAgICAgICAgICAgIHZpZXcuc2V0SW50MTYob2Zmc2V0LCBzIDwgMCA/IHMgKiAweDgwMDAgOiBzICogMHg3ZmZmLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbiAgICAvKipcbiAgICogQ29uY2F0ZW5hdGVzIHR3byBBcnJheUJ1ZmZlcnNcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gbGVmdEJ1ZmZlclxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSByaWdodEJ1ZmZlclxuICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9XG4gICAqLyBzdGF0aWMgbWVyZ2VCdWZmZXJzKGxlZnRCdWZmZXIsIHJpZ2h0QnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHRtcEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobGVmdEJ1ZmZlci5ieXRlTGVuZ3RoICsgcmlnaHRCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRtcEFycmF5LnNldChuZXcgVWludDhBcnJheShsZWZ0QnVmZmVyKSwgMCk7XG4gICAgICAgIHRtcEFycmF5LnNldChuZXcgVWludDhBcnJheShyaWdodEJ1ZmZlciksIGxlZnRCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiB0bXBBcnJheS5idWZmZXI7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQYWNrcyBkYXRhIGludG8gYW4gSW50MTYgZm9ybWF0XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIDAgPSAxeCBJbnQxNiwgMSA9IDJ4IEludDE2XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhcmcgdmFsdWUgdG8gcGFja1xuICAgKiBAcmV0dXJuc1xuICAgKi8gX3BhY2tEYXRhKHNpemUsIGFyZykge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgICAgIGFyZyxcbiAgICAgICAgICAgICAgICBhcmcgPj4gOFxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAgICAgYXJnLFxuICAgICAgICAgICAgICAgIGFyZyA+PiA4LFxuICAgICAgICAgICAgICAgIGFyZyA+PiAxNixcbiAgICAgICAgICAgICAgICBhcmcgPj4gMjRcbiAgICAgICAgICAgIF0pXG4gICAgICAgIF1bc2l6ZV07XG4gICAgfVxuICAgIC8qKlxuICAgKiBQYWNrcyBhdWRpbyBpbnRvIFwiYXVkaW8vd2F2XCIgQmxvYlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2FtcGxlUmF0ZVxuICAgKiBAcGFyYW0ge3tiaXRzUGVyU2FtcGxlOiBudW1iZXIsIGNoYW5uZWxzOiBBcnJheTxGbG9hdDMyQXJyYXk+LCBkYXRhOiBJbnQxNkFycmF5fX0gYXVkaW9cbiAgICogQHJldHVybnMge1dhdlBhY2tlckF1ZGlvVHlwZX1cbiAgICovIHBhY2soc2FtcGxlUmF0ZSwgYXVkaW8pIHtcbiAgICAgICAgaWYgKCFhdWRpbz8uYml0c1BlclNhbXBsZSkgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIFwiYml0c1BlclNhbXBsZVwiYCk7XG4gICAgICAgIGVsc2UgaWYgKCFhdWRpbz8uY2hhbm5lbHMpIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBcImNoYW5uZWxzXCJgKTtcbiAgICAgICAgZWxzZSBpZiAoIWF1ZGlvPy5kYXRhKSB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgXCJkYXRhXCJgKTtcbiAgICAgICAgY29uc3QgeyBiaXRzUGVyU2FtcGxlOiBiaXRzUGVyU2FtcGxlLCBjaGFubmVsczogY2hhbm5lbHMsIGRhdGE6IGRhdGEgfSA9IGF1ZGlvO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXG4gICAgICAgICAgICAvLyBIZWFkZXJcbiAgICAgICAgICAgICdSSUZGJyxcbiAgICAgICAgICAgIHRoaXMuX3BhY2tEYXRhKDEsIDUyKSxcbiAgICAgICAgICAgICdXQVZFJyxcbiAgICAgICAgICAgIC8vIGNodW5rIDFcbiAgICAgICAgICAgICdmbXQgJyxcbiAgICAgICAgICAgIHRoaXMuX3BhY2tEYXRhKDEsIDE2KSxcbiAgICAgICAgICAgIHRoaXMuX3BhY2tEYXRhKDAsIDEpLFxuICAgICAgICAgICAgdGhpcy5fcGFja0RhdGEoMCwgY2hhbm5lbHMubGVuZ3RoKSxcbiAgICAgICAgICAgIHRoaXMuX3BhY2tEYXRhKDEsIHNhbXBsZVJhdGUpLFxuICAgICAgICAgICAgdGhpcy5fcGFja0RhdGEoMSwgc2FtcGxlUmF0ZSAqIGNoYW5uZWxzLmxlbmd0aCAqIGJpdHNQZXJTYW1wbGUgLyA4KSxcbiAgICAgICAgICAgIHRoaXMuX3BhY2tEYXRhKDAsIGNoYW5uZWxzLmxlbmd0aCAqIGJpdHNQZXJTYW1wbGUgLyA4KSxcbiAgICAgICAgICAgIHRoaXMuX3BhY2tEYXRhKDAsIGJpdHNQZXJTYW1wbGUpLFxuICAgICAgICAgICAgLy8gY2h1bmsgMlxuICAgICAgICAgICAgJ2RhdGEnLFxuICAgICAgICAgICAgdGhpcy5fcGFja0RhdGEoMSwgY2hhbm5lbHNbMF0ubGVuZ3RoICogY2hhbm5lbHMubGVuZ3RoICogYml0c1BlclNhbXBsZSAvIDgpLFxuICAgICAgICAgICAgZGF0YVxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2Iob3V0cHV0LCB7XG4gICAgICAgICAgICB0eXBlOiAnYXVkaW8vbXBlZydcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBibG9iOiBibG9iLFxuICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICBjaGFubmVsQ291bnQ6IGNoYW5uZWxzLmxlbmd0aCxcbiAgICAgICAgICAgIHNhbXBsZVJhdGU6IHNhbXBsZVJhdGUsXG4gICAgICAgICAgICBkdXJhdGlvbjogZGF0YS5ieXRlTGVuZ3RoIC8gKGNoYW5uZWxzLmxlbmd0aCAqIHNhbXBsZVJhdGUgKiAyKVxuICAgICAgICB9O1xuICAgIH1cbn1cbmdsb2JhbFRoaXMuV2F2UGFja2VyID0gJDZkNGI3NDQ5YTFlMTU0NGEkZXhwb3J0JDEzYWZkYTIzN2IxYzk4NDY7XG5cblxuLyoqXG4gKiBDb25zdGFudHMgZm9yIGhlbHAgd2l0aCB2aXN1YWxpemF0aW9uXG4gKiBIZWxwcyBtYXAgZnJlcXVlbmN5IHJhbmdlcyBmcm9tIEZhc3QgRm91cmllciBUcmFuc2Zvcm1cbiAqIHRvIGh1bWFuLWludGVycHJldGFibGUgcmFuZ2VzLCBub3RhYmx5IG11c2ljIHJhbmdlcyBhbmRcbiAqIGh1bWFuIHZvY2FsIHJhbmdlcy5cbiAqLyAvLyBFaWdodGggb2N0YXZlIGZyZXF1ZW5jaWVzXG5jb25zdCAkMDNmNzFjZTg1ZTAwYWRhNiR2YXIkb2N0YXZlOEZyZXF1ZW5jaWVzID0gW1xuICAgIDQxODYuMDEsXG4gICAgNDQzNC45MixcbiAgICA0Njk4LjYzLFxuICAgIDQ5NzguMDMsXG4gICAgNTI3NC4wNCxcbiAgICA1NTg3LjY1LFxuICAgIDU5MTkuOTEsXG4gICAgNjI3MS45MyxcbiAgICA2NjQ0Ljg4LFxuICAgIDcwNDAuMCxcbiAgICA3NDU4LjYyLFxuICAgIDc5MDIuMTNcbl07XG4vLyBMYWJlbHMgZm9yIGVhY2ggb2YgdGhlIGFib3ZlIGZyZXF1ZW5jaWVzXG5jb25zdCAkMDNmNzFjZTg1ZTAwYWRhNiR2YXIkb2N0YXZlOEZyZXF1ZW5jeUxhYmVscyA9IFtcbiAgICAnQycsXG4gICAgJ0MjJyxcbiAgICAnRCcsXG4gICAgJ0QjJyxcbiAgICAnRScsXG4gICAgJ0YnLFxuICAgICdGIycsXG4gICAgJ0cnLFxuICAgICdHIycsXG4gICAgJ0EnLFxuICAgICdBIycsXG4gICAgJ0InXG5dO1xuY29uc3QgJDAzZjcxY2U4NWUwMGFkYTYkZXhwb3J0JDc3NmM2Mzg5OGFlNWI2MzYgPSBbXTtcbmNvbnN0ICQwM2Y3MWNlODVlMDBhZGE2JGV4cG9ydCRmYWNkMTY3Y2MyN2VhOWIwID0gW107XG5mb3IobGV0IGkgPSAxOyBpIDw9IDg7IGkrKylmb3IobGV0IGYgPSAwOyBmIDwgJDAzZjcxY2U4NWUwMGFkYTYkdmFyJG9jdGF2ZThGcmVxdWVuY2llcy5sZW5ndGg7IGYrKyl7XG4gICAgY29uc3QgZnJlcSA9ICQwM2Y3MWNlODVlMDBhZGE2JHZhciRvY3RhdmU4RnJlcXVlbmNpZXNbZl07XG4gICAgJDAzZjcxY2U4NWUwMGFkYTYkZXhwb3J0JDc3NmM2Mzg5OGFlNWI2MzYucHVzaChmcmVxIC8gTWF0aC5wb3coMiwgOCAtIGkpKTtcbiAgICAkMDNmNzFjZTg1ZTAwYWRhNiRleHBvcnQkZmFjZDE2N2NjMjdlYTliMC5wdXNoKCQwM2Y3MWNlODVlMDBhZGE2JHZhciRvY3RhdmU4RnJlcXVlbmN5TGFiZWxzW2ZdICsgaSk7XG59XG4vKipcbiAqIFN1YnNldCBvZiB0aGUgbm90ZSBmcmVxdWVuY2llcyBiZXR3ZWVuIDMyIGFuZCAyMDAwIEh6XG4gKiA2IG9jdGF2ZSByYW5nZTogQzEgdG8gQjZcbiAqLyBjb25zdCAkMDNmNzFjZTg1ZTAwYWRhNiR2YXIkdm9pY2VGcmVxdWVuY3lSYW5nZSA9IFtcbiAgICAzMi4wLFxuICAgIDIwMDAuMFxuXTtcbmNvbnN0ICQwM2Y3MWNlODVlMDBhZGE2JGV4cG9ydCRkYmMxNTgxZWQyY2ZhMTgzID0gJDAzZjcxY2U4NWUwMGFkYTYkZXhwb3J0JDc3NmM2Mzg5OGFlNWI2MzYuZmlsdGVyKChfLCBpKT0+e1xuICAgIHJldHVybiAkMDNmNzFjZTg1ZTAwYWRhNiRleHBvcnQkNzc2YzYzODk4YWU1YjYzNltpXSA+ICQwM2Y3MWNlODVlMDBhZGE2JHZhciR2b2ljZUZyZXF1ZW5jeVJhbmdlWzBdICYmICQwM2Y3MWNlODVlMDBhZGE2JGV4cG9ydCQ3NzZjNjM4OThhZTViNjM2W2ldIDwgJDAzZjcxY2U4NWUwMGFkYTYkdmFyJHZvaWNlRnJlcXVlbmN5UmFuZ2VbMV07XG59KTtcbmNvbnN0ICQwM2Y3MWNlODVlMDBhZGE2JGV4cG9ydCQzMGE2ZjI4ODEzMTEwODhmID0gJDAzZjcxY2U4NWUwMGFkYTYkZXhwb3J0JGZhY2QxNjdjYzI3ZWE5YjAuZmlsdGVyKChfLCBpKT0+e1xuICAgIHJldHVybiAkMDNmNzFjZTg1ZTAwYWRhNiRleHBvcnQkNzc2YzYzODk4YWU1YjYzNltpXSA+ICQwM2Y3MWNlODVlMDBhZGE2JHZhciR2b2ljZUZyZXF1ZW5jeVJhbmdlWzBdICYmICQwM2Y3MWNlODVlMDBhZGE2JGV4cG9ydCQ3NzZjNjM4OThhZTViNjM2W2ldIDwgJDAzZjcxY2U4NWUwMGFkYTYkdmFyJHZvaWNlRnJlcXVlbmN5UmFuZ2VbMV07XG59KTtcblxuXG5jbGFzcyAkZjMyZjA2NDU2NGVlNjJmNiRleHBvcnQkMmMzMTM2ZGEwYmYxMzBmOSB7XG4gICAgLyoqXG4gICAqIFJldHJpZXZlcyBmcmVxdWVuY3kgZG9tYWluIGRhdGEgZnJvbSBhbiBBbmFseXNlck5vZGUgYWRqdXN0ZWQgdG8gYSBkZWNpYmVsIHJhbmdlXG4gICAqIHJldHVybnMgaHVtYW4tcmVhZGFibGUgZm9ybWF0dGluZyBhbmQgbGFiZWxzXG4gICAqIEBwYXJhbSB7QW5hbHlzZXJOb2RlfSBhbmFseXNlclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2FtcGxlUmF0ZVxuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gW2ZmdFJlc3VsdF1cbiAgICogQHBhcmFtIHtcImZyZXF1ZW5jeVwifFwibXVzaWNcInxcInZvaWNlXCJ9IFthbmFseXNpc1R5cGVdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluRGVjaWJlbHNdIGRlZmF1bHQgLTEwMFxuICAgKiBAcGFyYW0ge251bWJlcn0gW21heERlY2liZWxzXSBkZWZhdWx0IC0zMFxuICAgKiBAcmV0dXJucyB7QXVkaW9BbmFseXNpc091dHB1dFR5cGV9XG4gICAqLyBzdGF0aWMgZ2V0RnJlcXVlbmNpZXMoYW5hbHlzZXIsIHNhbXBsZVJhdGUsIGZmdFJlc3VsdCwgYW5hbHlzaXNUeXBlID0gJ2ZyZXF1ZW5jeScsIG1pbkRlY2liZWxzID0gLTEwMCwgbWF4RGVjaWJlbHMgPSAtMzApIHtcbiAgICAgICAgaWYgKCFmZnRSZXN1bHQpIHtcbiAgICAgICAgICAgIGZmdFJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkoYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQpO1xuICAgICAgICAgICAgYW5hbHlzZXIuZ2V0RmxvYXRGcmVxdWVuY3lEYXRhKGZmdFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbnlxdWlzdEZyZXF1ZW5jeSA9IHNhbXBsZVJhdGUgLyAyO1xuICAgICAgICBjb25zdCBmcmVxdWVuY3lTdGVwID0gMSAvIGZmdFJlc3VsdC5sZW5ndGggKiBueXF1aXN0RnJlcXVlbmN5O1xuICAgICAgICBsZXQgb3V0cHV0VmFsdWVzO1xuICAgICAgICBsZXQgZnJlcXVlbmNpZXM7XG4gICAgICAgIGxldCBsYWJlbHM7XG4gICAgICAgIGlmIChhbmFseXNpc1R5cGUgPT09ICdtdXNpYycgfHwgYW5hbHlzaXNUeXBlID09PSAndm9pY2UnKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VGcmVxdWVuY2llcyA9IGFuYWx5c2lzVHlwZSA9PT0gJ3ZvaWNlJyA/ICgwLCAkMDNmNzFjZTg1ZTAwYWRhNiRleHBvcnQkZGJjMTU4MWVkMmNmYTE4MykgOiAoMCwgJDAzZjcxY2U4NWUwMGFkYTYkZXhwb3J0JDc3NmM2Mzg5OGFlNWI2MzYpO1xuICAgICAgICAgICAgY29uc3QgYWdncmVnYXRlT3V0cHV0ID0gQXJyYXkodXNlRnJlcXVlbmNpZXMubGVuZ3RoKS5maWxsKG1pbkRlY2liZWxzKTtcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBmZnRSZXN1bHQubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyZXF1ZW5jeSA9IGkgKiBmcmVxdWVuY3lTdGVwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFtcGxpdHVkZSA9IGZmdFJlc3VsdFtpXTtcbiAgICAgICAgICAgICAgICBmb3IobGV0IG4gPSB1c2VGcmVxdWVuY2llcy5sZW5ndGggLSAxOyBuID49IDA7IG4tLSlpZiAoZnJlcXVlbmN5ID4gdXNlRnJlcXVlbmNpZXNbbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRlT3V0cHV0W25dID0gTWF0aC5tYXgoYWdncmVnYXRlT3V0cHV0W25dLCBhbXBsaXR1ZGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXRWYWx1ZXMgPSBhZ2dyZWdhdGVPdXRwdXQ7XG4gICAgICAgICAgICBmcmVxdWVuY2llcyA9IGFuYWx5c2lzVHlwZSA9PT0gJ3ZvaWNlJyA/ICgwLCAkMDNmNzFjZTg1ZTAwYWRhNiRleHBvcnQkZGJjMTU4MWVkMmNmYTE4MykgOiAoMCwgJDAzZjcxY2U4NWUwMGFkYTYkZXhwb3J0JDc3NmM2Mzg5OGFlNWI2MzYpO1xuICAgICAgICAgICAgbGFiZWxzID0gYW5hbHlzaXNUeXBlID09PSAndm9pY2UnID8gKDAsICQwM2Y3MWNlODVlMDBhZGE2JGV4cG9ydCQzMGE2ZjI4ODEzMTEwODhmKSA6ICgwLCAkMDNmNzFjZTg1ZTAwYWRhNiRleHBvcnQkZmFjZDE2N2NjMjdlYTliMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXRWYWx1ZXMgPSBBcnJheS5mcm9tKGZmdFJlc3VsdCk7XG4gICAgICAgICAgICBmcmVxdWVuY2llcyA9IG91dHB1dFZhbHVlcy5tYXAoKF8sIGkpPT5mcmVxdWVuY3lTdGVwICogaSk7XG4gICAgICAgICAgICBsYWJlbHMgPSBmcmVxdWVuY2llcy5tYXAoKGYpPT5gJHtmLnRvRml4ZWQoMil9IEh6YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugbm9ybWFsaXplIHRvIHswLCAxfVxuICAgICAgICBjb25zdCBub3JtYWxpemVkT3V0cHV0ID0gb3V0cHV0VmFsdWVzLm1hcCgodik9PntcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigodiAtIG1pbkRlY2liZWxzKSAvIChtYXhEZWNpYmVscyAtIG1pbkRlY2liZWxzKSwgMSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShub3JtYWxpemVkT3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICAgICAgZnJlcXVlbmNpZXM6IGZyZXF1ZW5jaWVzLFxuICAgICAgICAgICAgbGFiZWxzOiBsYWJlbHNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgQXVkaW9BbmFseXNpcyBpbnN0YW5jZSBmb3IgYW4gSFRNTEF1ZGlvRWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxBdWRpb0VsZW1lbnR9IGF1ZGlvRWxlbWVudFxuICAgKiBAcGFyYW0ge0F1ZGlvQnVmZmVyfG51bGx9IFthdWRpb0J1ZmZlcl0gSWYgcHJvdmlkZWQsIHdpbGwgY2FjaGUgYWxsIGZyZXF1ZW5jeSBkb21haW4gZGF0YSBmcm9tIHRoZSBidWZmZXJcbiAgICogQHJldHVybnMge0F1ZGlvQW5hbHlzaXN9XG4gICAqLyBjb25zdHJ1Y3RvcihhdWRpb0VsZW1lbnQsIGF1ZGlvQnVmZmVyID0gbnVsbCl7XG4gICAgICAgIHRoaXMuZmZ0UmVzdWx0cyA9IFtdO1xuICAgICAgICBpZiAoYXVkaW9CdWZmZXIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICogTW9kaWZpZWQgZnJvbVxuICAgICAgICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzUwNjM3MTUvdXNpbmctdGhlLXdlYi1hdWRpby1hcGktdG8tYW5hbHl6ZS1hLXNvbmctd2l0aG91dC1wbGF5aW5nXG4gICAgICAgKlxuICAgICAgICogV2UgZG8gdGhpcyB0byBwb3B1bGF0ZSBGRlQgdmFsdWVzIGZvciB0aGUgYXVkaW8gaWYgcHJvdmlkZWQgYW4gYGF1ZGlvQnVmZmVyYFxuICAgICAgICogVGhlIHJlYXNvbiB0byBkbyB0aGlzIGlzIHRoYXQgU2FmYXJpIGZhaWxzIHdoZW4gdXNpbmcgYGNyZWF0ZU1lZGlhRWxlbWVudFNvdXJjZWBcbiAgICAgICAqIFRoaXMgaGFzIGEgbm9uLXplcm8gUkFNIGNvc3Qgc28gd2Ugb25seSBvcHQtaW4gdG8gcnVuIGl0IG9uIFNhZmFyaSwgQ2hyb21lIGlzIGJldHRlclxuICAgICAgICovIGNvbnN0IHsgbGVuZ3RoOiBsZW5ndGgsIHNhbXBsZVJhdGU6IHNhbXBsZVJhdGUgfSA9IGF1ZGlvQnVmZmVyO1xuICAgICAgICAgICAgY29uc3Qgb2ZmbGluZUF1ZGlvQ29udGV4dCA9IG5ldyBPZmZsaW5lQXVkaW9Db250ZXh0KHtcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgICAgICAgICBzYW1wbGVSYXRlOiBzYW1wbGVSYXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IG9mZmxpbmVBdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICAgICAgICBzb3VyY2UuYnVmZmVyID0gYXVkaW9CdWZmZXI7XG4gICAgICAgICAgICBjb25zdCBhbmFseXNlciA9IG9mZmxpbmVBdWRpb0NvbnRleHQuY3JlYXRlQW5hbHlzZXIoKTtcbiAgICAgICAgICAgIGFuYWx5c2VyLmZmdFNpemUgPSA4MTkyO1xuICAgICAgICAgICAgYW5hbHlzZXIuc21vb3RoaW5nVGltZUNvbnN0YW50ID0gMC4xO1xuICAgICAgICAgICAgc291cmNlLmNvbm5lY3QoYW5hbHlzZXIpO1xuICAgICAgICAgICAgLy8gbGltaXQgaXMgOjogMTI4IC8gc2FtcGxlUmF0ZTtcbiAgICAgICAgICAgIC8vIGJ1dCB3ZSBqdXN0IHdhbnQgNjBmcHMgLSBjdXRzIH4xcyBmcm9tIDZNQiB0byAxTUIgb2YgUkFNXG4gICAgICAgICAgICBjb25zdCByZW5kZXJRdWFudHVtSW5TZWNvbmRzID0gMSAvIDYwO1xuICAgICAgICAgICAgY29uc3QgZHVyYXRpb25JblNlY29uZHMgPSBsZW5ndGggLyBzYW1wbGVSYXRlO1xuICAgICAgICAgICAgY29uc3QgYW5hbHl6ZSA9IChpbmRleCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBzdXNwZW5kVGltZSA9IHJlbmRlclF1YW50dW1JblNlY29uZHMgKiBpbmRleDtcbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuZFRpbWUgPCBkdXJhdGlvbkluU2Vjb25kcykgb2ZmbGluZUF1ZGlvQ29udGV4dC5zdXNwZW5kKHN1c3BlbmRUaW1lKS50aGVuKCgpPT57XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZmdFJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkoYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQpO1xuICAgICAgICAgICAgICAgICAgICBhbmFseXNlci5nZXRGbG9hdEZyZXF1ZW5jeURhdGEoZmZ0UmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mZnRSZXN1bHRzLnB1c2goZmZ0UmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgYW5hbHl6ZShpbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMSkgb2ZmbGluZUF1ZGlvQ29udGV4dC5zdGFydFJlbmRlcmluZygpO1xuICAgICAgICAgICAgICAgIGVsc2Ugb2ZmbGluZUF1ZGlvQ29udGV4dC5yZXN1bWUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzb3VyY2Uuc3RhcnQoMCk7XG4gICAgICAgICAgICBhbmFseXplKDEpO1xuICAgICAgICAgICAgdGhpcy5hdWRpbyA9IGF1ZGlvRWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IG9mZmxpbmVBdWRpb0NvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLmFuYWx5c2VyID0gYW5hbHlzZXI7XG4gICAgICAgICAgICB0aGlzLnNhbXBsZVJhdGUgPSBzYW1wbGVSYXRlO1xuICAgICAgICAgICAgdGhpcy5hdWRpb0J1ZmZlciA9IGF1ZGlvQnVmZmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYXVkaW9Db250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuICAgICAgICAgICAgY29uc3QgdHJhY2sgPSBhdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFFbGVtZW50U291cmNlKGF1ZGlvRWxlbWVudCk7XG4gICAgICAgICAgICBjb25zdCBhbmFseXNlciA9IGF1ZGlvQ29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuICAgICAgICAgICAgYW5hbHlzZXIuZmZ0U2l6ZSA9IDgxOTI7XG4gICAgICAgICAgICBhbmFseXNlci5zbW9vdGhpbmdUaW1lQ29uc3RhbnQgPSAwLjE7XG4gICAgICAgICAgICB0cmFjay5jb25uZWN0KGFuYWx5c2VyKTtcbiAgICAgICAgICAgIGFuYWx5c2VyLmNvbm5lY3QoYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuYXVkaW8gPSBhdWRpb0VsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLmFuYWx5c2VyID0gYW5hbHlzZXI7XG4gICAgICAgICAgICB0aGlzLnNhbXBsZVJhdGUgPSB0aGlzLmNvbnRleHQuc2FtcGxlUmF0ZTtcbiAgICAgICAgICAgIHRoaXMuYXVkaW9CdWZmZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IGZyZXF1ZW5jeSBkb21haW4gZGF0YSBmcm9tIHRoZSBwbGF5aW5nIGF1ZGlvIHRyYWNrXG4gICAqIEBwYXJhbSB7XCJmcmVxdWVuY3lcInxcIm11c2ljXCJ8XCJ2b2ljZVwifSBbYW5hbHlzaXNUeXBlXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbkRlY2liZWxzXSBkZWZhdWx0IC0xMDBcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttYXhEZWNpYmVsc10gZGVmYXVsdCAtMzBcbiAgICogQHJldHVybnMge0F1ZGlvQW5hbHlzaXNPdXRwdXRUeXBlfVxuICAgKi8gZ2V0RnJlcXVlbmNpZXMoYW5hbHlzaXNUeXBlID0gJ2ZyZXF1ZW5jeScsIG1pbkRlY2liZWxzID0gLTEwMCwgbWF4RGVjaWJlbHMgPSAtMzApIHtcbiAgICAgICAgbGV0IGZmdFJlc3VsdCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmF1ZGlvQnVmZmVyICYmIHRoaXMuZmZ0UmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBjdCA9IHRoaXMuYXVkaW8uY3VycmVudFRpbWUgLyB0aGlzLmF1ZGlvLmR1cmF0aW9uO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBNYXRoLm1pbihwY3QgKiB0aGlzLmZmdFJlc3VsdHMubGVuZ3RoIHwgMCwgdGhpcy5mZnRSZXN1bHRzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgZmZ0UmVzdWx0ID0gdGhpcy5mZnRSZXN1bHRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJGYzMmYwNjQ1NjRlZTYyZjYkZXhwb3J0JDJjMzEzNmRhMGJmMTMwZjkuZ2V0RnJlcXVlbmNpZXModGhpcy5hbmFseXNlciwgdGhpcy5zYW1wbGVSYXRlLCBmZnRSZXN1bHQsIGFuYWx5c2lzVHlwZSwgbWluRGVjaWJlbHMsIG1heERlY2liZWxzKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJlc3VtZSB0aGUgaW50ZXJuYWwgQXVkaW9Db250ZXh0IGlmIGl0IHdhcyBzdXNwZW5kZWQgZHVlIHRvIHRoZSBsYWNrIG9mXG4gICAqIHVzZXIgaW50ZXJhY3Rpb24gd2hlbiB0aGUgQXVkaW9BbmFseXNpcyB3YXMgaW5zdGFudGlhdGVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx0cnVlPn1cbiAgICovIGFzeW5jIHJlc3VtZUlmU3VzcGVuZGVkKCkge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0YXRlID09PSAnc3VzcGVuZGVkJykgYXdhaXQgdGhpcy5jb250ZXh0LnJlc3VtZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5nbG9iYWxUaGlzLkF1ZGlvQW5hbHlzaXMgPSAkZjMyZjA2NDU2NGVlNjJmNiRleHBvcnQkMmMzMTM2ZGEwYmYxMzBmOTtcblxuXG5jb25zdCAkMjlhOGE3MGE5NDY2YjE0ZiRleHBvcnQkNTBiNzY3MDBlMmIxNWU5ID0gYFxuY2xhc3MgU3RyZWFtUHJvY2Vzc29yIGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmhhc1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmhhc0ludGVycnVwdGVkID0gZmFsc2U7XG4gICAgdGhpcy5vdXRwdXRCdWZmZXJzID0gW107XG4gICAgdGhpcy5idWZmZXJMZW5ndGggPSAxMjg7XG4gICAgdGhpcy53cml0ZSA9IHsgYnVmZmVyOiBuZXcgRmxvYXQzMkFycmF5KHRoaXMuYnVmZmVyTGVuZ3RoKSwgdHJhY2tJZDogbnVsbCB9O1xuICAgIHRoaXMud3JpdGVPZmZzZXQgPSAwO1xuICAgIHRoaXMudHJhY2tTYW1wbGVPZmZzZXRzID0ge307XG4gICAgdGhpcy5wb3J0Lm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRhdGEpIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IGV2ZW50LmRhdGE7XG4gICAgICAgIGlmIChwYXlsb2FkLmV2ZW50ID09PSAnd3JpdGUnKSB7XG4gICAgICAgICAgY29uc3QgaW50MTZBcnJheSA9IHBheWxvYWQuYnVmZmVyO1xuICAgICAgICAgIGNvbnN0IGZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoaW50MTZBcnJheS5sZW5ndGgpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW50MTZBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZmxvYXQzMkFycmF5W2ldID0gaW50MTZBcnJheVtpXSAvIDB4ODAwMDsgLy8gQ29udmVydCBJbnQxNiB0byBGbG9hdDMyXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMud3JpdGVEYXRhKGZsb2F0MzJBcnJheSwgcGF5bG9hZC50cmFja0lkKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBwYXlsb2FkLmV2ZW50ID09PSAnb2Zmc2V0JyB8fFxuICAgICAgICAgIHBheWxvYWQuZXZlbnQgPT09ICdpbnRlcnJ1cHQnXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHBheWxvYWQucmVxdWVzdElkO1xuICAgICAgICAgIGNvbnN0IHRyYWNrSWQgPSB0aGlzLndyaXRlLnRyYWNrSWQ7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy50cmFja1NhbXBsZU9mZnNldHNbdHJhY2tJZF0gfHwgMDtcbiAgICAgICAgICB0aGlzLnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgZXZlbnQ6ICdvZmZzZXQnLFxuICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgdHJhY2tJZCxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAocGF5bG9hZC5ldmVudCA9PT0gJ2ludGVycnVwdCcpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzSW50ZXJydXB0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxgVW5oYW5kbGVkIGV2ZW50IFwiXFwke3BheWxvYWQuZXZlbnR9XCJcXGApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHdyaXRlRGF0YShmbG9hdDMyQXJyYXksIHRyYWNrSWQgPSBudWxsKSB7XG4gICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLndyaXRlO1xuICAgIGxldCBvZmZzZXQgPSB0aGlzLndyaXRlT2Zmc2V0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmxvYXQzMkFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZmZXJbb2Zmc2V0KytdID0gZmxvYXQzMkFycmF5W2ldO1xuICAgICAgaWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMub3V0cHV0QnVmZmVycy5wdXNoKHRoaXMud3JpdGUpO1xuICAgICAgICB0aGlzLndyaXRlID0geyBidWZmZXI6IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5idWZmZXJMZW5ndGgpLCB0cmFja0lkIH07XG4gICAgICAgIGJ1ZmZlciA9IHRoaXMud3JpdGUuYnVmZmVyO1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLndyaXRlT2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJvY2VzcyhpbnB1dHMsIG91dHB1dHMsIHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRzWzBdO1xuICAgIGNvbnN0IG91dHB1dENoYW5uZWxEYXRhID0gb3V0cHV0WzBdO1xuICAgIGNvbnN0IG91dHB1dEJ1ZmZlcnMgPSB0aGlzLm91dHB1dEJ1ZmZlcnM7XG4gICAgaWYgKHRoaXMuaGFzSW50ZXJydXB0ZWQpIHtcbiAgICAgIHRoaXMucG9ydC5wb3N0TWVzc2FnZSh7IGV2ZW50OiAnc3RvcCcgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChvdXRwdXRCdWZmZXJzLmxlbmd0aCkge1xuICAgICAgdGhpcy5oYXNTdGFydGVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHsgYnVmZmVyLCB0cmFja0lkIH0gPSBvdXRwdXRCdWZmZXJzLnNoaWZ0KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENoYW5uZWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dHB1dENoYW5uZWxEYXRhW2ldID0gYnVmZmVyW2ldIHx8IDA7XG4gICAgICB9XG4gICAgICBpZiAodHJhY2tJZCkge1xuICAgICAgICB0aGlzLnRyYWNrU2FtcGxlT2Zmc2V0c1t0cmFja0lkXSA9XG4gICAgICAgICAgdGhpcy50cmFja1NhbXBsZU9mZnNldHNbdHJhY2tJZF0gfHwgMDtcbiAgICAgICAgdGhpcy50cmFja1NhbXBsZU9mZnNldHNbdHJhY2tJZF0gKz0gYnVmZmVyLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5oYXNTdGFydGVkKSB7XG4gICAgICB0aGlzLnBvcnQucG9zdE1lc3NhZ2UoeyBldmVudDogJ3N0b3AnIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxucmVnaXN0ZXJQcm9jZXNzb3IoJ3N0cmVhbV9wcm9jZXNzb3InLCBTdHJlYW1Qcm9jZXNzb3IpO1xuYDtcbmNvbnN0ICQyOWE4YTcwYTk0NjZiMTRmJHZhciRzY3JpcHQgPSBuZXcgQmxvYihbXG4gICAgJDI5YThhNzBhOTQ2NmIxNGYkZXhwb3J0JDUwYjc2NzAwZTJiMTVlOVxuXSwge1xuICAgIHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0J1xufSk7XG5jb25zdCAkMjlhOGE3MGE5NDY2YjE0ZiR2YXIkc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTCgkMjlhOGE3MGE5NDY2YjE0ZiR2YXIkc2NyaXB0KTtcbmNvbnN0ICQyOWE4YTcwYTk0NjZiMTRmJGV4cG9ydCRiZmE4YzU5NjExNGQ3NGRmID0gJDI5YThhNzBhOTQ2NmIxNGYkdmFyJHNyYztcblxuXG5cbmNsYXNzICRkMGE5Njk4MzM5NThkOWU3JGV4cG9ydCQ5Njk4ZDYyYzc4YjhmMzY2IHtcbiAgICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBXYXZTdHJlYW1QbGF5ZXIgaW5zdGFuY2VcbiAgICogQHBhcmFtIHt7c2FtcGxlUmF0ZT86IG51bWJlcn19IG9wdGlvbnNcbiAgICogQHJldHVybnMge1dhdlN0cmVhbVBsYXllcn1cbiAgICovIGNvbnN0cnVjdG9yKHsgc2FtcGxlUmF0ZTogc2FtcGxlUmF0ZSA9IDQ0MTAwIH0gPSB7fSl7XG4gICAgICAgIHRoaXMuc2NyaXB0U3JjID0gKDAsICQyOWE4YTcwYTk0NjZiMTRmJGV4cG9ydCRiZmE4YzU5NjExNGQ3NGRmKTtcbiAgICAgICAgdGhpcy5zYW1wbGVSYXRlID0gc2FtcGxlUmF0ZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBudWxsO1xuICAgICAgICB0aGlzLmFuYWx5c2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmFja1NhbXBsZU9mZnNldHMgPSB7fTtcbiAgICAgICAgdGhpcy5pbnRlcnJ1cHRlZFRyYWNrSWRzID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgKiBDb25uZWN0cyB0aGUgYXVkaW8gY29udGV4dCBhbmQgZW5hYmxlcyBvdXRwdXQgdG8gc3BlYWtlcnNcbiAgICogQHJldHVybnMge1Byb21pc2U8dHJ1ZT59XG4gICAqLyBhc3luYyBjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KHtcbiAgICAgICAgICAgIHNhbXBsZVJhdGU6IHRoaXMuc2FtcGxlUmF0ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX3NwZWFrZXJJRCkgdGhpcy5jb250ZXh0LnNldFNpbmtJZCh0aGlzLl9zcGVha2VySUQpO1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0YXRlID09PSBcInN1c3BlbmRlZFwiKSBhd2FpdCB0aGlzLmNvbnRleHQucmVzdW1lKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNvbnRleHQuYXVkaW9Xb3JrbGV0LmFkZE1vZHVsZSh0aGlzLnNjcmlwdFNyYyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBhZGQgYXVkaW9Xb3JrbGV0IG1vZHVsZTogJHt0aGlzLnNjcmlwdFNyY31gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbmFseXNlciA9IHRoaXMuY29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuICAgICAgICBhbmFseXNlci5mZnRTaXplID0gODE5MjtcbiAgICAgICAgYW5hbHlzZXIuc21vb3RoaW5nVGltZUNvbnN0YW50ID0gMC4xO1xuICAgICAgICB0aGlzLmFuYWx5c2VyID0gYW5hbHlzZXI7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBmcmVxdWVuY3kgZG9tYWluIGRhdGEgZnJvbSB0aGUgcGxheWluZyB0cmFja1xuICAgKiBAcGFyYW0ge1wiZnJlcXVlbmN5XCJ8XCJtdXNpY1wifFwidm9pY2VcIn0gW2FuYWx5c2lzVHlwZV1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaW5EZWNpYmVsc10gZGVmYXVsdCAtMTAwXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4RGVjaWJlbHNdIGRlZmF1bHQgLTMwXG4gICAqIEByZXR1cm5zIHtpbXBvcnQoJy4vYW5hbHlzaXMvYXVkaW9fYW5hbHlzaXMuanMnKS5BdWRpb0FuYWx5c2lzT3V0cHV0VHlwZX1cbiAgICovIGdldEZyZXF1ZW5jaWVzKGFuYWx5c2lzVHlwZSA9IFwiZnJlcXVlbmN5XCIsIG1pbkRlY2liZWxzID0gLTEwMCwgbWF4RGVjaWJlbHMgPSAtMzApIHtcbiAgICAgICAgaWYgKCF0aGlzLmFuYWx5c2VyKSB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgY29ubmVjdGVkLCBwbGVhc2UgY2FsbCAuY29ubmVjdCgpIGZpcnN0XCIpO1xuICAgICAgICByZXR1cm4gKDAsICRmMzJmMDY0NTY0ZWU2MmY2JGV4cG9ydCQyYzMxMzZkYTBiZjEzMGY5KS5nZXRGcmVxdWVuY2llcyh0aGlzLmFuYWx5c2VyLCB0aGlzLnNhbXBsZVJhdGUsIG51bGwsIGFuYWx5c2lzVHlwZSwgbWluRGVjaWJlbHMsIG1heERlY2liZWxzKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzcGVha2VyIGRldmljZUlkXG4gICAqLyBhc3luYyB1cGRhdGVTcGVha2VyKHNwZWFrZXIpIHtcbiAgICAgICAgY29uc3QgX3ByZXZTcGVha2VyID0gdGhpcy5fc3BlYWtlcklEO1xuICAgICAgICB0aGlzLl9zcGVha2VySUQgPSBzcGVha2VyO1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0KSB0cnkge1xuICAgICAgICAgICAgaWYgKHNwZWFrZXIgPT09IFwiZGVmYXVsdFwiKSBhd2FpdCB0aGlzLmNvbnRleHQuc2V0U2lua0lkKCk7XG4gICAgICAgICAgICBlbHNlIGF3YWl0IHRoaXMuY29udGV4dC5zZXRTaW5rSWQoc3BlYWtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkIG5vdCBzZXQgc2lua0lkIHRvICR7c3BlYWtlcn06ICR7ZX1gKTtcbiAgICAgICAgICAgIHRoaXMuX3NwZWFrZXJJRCA9IF9wcmV2U3BlYWtlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICogU3RhcnRzIGF1ZGlvIHN0cmVhbWluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx0cnVlPn1cbiAgICovIF9zdGFydCgpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtTm9kZSA9IG5ldyBBdWRpb1dvcmtsZXROb2RlKHRoaXMuY29udGV4dCwgXCJzdHJlYW1fcHJvY2Vzc29yXCIpO1xuICAgICAgICBzdHJlYW1Ob2RlLmNvbm5lY3QodGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgc3RyZWFtTm9kZS5wb3J0Lm9ubWVzc2FnZSA9IChlKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBldmVudDogZXZlbnQgfSA9IGUuZGF0YTtcbiAgICAgICAgICAgIGlmIChldmVudCA9PT0gXCJzdG9wXCIpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1Ob2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50ID09PSBcIm9mZnNldFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByZXF1ZXN0SWQ6IHJlcXVlc3RJZCwgdHJhY2tJZDogdHJhY2tJZCwgb2Zmc2V0OiBvZmZzZXQgfSA9IGUuZGF0YTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IG9mZnNldCAvIHRoaXMuc2FtcGxlUmF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrU2FtcGxlT2Zmc2V0c1tyZXF1ZXN0SWRdID0ge1xuICAgICAgICAgICAgICAgICAgICB0cmFja0lkOiB0cmFja0lkLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRpbWU6IGN1cnJlbnRUaW1lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hbmFseXNlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIHN0cmVhbU5vZGUuY29ubmVjdCh0aGlzLmFuYWx5c2VyKTtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW1Ob2RlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEFkZHMgMTZCaXRQQ00gZGF0YSB0byB0aGUgY3VycmVudGx5IHBsYXlpbmcgYXVkaW8gc3RyZWFtXG4gICAqIFlvdSBjYW4gYWRkIGNodW5rcyBiZXlvbmQgdGhlIGN1cnJlbnQgcGxheSBwb2ludCBhbmQgdGhleSB3aWxsIGJlIHF1ZXVlZCBmb3IgcGxheVxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfEludDE2QXJyYXl9IGFycmF5QnVmZmVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHJhY2tJZF1cbiAgICogQHJldHVybnMge0ludDE2QXJyYXl9XG4gICAqLyBhZGQxNkJpdFBDTShhcnJheUJ1ZmZlciwgdHJhY2tJZCA9IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHJhY2tJZCAhPT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IEVycm9yKGB0cmFja0lkIG11c3QgYmUgYSBzdHJpbmdgKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5pbnRlcnJ1cHRlZFRyYWNrSWRzW3RyYWNrSWRdKSByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5zdHJlYW0pIHRoaXMuX3N0YXJ0KCk7XG4gICAgICAgIGxldCBidWZmZXI7XG4gICAgICAgIGlmIChhcnJheUJ1ZmZlciBpbnN0YW5jZW9mIEludDE2QXJyYXkpIGJ1ZmZlciA9IGFycmF5QnVmZmVyO1xuICAgICAgICBlbHNlIGlmIChhcnJheUJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBidWZmZXIgPSBuZXcgSW50MTZBcnJheShhcnJheUJ1ZmZlcik7XG4gICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKGBhcmd1bWVudCBtdXN0IGJlIEludDE2QXJyYXkgb3IgQXJyYXlCdWZmZXJgKTtcbiAgICAgICAgdGhpcy5zdHJlYW0ucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBldmVudDogXCJ3cml0ZVwiLFxuICAgICAgICAgICAgYnVmZmVyOiBidWZmZXIsXG4gICAgICAgICAgICB0cmFja0lkOiB0cmFja0lkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbiAgICAvKipcbiAgICogR2V0cyB0aGUgb2Zmc2V0IChzYW1wbGUgY291bnQpIG9mIHRoZSBjdXJyZW50bHkgcGxheWluZyBzdHJlYW1cbiAgICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJydXB0XVxuICAgKiBAcmV0dXJucyB7e3RyYWNrSWQ6IHN0cmluZ3xudWxsLCBvZmZzZXQ6IG51bWJlciwgY3VycmVudFRpbWU6IG51bWJlcn19XG4gICAqLyBhc3luYyBnZXRUcmFja1NhbXBsZU9mZnNldChpbnRlcnJ1cHQgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMuc3RyZWFtKSByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgICAgICAgdGhpcy5zdHJlYW0ucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBldmVudDogaW50ZXJydXB0ID8gXCJpbnRlcnJ1cHRcIiA6IFwib2Zmc2V0XCIsXG4gICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHRyYWNrU2FtcGxlT2Zmc2V0O1xuICAgICAgICB3aGlsZSghdHJhY2tTYW1wbGVPZmZzZXQpe1xuICAgICAgICAgICAgdHJhY2tTYW1wbGVPZmZzZXQgPSB0aGlzLnRyYWNrU2FtcGxlT2Zmc2V0c1tyZXF1ZXN0SWRdO1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHIpPT5zZXRUaW1lb3V0KCgpPT5yKCksIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHRyYWNrSWQ6IHRyYWNrSWQgfSA9IHRyYWNrU2FtcGxlT2Zmc2V0O1xuICAgICAgICBpZiAoaW50ZXJydXB0ICYmIHRyYWNrSWQpIHRoaXMuaW50ZXJydXB0ZWRUcmFja0lkc1t0cmFja0lkXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cmFja1NhbXBsZU9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFN0cmlwcyB0aGUgY3VycmVudCBzdHJlYW0gYW5kIHJldHVybnMgdGhlIHNhbXBsZSBvZmZzZXQgb2YgdGhlIGF1ZGlvXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVycnVwdF1cbiAgICogQHJldHVybnMge3t0cmFja0lkOiBzdHJpbmd8bnVsbCwgb2Zmc2V0OiBudW1iZXIsIGN1cnJlbnRUaW1lOiBudW1iZXJ9fVxuICAgKi8gYXN5bmMgaW50ZXJydXB0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUcmFja1NhbXBsZU9mZnNldCh0cnVlKTtcbiAgICB9XG59XG5nbG9iYWxUaGlzLldhdlN0cmVhbVBsYXllciA9ICRkMGE5Njk4MzM5NThkOWU3JGV4cG9ydCQ5Njk4ZDYyYzc4YjhmMzY2O1xuXG5cbmNvbnN0ICQ4ZTFkMWU2ZmYwOGY2ZmI1JHZhciRBdWRpb1Byb2Nlc3NvcldvcmtsZXQgPSBgXG5jbGFzcyBBdWRpb1Byb2Nlc3NvciBleHRlbmRzIEF1ZGlvV29ya2xldFByb2Nlc3NvciB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnBvcnQub25tZXNzYWdlID0gdGhpcy5yZWNlaXZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cblxuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZm91bmRBdWRpbyA9IGZhbHNlO1xuICAgIHRoaXMucmVjb3JkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25jYXRlbmF0ZXMgc2FtcGxlZCBjaHVua3MgaW50byBjaGFubmVsc1xuICAgKiBGb3JtYXQgaXMgY2h1bmtbTGVmdFtdLCBSaWdodFtdXVxuICAgKi9cbiAgcmVhZENoYW5uZWxEYXRhKGNodW5rcywgY2hhbm5lbCA9IC0xLCBtYXhDaGFubmVscyA9IDkpIHtcbiAgICBsZXQgY2hhbm5lbExpbWl0O1xuICAgIGlmIChjaGFubmVsICE9PSAtMSkge1xuICAgICAgaWYgKGNodW5rc1swXSAmJiBjaHVua3NbMF0ubGVuZ3RoIC0gMSA8IGNoYW5uZWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFxcYENoYW5uZWwgXFwke2NoYW5uZWx9IG91dCBvZiByYW5nZTogbWF4IFxcJHtjaHVua3NbMF0ubGVuZ3RofVxcYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hhbm5lbExpbWl0ID0gY2hhbm5lbCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYW5uZWwgPSAwO1xuICAgICAgY2hhbm5lbExpbWl0ID0gTWF0aC5taW4oY2h1bmtzWzBdID8gY2h1bmtzWzBdLmxlbmd0aCA6IDEsIG1heENoYW5uZWxzKTtcbiAgICB9XG4gICAgY29uc3QgY2hhbm5lbHMgPSBbXTtcbiAgICBmb3IgKGxldCBuID0gY2hhbm5lbDsgbiA8IGNoYW5uZWxMaW1pdDsgbisrKSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBjaHVua3MucmVkdWNlKChzdW0sIGNodW5rKSA9PiB7XG4gICAgICAgIHJldHVybiBzdW0gKyBjaHVua1tuXS5sZW5ndGg7XG4gICAgICB9LCAwKTtcbiAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBjaHVua3MubWFwKChjaHVuaykgPT4gY2h1bmtbbl0pO1xuICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShsZW5ndGgpO1xuICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnNldChidWZmZXJzW2ldLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gYnVmZmVyc1tpXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBjaGFubmVsc1tuXSA9IHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5uZWxzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbWJpbmVzIHBhcmFsbGVsIGF1ZGlvIGRhdGEgaW50byBjb3JyZWN0IGZvcm1hdCxcbiAgICogY2hhbm5lbHNbTGVmdFtdLCBSaWdodFtdXSB0byBmbG9hdDMyQXJyYXlbTFJMUkxSTFIuLi5dXG4gICAqL1xuICBmb3JtYXRBdWRpb0RhdGEoY2hhbm5lbHMpIHtcbiAgICBpZiAoY2hhbm5lbHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBTaW1wbGUgY2FzZSBpcyBvbmx5IG9uZSBjaGFubmVsXG4gICAgICBjb25zdCBmbG9hdDMyQXJyYXkgPSBjaGFubmVsc1swXS5zbGljZSgpO1xuICAgICAgY29uc3QgbWVhblZhbHVlcyA9IGNoYW5uZWxzWzBdLnNsaWNlKCk7XG4gICAgICByZXR1cm4geyBmbG9hdDMyQXJyYXksIG1lYW5WYWx1ZXMgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShcbiAgICAgICAgY2hhbm5lbHNbMF0ubGVuZ3RoICogY2hhbm5lbHMubGVuZ3RoXG4gICAgICApO1xuICAgICAgY29uc3QgbWVhblZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoY2hhbm5lbHNbMF0ubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbm5lbHNbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaSAqIGNoYW5uZWxzLmxlbmd0aDtcbiAgICAgICAgbGV0IG1lYW5WYWx1ZSA9IDA7XG4gICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgY2hhbm5lbHMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICBmbG9hdDMyQXJyYXlbb2Zmc2V0ICsgbl0gPSBjaGFubmVsc1tuXVtpXTtcbiAgICAgICAgICBtZWFuVmFsdWUgKz0gY2hhbm5lbHNbbl1baV07XG4gICAgICAgIH1cbiAgICAgICAgbWVhblZhbHVlc1tpXSA9IG1lYW5WYWx1ZSAvIGNoYW5uZWxzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGZsb2F0MzJBcnJheSwgbWVhblZhbHVlcyB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyAzMi1iaXQgZmxvYXQgZGF0YSB0byAxNi1iaXQgaW50ZWdlcnNcbiAgICovXG4gIGZsb2F0VG8xNkJpdFBDTShmbG9hdDMyQXJyYXkpIHtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoZmxvYXQzMkFycmF5Lmxlbmd0aCAqIDIpO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZsb2F0MzJBcnJheS5sZW5ndGg7IGkrKywgb2Zmc2V0ICs9IDIpIHtcbiAgICAgIGxldCBzID0gTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIGZsb2F0MzJBcnJheVtpXSkpO1xuICAgICAgdmlldy5zZXRJbnQxNihvZmZzZXQsIHMgPCAwID8gcyAqIDB4ODAwMCA6IHMgKiAweDdmZmYsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgbW9zdCByZWNlbnQgYW1wbGl0dWRlIHZhbHVlcyBmcm9tIHRoZSBhdWRpbyBzdHJlYW1cbiAgICogQHBhcmFtIHtudW1iZXJ9IGNoYW5uZWxcbiAgICovXG4gIGdldFZhbHVlcyhjaGFubmVsID0gLTEpIHtcbiAgICBjb25zdCBjaGFubmVscyA9IHRoaXMucmVhZENoYW5uZWxEYXRhKHRoaXMuY2h1bmtzLCBjaGFubmVsKTtcbiAgICBjb25zdCB7IG1lYW5WYWx1ZXMgfSA9IHRoaXMuZm9ybWF0QXVkaW9EYXRhKGNoYW5uZWxzKTtcbiAgICByZXR1cm4geyBtZWFuVmFsdWVzLCBjaGFubmVscyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9ydHMgY2h1bmtzIGFzIGFuIGF1ZGlvL3dhdiBmaWxlXG4gICAqL1xuICBleHBvcnQoKSB7XG4gICAgY29uc3QgY2hhbm5lbHMgPSB0aGlzLnJlYWRDaGFubmVsRGF0YSh0aGlzLmNodW5rcyk7XG4gICAgY29uc3QgeyBmbG9hdDMyQXJyYXksIG1lYW5WYWx1ZXMgfSA9IHRoaXMuZm9ybWF0QXVkaW9EYXRhKGNoYW5uZWxzKTtcbiAgICBjb25zdCBhdWRpb0RhdGEgPSB0aGlzLmZsb2F0VG8xNkJpdFBDTShmbG9hdDMyQXJyYXkpO1xuICAgIHJldHVybiB7XG4gICAgICBtZWFuVmFsdWVzOiBtZWFuVmFsdWVzLFxuICAgICAgYXVkaW86IHtcbiAgICAgICAgYml0c1BlclNhbXBsZTogMTYsXG4gICAgICAgIGNoYW5uZWxzOiBjaGFubmVscyxcbiAgICAgICAgZGF0YTogYXVkaW9EYXRhLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgcmVjZWl2ZShlKSB7XG4gICAgY29uc3QgeyBldmVudCwgaWQgfSA9IGUuZGF0YTtcbiAgICBsZXQgcmVjZWlwdERhdGEgPSB7fTtcbiAgICBzd2l0Y2ggKGV2ZW50KSB7XG4gICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgIHRoaXMucmVjb3JkaW5nID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdG9wJzpcbiAgICAgICAgdGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjbGVhcic6XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2V4cG9ydCc6XG4gICAgICAgIHJlY2VpcHREYXRhID0gdGhpcy5leHBvcnQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZWFkJzpcbiAgICAgICAgcmVjZWlwdERhdGEgPSB0aGlzLmdldFZhbHVlcygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBBbHdheXMgc2VuZCBiYWNrIHJlY2VpcHRcbiAgICB0aGlzLnBvcnQucG9zdE1lc3NhZ2UoeyBldmVudDogJ3JlY2VpcHQnLCBpZCwgZGF0YTogcmVjZWlwdERhdGEgfSk7XG4gIH1cblxuICBzZW5kQ2h1bmsoY2h1bmspIHtcbiAgICBjb25zdCBjaGFubmVscyA9IHRoaXMucmVhZENoYW5uZWxEYXRhKFtjaHVua10pO1xuICAgIGNvbnN0IHsgZmxvYXQzMkFycmF5LCBtZWFuVmFsdWVzIH0gPSB0aGlzLmZvcm1hdEF1ZGlvRGF0YShjaGFubmVscyk7XG4gICAgY29uc3QgcmF3QXVkaW9EYXRhID0gdGhpcy5mbG9hdFRvMTZCaXRQQ00oZmxvYXQzMkFycmF5KTtcbiAgICBjb25zdCBtb25vQXVkaW9EYXRhID0gdGhpcy5mbG9hdFRvMTZCaXRQQ00obWVhblZhbHVlcyk7XG4gICAgdGhpcy5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgIGV2ZW50OiAnY2h1bmsnLFxuICAgICAgZGF0YToge1xuICAgICAgICBtb25vOiBtb25vQXVkaW9EYXRhLFxuICAgICAgICByYXc6IHJhd0F1ZGlvRGF0YSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBwcm9jZXNzKGlucHV0TGlzdCwgb3V0cHV0TGlzdCwgcGFyYW1ldGVycykge1xuICAgIC8vIENvcHkgaW5wdXQgdG8gb3V0cHV0IChlLmcuIHNwZWFrZXJzKVxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGNyZWF0ZXMgY2hvcHB5IHNvdW5kcyB3aXRoIE1hYyBwcm9kdWN0c1xuICAgIGNvbnN0IHNvdXJjZUxpbWl0ID0gTWF0aC5taW4oaW5wdXRMaXN0Lmxlbmd0aCwgb3V0cHV0TGlzdC5sZW5ndGgpO1xuICAgIGZvciAobGV0IGlucHV0TnVtID0gMDsgaW5wdXROdW0gPCBzb3VyY2VMaW1pdDsgaW5wdXROdW0rKykge1xuICAgICAgY29uc3QgaW5wdXQgPSBpbnB1dExpc3RbaW5wdXROdW1dO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0TGlzdFtpbnB1dE51bV07XG4gICAgICBjb25zdCBjaGFubmVsQ291bnQgPSBNYXRoLm1pbihpbnB1dC5sZW5ndGgsIG91dHB1dC5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgY2hhbm5lbE51bSA9IDA7IGNoYW5uZWxOdW0gPCBjaGFubmVsQ291bnQ7IGNoYW5uZWxOdW0rKykge1xuICAgICAgICBpbnB1dFtjaGFubmVsTnVtXS5mb3JFYWNoKChzYW1wbGUsIGkpID0+IHtcbiAgICAgICAgICBvdXRwdXRbY2hhbm5lbE51bV1baV0gPSBzYW1wbGU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbnB1dHMgPSBpbnB1dExpc3RbMF07XG4gICAgLy8gVGhlcmUncyBsYXRlbmN5IGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBzdHJlYW0gYmVmb3JlIHJlY29yZGluZyBzdGFydHNcbiAgICAvLyBNYWtlIHN1cmUgd2UgYWN0dWFsbHkgcmVjZWl2ZSBhdWRpbyBkYXRhIGJlZm9yZSB3ZSBzdGFydCBzdG9yaW5nIGNodW5rc1xuICAgIGxldCBzbGljZUluZGV4ID0gMDtcbiAgICBpZiAoIXRoaXMuZm91bmRBdWRpbykge1xuICAgICAgZm9yIChjb25zdCBjaGFubmVsIG9mIGlucHV0cykge1xuICAgICAgICBzbGljZUluZGV4ID0gMDsgLy8gcmVzZXQgZm9yIGVhY2ggY2hhbm5lbFxuICAgICAgICBpZiAodGhpcy5mb3VuZEF1ZGlvKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGNoYW5uZWwpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAvLyBmaW5kIG9ubHkgb25lIG5vbi16ZXJvIGVudHJ5IGluIGFueSBjaGFubmVsXG4gICAgICAgICAgICAgIHRoaXMuZm91bmRBdWRpbyA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2xpY2VJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5wdXRzICYmIGlucHV0c1swXSAmJiB0aGlzLmZvdW5kQXVkaW8gJiYgdGhpcy5yZWNvcmRpbmcpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY29weSB0aGUgVHlwZWRBcnJheSwgYmVjYXVzZSB0aGUgXFxgcHJvY2Vzc1xcYFxuICAgICAgLy8gaW50ZXJuYWxzIHdpbGwgcmV1c2UgdGhlIHNhbWUgYnVmZmVyIHRvIGhvbGQgZWFjaCBpbnB1dFxuICAgICAgY29uc3QgY2h1bmsgPSBpbnB1dHMubWFwKChpbnB1dCkgPT4gaW5wdXQuc2xpY2Uoc2xpY2VJbmRleCkpO1xuICAgICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG4gICAgICB0aGlzLnNlbmRDaHVuayhjaHVuayk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbnJlZ2lzdGVyUHJvY2Vzc29yKCdhdWRpb19wcm9jZXNzb3InLCBBdWRpb1Byb2Nlc3Nvcik7XG5gO1xuY29uc3QgJDhlMWQxZTZmZjA4ZjZmYjUkdmFyJHNjcmlwdCA9IG5ldyBCbG9iKFtcbiAgICAkOGUxZDFlNmZmMDhmNmZiNSR2YXIkQXVkaW9Qcm9jZXNzb3JXb3JrbGV0XG5dLCB7XG4gICAgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnXG59KTtcbmNvbnN0ICQ4ZTFkMWU2ZmYwOGY2ZmI1JHZhciRzcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKCQ4ZTFkMWU2ZmYwOGY2ZmI1JHZhciRzY3JpcHQpO1xuY29uc3QgJDhlMWQxZTZmZjA4ZjZmYjUkZXhwb3J0JDFmNjVmNTBhOGNiZmY0M2MgPSAkOGUxZDFlNmZmMDhmNmZiNSR2YXIkc3JjO1xuXG5cblxuXG5jbGFzcyAkNjJiYzM3NjA0NGEwNTUxMyRleHBvcnQkNDM5YjIxN2NhNjU5YTg3NyB7XG4gICAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBXYXZSZWNvcmRlciBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3tzYW1wbGVSYXRlPzogbnVtYmVyLCBvdXRwdXRUb1NwZWFrZXJzPzogYm9vbGVhbiwgZGVidWc/OiBib29sZWFufX0gW29wdGlvbnNdXG4gICAqIEByZXR1cm5zIHtXYXZSZWNvcmRlcn1cbiAgICovIGNvbnN0cnVjdG9yKHsgc2FtcGxlUmF0ZTogc2FtcGxlUmF0ZSA9IDQ0MTAwLCBvdXRwdXRUb1NwZWFrZXJzOiBvdXRwdXRUb1NwZWFrZXJzID0gZmFsc2UsIGRlYnVnOiBkZWJ1ZyA9IGZhbHNlIH0gPSB7fSl7XG4gICAgICAgIC8vIFNjcmlwdCBzb3VyY2VcbiAgICAgICAgdGhpcy5zY3JpcHRTcmMgPSAoMCwgJDhlMWQxZTZmZjA4ZjZmYjUkZXhwb3J0JDFmNjVmNTBhOGNiZmY0M2MpO1xuICAgICAgICAvLyBDb25maWdcbiAgICAgICAgdGhpcy5zYW1wbGVSYXRlID0gc2FtcGxlUmF0ZTtcbiAgICAgICAgdGhpcy5vdXRwdXRUb1NwZWFrZXJzID0gb3V0cHV0VG9TcGVha2VycztcbiAgICAgICAgdGhpcy5kZWJ1ZyA9ICEhZGVidWc7XG4gICAgICAgIHRoaXMuX2RldmljZUNoYW5nZUNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZGV2aWNlcyA9IFtdO1xuICAgICAgICB0aGlzLmRldmljZVNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIC8vIFN0YXRlIHZhcmlhYmxlc1xuICAgICAgICB0aGlzLnN0cmVhbSA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gbnVsbDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICAgICAgICB0aGlzLm5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLnJlY29yZGluZyA9IGZhbHNlO1xuICAgICAgICAvLyBFdmVudCBoYW5kbGluZyB3aXRoIEF1ZGlvV29ya2xldFxuICAgICAgICB0aGlzLl9sYXN0RXZlbnRJZCA9IDA7XG4gICAgICAgIHRoaXMuZXZlbnRSZWNlaXB0cyA9IHt9O1xuICAgICAgICB0aGlzLmV2ZW50VGltZW91dCA9IDUwMDA7XG4gICAgICAgIC8vIFByb2Nlc3MgY2h1bmtzIG9mIGF1ZGlvXG4gICAgICAgIHRoaXMuX2NodW5rUHJvY2Vzc29yID0gKCk9Pnt9O1xuICAgICAgICB0aGlzLl9jaHVua1Byb2Nlc3NvclNpemUgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuX2NodW5rUHJvY2Vzc29yQnVmZmVyID0ge1xuICAgICAgICAgICAgcmF3OiBuZXcgQXJyYXlCdWZmZXIoMCksXG4gICAgICAgICAgICBtb25vOiBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAqIERlY29kZXMgYXVkaW8gZGF0YSBmcm9tIG11bHRpcGxlIGZvcm1hdHMgdG8gYSBCbG9iLCB1cmwsIEZsb2F0MzJBcnJheSBhbmQgQXVkaW9CdWZmZXJcbiAgICogQHBhcmFtIHtCbG9ifEZsb2F0MzJBcnJheXxJbnQxNkFycmF5fEFycmF5QnVmZmVyfG51bWJlcltdfSBhdWRpb0RhdGFcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsZVJhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21TYW1wbGVSYXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPERlY29kZWRBdWRpb1R5cGU+fVxuICAgKi8gc3RhdGljIGFzeW5jIGRlY29kZShhdWRpb0RhdGEsIHNhbXBsZVJhdGUgPSA0NDEwMCwgZnJvbVNhbXBsZVJhdGUgPSAtMSkge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCh7XG4gICAgICAgICAgICBzYW1wbGVSYXRlOiBzYW1wbGVSYXRlXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgYXJyYXlCdWZmZXI7XG4gICAgICAgIGxldCBibG9iO1xuICAgICAgICBpZiAoYXVkaW9EYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgaWYgKGZyb21TYW1wbGVSYXRlICE9PSAtMSkgdGhyb3cgbmV3IEVycm9yKGBDYW4gbm90IHNwZWNpZnkgXCJmcm9tU2FtcGxlUmF0ZVwiIHdoZW4gcmVhZGluZyBmcm9tIEJsb2JgKTtcbiAgICAgICAgICAgIGJsb2IgPSBhdWRpb0RhdGE7XG4gICAgICAgICAgICBhcnJheUJ1ZmZlciA9IGF3YWl0IGJsb2IuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgfSBlbHNlIGlmIChhdWRpb0RhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgaWYgKGZyb21TYW1wbGVSYXRlICE9PSAtMSkgdGhyb3cgbmV3IEVycm9yKGBDYW4gbm90IHNwZWNpZnkgXCJmcm9tU2FtcGxlUmF0ZVwiIHdoZW4gcmVhZGluZyBmcm9tIEFycmF5QnVmZmVyYCk7XG4gICAgICAgICAgICBhcnJheUJ1ZmZlciA9IGF1ZGlvRGF0YTtcbiAgICAgICAgICAgIGJsb2IgPSBuZXcgQmxvYihbXG4gICAgICAgICAgICAgICAgYXJyYXlCdWZmZXJcbiAgICAgICAgICAgIF0sIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYXVkaW8vd2F2J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZmxvYXQzMkFycmF5O1xuICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICBpZiAoYXVkaW9EYXRhIGluc3RhbmNlb2YgSW50MTZBcnJheSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBhdWRpb0RhdGE7XG4gICAgICAgICAgICAgICAgZmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShhdWRpb0RhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgYXVkaW9EYXRhLmxlbmd0aDsgaSsrKWZsb2F0MzJBcnJheVtpXSA9IGF1ZGlvRGF0YVtpXSAvIDB4ODAwMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXVkaW9EYXRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSBmbG9hdDMyQXJyYXkgPSBhdWRpb0RhdGE7XG4gICAgICAgICAgICBlbHNlIGlmIChhdWRpb0RhdGEgaW5zdGFuY2VvZiBBcnJheSkgZmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShhdWRpb0RhdGEpO1xuICAgICAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFwiYXVkaW9EYXRhXCIgbXVzdCBiZSBvbmUgb2Y6IEJsb2IsIEZsb2F0MzJBcnJyYXksIEludDE2QXJyYXksIEFycmF5QnVmZmVyLCBBcnJheTxudW1iZXI+YCk7XG4gICAgICAgICAgICBpZiAoZnJvbVNhbXBsZVJhdGUgPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoYE11c3Qgc3BlY2lmeSBcImZyb21TYW1wbGVSYXRlXCIgd2hlbiByZWFkaW5nIGZyb20gRmxvYXQzMkFycmF5LCBJbjE2QXJyYXkgb3IgQXJyYXlgKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZyb21TYW1wbGVSYXRlIDwgMzAwMCkgdGhyb3cgbmV3IEVycm9yKGBNaW5pbXVtIFwiZnJvbVNhbXBsZVJhdGVcIiBpcyAzMDAwICgza0h6KWApO1xuICAgICAgICAgICAgaWYgKCFkYXRhKSBkYXRhID0gKDAsICQ2ZDRiNzQ0OWExZTE1NDRhJGV4cG9ydCQxM2FmZGEyMzdiMWM5ODQ2KS5mbG9hdFRvMTZCaXRQQ00oZmxvYXQzMkFycmF5KTtcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvID0ge1xuICAgICAgICAgICAgICAgIGJpdHNQZXJTYW1wbGU6IDE2LFxuICAgICAgICAgICAgICAgIGNoYW5uZWxzOiBbXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0MzJBcnJheVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHBhY2tlciA9IG5ldyAoMCwgJDZkNGI3NDQ5YTFlMTU0NGEkZXhwb3J0JDEzYWZkYTIzN2IxYzk4NDYpKCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwYWNrZXIucGFjayhmcm9tU2FtcGxlUmF0ZSwgYXVkaW8pO1xuICAgICAgICAgICAgYmxvYiA9IHJlc3VsdC5ibG9iO1xuICAgICAgICAgICAgYXJyYXlCdWZmZXIgPSBhd2FpdCBibG9iLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXVkaW9CdWZmZXIgPSBhd2FpdCBjb250ZXh0LmRlY29kZUF1ZGlvRGF0YShhcnJheUJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGF1ZGlvQnVmZmVyLmdldENoYW5uZWxEYXRhKDApO1xuICAgICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmxvYjogYmxvYixcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgICAgICBhdWRpb0J1ZmZlcjogYXVkaW9CdWZmZXJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAqIExvZ3MgZGF0YSBpbiBkZWJ1ZyBtb2RlXG4gICAqIEBwYXJhbSB7Li4uYW55fSBhcmd1bWVudHNcbiAgICogQHJldHVybnMge3RydWV9XG4gICAqLyBsb2coKSB7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB0aGlzLmxvZyguLi5hcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBzYW1wbGVSYXRlIGZvciB0aGUgcmVjb3JkZXJcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovIGdldFNhbXBsZVJhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhbXBsZVJhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSByZWNvcmRpbmdcbiAgICogQHJldHVybnMge1wiZW5kZWRcInxcInBhdXNlZFwifFwicmVjb3JkaW5nXCJ9XG4gICAqLyBnZXRTdGF0dXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9jZXNzb3IpIHJldHVybiAnZW5kZWQnO1xuICAgICAgICBlbHNlIGlmICghdGhpcy5yZWNvcmRpbmcpIHJldHVybiAncGF1c2VkJztcbiAgICAgICAgZWxzZSByZXR1cm4gJ3JlY29yZGluZyc7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTZW5kcyBhbiBldmVudCB0byB0aGUgQXVkaW9Xb3JrbGV0XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7e1trZXk6IHN0cmluZ106IGFueX19IGRhdGFcbiAgICogQHBhcmFtIHtBdWRpb1dvcmtsZXROb2RlfSBbX3Byb2Nlc3Nvcl1cbiAgICogQHJldHVybnMge1Byb21pc2U8e1trZXk6IHN0cmluZ106IGFueX0+fVxuICAgKi8gYXN5bmMgX2V2ZW50KG5hbWUsIGRhdGEgPSB7fSwgX3Byb2Nlc3NvciA9IG51bGwpIHtcbiAgICAgICAgX3Byb2Nlc3NvciA9IF9wcm9jZXNzb3IgfHwgdGhpcy5wcm9jZXNzb3I7XG4gICAgICAgIGlmICghX3Byb2Nlc3NvcikgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IHNlbmQgZXZlbnRzIHdpdGhvdXQgcmVjb3JkaW5nIGZpcnN0Jyk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBldmVudDogbmFtZSxcbiAgICAgICAgICAgIGlkOiB0aGlzLl9sYXN0RXZlbnRJZCsrLFxuICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICB9O1xuICAgICAgICBfcHJvY2Vzc29yLnBvcnQucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHQwID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgIHdoaWxlKCF0aGlzLmV2ZW50UmVjZWlwdHNbbWVzc2FnZS5pZF0pe1xuICAgICAgICAgICAgaWYgKG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdDAgPiB0aGlzLmV2ZW50VGltZW91dCkgdGhyb3cgbmV3IEVycm9yKGBUaW1lb3V0IHdhaXRpbmcgZm9yIFwiJHtuYW1lfVwiIGV2ZW50YCk7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzKT0+c2V0VGltZW91dCgoKT0+cmVzKHRydWUpLCAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuZXZlbnRSZWNlaXB0c1ttZXNzYWdlLmlkXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZXZlbnRSZWNlaXB0c1ttZXNzYWdlLmlkXTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTZXRzIGRldmljZSBjaGFuZ2UgY2FsbGJhY2ssIHJlbW92ZSBpZiBjYWxsYmFjayBwcm92aWRlZCBpcyBgbnVsbGBcbiAgICogQHBhcmFtIHsoQXJyYXk8TWVkaWFEZXZpY2VJbmZvICYge2RlZmF1bHQ6IGJvb2xlYW59Pik6IHZvaWR8bnVsbH0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3RydWV9XG4gICAqLyBsaXN0ZW5Gb3JEZXZpY2VDaGFuZ2UoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrID09PSBudWxsICYmIHRoaXMuX2RldmljZUNoYW5nZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RldmljZWNoYW5nZScsIHRoaXMuX2RldmljZUNoYW5nZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIHRoaXMuX2RldmljZUNoYW5nZUNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQmFzaWNhbGx5IGEgZGVib3VuY2U7IHdlIG9ubHkgd2FudCB0aGlzIGNhbGxlZCBvbmNlIHdoZW4gZGV2aWNlcyBjaGFuZ2VcbiAgICAgICAgICAgIC8vIEFuZCB3ZSBvbmx5IHdhbnQgdGhlIG1vc3QgcmVjZW50IGNhbGxiYWNrKCkgdG8gYmUgZXhlY3V0ZWRcbiAgICAgICAgICAgIC8vIGlmIGEgZmV3IGFyZSBvcGVyYXRpbmcgYXQgdGhlIHNhbWUgdGltZVxuICAgICAgICAgICAgbGV0IGxhc3RJZCA9IDA7XG4gICAgICAgICAgICBsZXQgbGFzdERldmljZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZURldmljZXMgPSAoZGV2aWNlcyk9PmRldmljZXMubWFwKChkKT0+ZC5kZXZpY2VJZCkuc29ydCgpLmpvaW4oJywnKTtcbiAgICAgICAgICAgIGNvbnN0IGNiID0gYXN5bmMgKCk9PntcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSArK2xhc3RJZDtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXZpY2VzID0gYXdhaXQgdGhpcy5saXN0RGV2aWNlcygpO1xuICAgICAgICAgICAgICAgIGlmIChpZCA9PT0gbGFzdElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXJpYWxpemVEZXZpY2VzKGxhc3REZXZpY2VzKSAhPT0gc2VyaWFsaXplRGV2aWNlcyhkZXZpY2VzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdERldmljZXMgPSBkZXZpY2VzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZGV2aWNlcy5zbGljZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZWNoYW5nZScsIGNiKTtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB0aGlzLl9kZXZpY2VDaGFuZ2VDYWxsYmFjayA9IGNiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICogTWFudWFsbHkgcmVxdWVzdCBwZXJtaXNzaW9uIHRvIHVzZSB0aGUgbWljcm9waG9uZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx0cnVlPn1cbiAgICovIGFzeW5jIHJlcXVlc3RQZXJtaXNzaW9uKCkge1xuICAgICAgICBjb25zdCBwZXJtaXNzaW9uU3RhdHVzID0gYXdhaXQgbmF2aWdhdG9yLnBlcm1pc3Npb25zLnF1ZXJ5KHtcbiAgICAgICAgICAgIG5hbWU6ICdtaWNyb3Bob25lJ1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBlcm1pc3Npb25TdGF0dXMuc3RhdGUgPT09ICdkZW5pZWQnKSB3aW5kb3cuYWxlcnQoJ1lvdSBtdXN0IGdyYW50IG1pY3JvcGhvbmUgYWNjZXNzIHRvIHVzZSB0aGlzIGZlYXR1cmUuJyk7XG4gICAgICAgIGVsc2UgaWYgKHBlcm1pc3Npb25TdGF0dXMuc3RhdGUgPT09ICdwcm9tcHQnKSB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xuICAgICAgICAgICAgICAgIGF1ZGlvOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrcyA9IHN0cmVhbS5nZXRUcmFja3MoKTtcbiAgICAgICAgICAgIHRyYWNrcy5mb3JFYWNoKCh0cmFjayk9PnRyYWNrLnN0b3AoKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hbGVydCgnWW91IG11c3QgZ3JhbnQgbWljcm9waG9uZSBhY2Nlc3MgdG8gdXNlIHRoaXMgZmVhdHVyZS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAqIExpc3QgYWxsIGVsaWdpYmxlIGRldmljZXMgZm9yIHJlY29yZGluZywgd2lsbCByZXF1ZXN0IHBlcm1pc3Npb24gdG8gdXNlIG1pY3JvcGhvbmVcbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8TWVkaWFEZXZpY2VJbmZvICYge2RlZmF1bHQ6IGJvb2xlYW59Pj59XG4gICAqLyBhc3luYyBsaXN0RGV2aWNlcygpIHtcbiAgICAgICAgaWYgKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzIHx8ICEoJ2VudW1lcmF0ZURldmljZXMnIGluIG5hdmlnYXRvci5tZWRpYURldmljZXMpKSB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCByZXF1ZXN0IHVzZXIgZGV2aWNlcycpO1xuICAgICAgICBhd2FpdCB0aGlzLnJlcXVlc3RQZXJtaXNzaW9uKCk7XG4gICAgICAgIGNvbnN0IGRldmljZXMgPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICAgICAgY29uc3QgYXVkaW9EZXZpY2VzID0gZGV2aWNlcy5maWx0ZXIoKGRldmljZSk9PmRldmljZS5raW5kID09PSAnYXVkaW9pbnB1dCcpO1xuICAgICAgICByZXR1cm4gYXVkaW9EZXZpY2VzO1xuICAgIC8vIGNvbnN0IGRlZmF1bHREZXZpY2VJbmRleCA9IGF1ZGlvRGV2aWNlcy5maW5kSW5kZXgoXG4gICAgLy8gICAoZGV2aWNlKSA9PiBkZXZpY2UuZGV2aWNlSWQgPT09ICdkZWZhdWx0J1xuICAgIC8vICk7XG4gICAgLy8gY29uc3QgZGV2aWNlTGlzdCA9IFtdO1xuICAgIC8vIGlmIChkZWZhdWx0RGV2aWNlSW5kZXggIT09IC0xKSB7XG4gICAgLy8gICBsZXQgZGVmYXVsdERldmljZSA9IGF1ZGlvRGV2aWNlcy5zcGxpY2UoZGVmYXVsdERldmljZUluZGV4LCAxKVswXTtcbiAgICAvLyAgIGxldCBleGlzdGluZ0luZGV4ID0gYXVkaW9EZXZpY2VzLmZpbmRJbmRleChcbiAgICAvLyAgICAgKGRldmljZSkgPT4gZGV2aWNlLmdyb3VwSWQgPT09IGRlZmF1bHREZXZpY2UuZ3JvdXBJZFxuICAgIC8vICAgKTtcbiAgICAvLyAgIGlmIChleGlzdGluZ0luZGV4ICE9PSAtMSkge1xuICAgIC8vICAgICBkZWZhdWx0RGV2aWNlID0gYXVkaW9EZXZpY2VzLnNwbGljZShleGlzdGluZ0luZGV4LCAxKVswXTtcbiAgICAvLyAgIH1cbiAgICAvLyAgIGRlZmF1bHREZXZpY2UuZGVmYXVsdCA9IHRydWU7XG4gICAgLy8gICBkZXZpY2VMaXN0LnB1c2goZGVmYXVsdERldmljZSk7XG4gICAgLy8gfVxuICAgIC8vIHJldHVybiBkZXZpY2VMaXN0LmNvbmNhdChhdWRpb0RldmljZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICogQmVnaW5zIGEgcmVjb3JkaW5nIHNlc3Npb24gYW5kIHJlcXVlc3RzIG1pY3JvcGhvbmUgcGVybWlzc2lvbnMgaWYgbm90IGFscmVhZHkgZ3JhbnRlZFxuICAgKiBNaWNyb3Bob25lIHJlY29yZGluZyBpbmRpY2F0b3Igd2lsbCBhcHBlYXIgb24gYnJvd3NlciB0YWIgYnV0IHN0YXR1cyB3aWxsIGJlIFwicGF1c2VkXCJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkZXZpY2VJZF0gaWYgbm8gZGV2aWNlIHByb3ZpZGVkLCBkZWZhdWx0IGRldmljZSB3aWxsIGJlIHVzZWRcbiAgICogQHJldHVybnMge1Byb21pc2U8dHJ1ZT59XG4gICAqLyBhc3luYyBiZWdpbihkZXZpY2VJZCkge1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzb3IpIHRocm93IG5ldyBFcnJvcihgQWxyZWFkeSBjb25uZWN0ZWQ6IHBsZWFzZSBjYWxsIC5lbmQoKSB0byBzdGFydCBhIG5ldyBzZXNzaW9uYCk7XG4gICAgICAgIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyB8fCAhKCdnZXRVc2VyTWVkaWEnIGluIG5hdmlnYXRvci5tZWRpYURldmljZXMpKSB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCByZXF1ZXN0IHVzZXIgbWVkaWEnKTtcbiAgICAgICAgZGV2aWNlSWQgPSBkZXZpY2VJZCA/PyB0aGlzLmRldmljZVNlbGVjdGlvbj8uZGV2aWNlSWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgYXVkaW86IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZGV2aWNlSWQpIGNvbmZpZy5hdWRpbyA9IHtcbiAgICAgICAgICAgICAgICBkZXZpY2VJZDoge1xuICAgICAgICAgICAgICAgICAgICBleGFjdDogZGV2aWNlSWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25maWcpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHN0YXJ0IG1lZGlhIHN0cmVhbScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlzdERldmljZXMoKS50aGVuKChkZXZpY2VzKT0+e1xuICAgICAgICAgICAgZGV2aWNlSWQgPSB0aGlzLnN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdLmdldFNldHRpbmdzKCkuZGV2aWNlSWQ7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZmluZCBjdXJyZW50IGRldmljZScsIGRldmljZXMsIGRldmljZUlkLCB0aGlzLnN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdLmdldFNldHRpbmdzKCkpO1xuICAgICAgICAgICAgdGhpcy5kZXZpY2VTZWxlY3Rpb24gPSBkZXZpY2VzLmZpbmQoKGQpPT5kLmRldmljZUlkID09PSBkZXZpY2VJZCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnY3VycmVudCBkZXZpY2UnLCB0aGlzLmRldmljZVNlbGVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCh7XG4gICAgICAgICAgICBzYW1wbGVSYXRlOiB0aGlzLnNhbXBsZVJhdGVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGNvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UodGhpcy5zdHJlYW0pO1xuICAgICAgICAvLyBMb2FkIGFuZCBleGVjdXRlIHRoZSBtb2R1bGUgc2NyaXB0LlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgY29udGV4dC5hdWRpb1dvcmtsZXQuYWRkTW9kdWxlKHRoaXMuc2NyaXB0U3JjKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGFkZCBhdWRpb1dvcmtsZXQgbW9kdWxlOiAke3RoaXMuc2NyaXB0U3JjfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb2Nlc3NvciA9IG5ldyBBdWRpb1dvcmtsZXROb2RlKGNvbnRleHQsICdhdWRpb19wcm9jZXNzb3InKTtcbiAgICAgICAgcHJvY2Vzc29yLnBvcnQub25tZXNzYWdlID0gKGUpPT57XG4gICAgICAgICAgICBjb25zdCB7IGV2ZW50OiBldmVudCwgaWQ6IGlkLCBkYXRhOiBkYXRhIH0gPSBlLmRhdGE7XG4gICAgICAgICAgICBpZiAoZXZlbnQgPT09ICdyZWNlaXB0JykgdGhpcy5ldmVudFJlY2VpcHRzW2lkXSA9IGRhdGE7XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudCA9PT0gJ2NodW5rJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaHVua1Byb2Nlc3NvclNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5fY2h1bmtQcm9jZXNzb3JCdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NodW5rUHJvY2Vzc29yQnVmZmVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmF3OiAoMCwgJDZkNGI3NDQ5YTFlMTU0NGEkZXhwb3J0JDEzYWZkYTIzN2IxYzk4NDYpLm1lcmdlQnVmZmVycyhidWZmZXIucmF3LCBkYXRhLnJhdyksXG4gICAgICAgICAgICAgICAgICAgICAgICBtb25vOiAoMCwgJDZkNGI3NDQ5YTFlMTU0NGEkZXhwb3J0JDEzYWZkYTIzN2IxYzk4NDYpLm1lcmdlQnVmZmVycyhidWZmZXIubW9ubywgZGF0YS5tb25vKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2h1bmtQcm9jZXNzb3JCdWZmZXIubW9uby5ieXRlTGVuZ3RoID49IHRoaXMuX2NodW5rUHJvY2Vzc29yU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2h1bmtQcm9jZXNzb3IodGhpcy5fY2h1bmtQcm9jZXNzb3JCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2h1bmtQcm9jZXNzb3JCdWZmZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3OiBuZXcgQXJyYXlCdWZmZXIoMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9ubzogbmV3IEFycmF5QnVmZmVyKDApXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHRoaXMuX2NodW5rUHJvY2Vzc29yKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBub2RlID0gc291cmNlLmNvbm5lY3QocHJvY2Vzc29yKTtcbiAgICAgICAgY29uc3QgYW5hbHlzZXIgPSBjb250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XG4gICAgICAgIGFuYWx5c2VyLmZmdFNpemUgPSA4MTkyO1xuICAgICAgICBhbmFseXNlci5zbW9vdGhpbmdUaW1lQ29uc3RhbnQgPSAwLjE7XG4gICAgICAgIG5vZGUuY29ubmVjdChhbmFseXNlcik7XG4gICAgICAgIGlmICh0aGlzLm91dHB1dFRvU3BlYWtlcnMpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBPdXRwdXQgdG8gc3BlYWtlcnMgbWF5IGFmZmVjdCBzb3VuZCBxdWFsaXR5LFxcbmVzcGVjaWFsbHkgZHVlIHRvIHN5c3RlbSBhdWRpbyBmZWVkYmFjayBwcmV2ZW50YXRpdmUgbWVhc3VyZXMuXFxudXNlIG9ubHkgZm9yIGRlYnVnZ2luZ1wiKTtcbiAgICAgICAgICAgIGFuYWx5c2VyLmNvbm5lY3QoY29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuYW5hbHlzZXIgPSBhbmFseXNlcjtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gICAgICAgIGNvbnNvbGUubG9nKCdiZWdpbiBjb21wbGV0ZWQnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IGZyZXF1ZW5jeSBkb21haW4gZGF0YSBmcm9tIHRoZSByZWNvcmRpbmcgdHJhY2tcbiAgICogQHBhcmFtIHtcImZyZXF1ZW5jeVwifFwibXVzaWNcInxcInZvaWNlXCJ9IFthbmFseXNpc1R5cGVdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluRGVjaWJlbHNdIGRlZmF1bHQgLTEwMFxuICAgKiBAcGFyYW0ge251bWJlcn0gW21heERlY2liZWxzXSBkZWZhdWx0IC0zMFxuICAgKiBAcmV0dXJucyB7aW1wb3J0KCcuL2FuYWx5c2lzL2F1ZGlvX2FuYWx5c2lzLmpzJykuQXVkaW9BbmFseXNpc091dHB1dFR5cGV9XG4gICAqLyBnZXRGcmVxdWVuY2llcyhhbmFseXNpc1R5cGUgPSAnZnJlcXVlbmN5JywgbWluRGVjaWJlbHMgPSAtMTAwLCBtYXhEZWNpYmVscyA9IC0zMCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvY2Vzc29yKSB0aHJvdyBuZXcgRXJyb3IoJ1Nlc3Npb24gZW5kZWQ6IHBsZWFzZSBjYWxsIC5iZWdpbigpIGZpcnN0Jyk7XG4gICAgICAgIHJldHVybiAoMCwgJGYzMmYwNjQ1NjRlZTYyZjYkZXhwb3J0JDJjMzEzNmRhMGJmMTMwZjkpLmdldEZyZXF1ZW5jaWVzKHRoaXMuYW5hbHlzZXIsIHRoaXMuc2FtcGxlUmF0ZSwgbnVsbCwgYW5hbHlzaXNUeXBlLCBtaW5EZWNpYmVscywgbWF4RGVjaWJlbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICogUGF1c2VzIHRoZSByZWNvcmRpbmdcbiAgICogS2VlcHMgbWljcm9waG9uZSBzdHJlYW0gb3BlbiBidXQgaGFsdHMgc3RvcmFnZSBvZiBhdWRpb1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx0cnVlPn1cbiAgICovIGFzeW5jIHBhdXNlKCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvY2Vzc29yKSB0aHJvdyBuZXcgRXJyb3IoJ1Nlc3Npb24gZW5kZWQ6IHBsZWFzZSBjYWxsIC5iZWdpbigpIGZpcnN0Jyk7XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLnJlY29yZGluZykgdGhyb3cgbmV3IEVycm9yKCdBbHJlYWR5IHBhdXNlZDogcGxlYXNlIGNhbGwgLnJlY29yZCgpIGZpcnN0Jyk7XG4gICAgICAgIGlmICh0aGlzLl9jaHVua1Byb2Nlc3NvckJ1ZmZlci5yYXcuYnl0ZUxlbmd0aCkgdGhpcy5fY2h1bmtQcm9jZXNzb3IodGhpcy5fY2h1bmtQcm9jZXNzb3JCdWZmZXIpO1xuICAgICAgICB0aGlzLmxvZygnUGF1c2luZyAuLi4nKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZXZlbnQoJ3N0b3AnKTtcbiAgICAgICAgdGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTdGFydCByZWNvcmRpbmcgc3RyZWFtIGFuZCBzdG9yaW5nIHRvIG1lbW9yeSBmcm9tIHRoZSBjb25uZWN0ZWQgYXVkaW8gc291cmNlXG4gICAqIEBwYXJhbSB7KGRhdGE6IHsgbW9ubzogSW50MTZBcnJheTsgcmF3OiBJbnQxNkFycmF5IH0pID0+IGFueX0gW2NodW5rUHJvY2Vzc29yXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2NodW5rU2l6ZV0gY2h1bmtQcm9jZXNzb3Igd2lsbCBub3QgYmUgdHJpZ2dlcmVkIHVudGlsIHRoaXMgc2l6ZSB0aHJlc2hvbGQgbWV0IGluIG1vbm8gYXVkaW9cbiAgICogQHJldHVybnMge1Byb21pc2U8dHJ1ZT59XG4gICAqLyBhc3luYyByZWNvcmQoY2h1bmtQcm9jZXNzb3IgPSAoKT0+e30sIGNodW5rU2l6ZSA9IDgxOTIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb2Nlc3NvcikgdGhyb3cgbmV3IEVycm9yKCdTZXNzaW9uIGVuZGVkOiBwbGVhc2UgY2FsbCAuYmVnaW4oKSBmaXJzdCcpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLnJlY29yZGluZykgdGhyb3cgbmV3IEVycm9yKCdBbHJlYWR5IHJlY29yZGluZzogcGxlYXNlIGNhbGwgLnBhdXNlKCkgZmlyc3QnKTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNodW5rUHJvY2Vzc29yICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoYGNodW5rUHJvY2Vzc29yIG11c3QgYmUgYSBmdW5jdGlvbmApO1xuICAgICAgICB0aGlzLl9jaHVua1Byb2Nlc3NvciA9IGNodW5rUHJvY2Vzc29yO1xuICAgICAgICB0aGlzLl9jaHVua1Byb2Nlc3NvclNpemUgPSBjaHVua1NpemU7XG4gICAgICAgIHRoaXMuX2NodW5rUHJvY2Vzc29yQnVmZmVyID0ge1xuICAgICAgICAgICAgcmF3OiBuZXcgQXJyYXlCdWZmZXIoMCksXG4gICAgICAgICAgICBtb25vOiBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2coJ1JlY29yZGluZyAuLi4nKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZXZlbnQoJ3N0YXJ0Jyk7XG4gICAgICAgIHRoaXMucmVjb3JkaW5nID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgKiBDbGVhcnMgdGhlIGF1ZGlvIGJ1ZmZlciwgZW1wdGllcyBzdG9yZWQgcmVjb3JkaW5nXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHRydWU+fVxuICAgKi8gYXN5bmMgY2xlYXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9jZXNzb3IpIHRocm93IG5ldyBFcnJvcignU2Vzc2lvbiBlbmRlZDogcGxlYXNlIGNhbGwgLmJlZ2luKCkgZmlyc3QnKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZXZlbnQoJ2NsZWFyJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICogUmVhZHMgdGhlIGN1cnJlbnQgYXVkaW8gc3RyZWFtIGRhdGFcbiAgICogQHJldHVybnMge1Byb21pc2U8e21lYW5WYWx1ZXM6IEZsb2F0MzJBcnJheSwgY2hhbm5lbHM6IEFycmF5PEZsb2F0MzJBcnJheT59Pn1cbiAgICovIGFzeW5jIHJlYWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9jZXNzb3IpIHRocm93IG5ldyBFcnJvcignU2Vzc2lvbiBlbmRlZDogcGxlYXNlIGNhbGwgLmJlZ2luKCkgZmlyc3QnKTtcbiAgICAgICAgdGhpcy5sb2coJ1JlYWRpbmcgLi4uJyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2V2ZW50KCdyZWFkJyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTYXZlcyB0aGUgY3VycmVudCBhdWRpbyBzdHJlYW0gdG8gYSBmaWxlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlXSBGb3JjZSBzYXZpbmcgd2hpbGUgc3RpbGwgcmVjb3JkaW5nXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGltcG9ydCgnLi93YXZfcGFja2VyLmpzJykuV2F2UGFja2VyQXVkaW9UeXBlPn1cbiAgICovIGFzeW5jIHNhdmUoZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMucHJvY2Vzc29yKSB0aHJvdyBuZXcgRXJyb3IoJ1Nlc3Npb24gZW5kZWQ6IHBsZWFzZSBjYWxsIC5iZWdpbigpIGZpcnN0Jyk7XG4gICAgICAgIGlmICghZm9yY2UgJiYgdGhpcy5yZWNvcmRpbmcpIHRocm93IG5ldyBFcnJvcignQ3VycmVudGx5IHJlY29yZGluZzogcGxlYXNlIGNhbGwgLnBhdXNlKCkgZmlyc3QsIG9yIGNhbGwgLnNhdmUodHJ1ZSkgdG8gZm9yY2UnKTtcbiAgICAgICAgdGhpcy5sb2coJ0V4cG9ydGluZyAuLi4nKTtcbiAgICAgICAgY29uc3QgZXhwb3J0RGF0YSA9IGF3YWl0IHRoaXMuX2V2ZW50KCdleHBvcnQnKTtcbiAgICAgICAgY29uc3QgcGFja2VyID0gbmV3ICgwLCAkNmQ0Yjc0NDlhMWUxNTQ0YSRleHBvcnQkMTNhZmRhMjM3YjFjOTg0NikoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFja2VyLnBhY2sodGhpcy5zYW1wbGVSYXRlLCBleHBvcnREYXRhLmF1ZGlvKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAqIEVuZHMgdGhlIGN1cnJlbnQgcmVjb3JkaW5nIHNlc3Npb24gYW5kIHNhdmVzIHRoZSByZXN1bHRcbiAgICogQHJldHVybnMge1Byb21pc2U8aW1wb3J0KCcuL3dhdl9wYWNrZXIuanMnKS5XYXZQYWNrZXJBdWRpb1R5cGU+fVxuICAgKi8gYXN5bmMgZW5kKCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvY2Vzc29yKSB0aHJvdyBuZXcgRXJyb3IoJ1Nlc3Npb24gZW5kZWQ6IHBsZWFzZSBjYWxsIC5iZWdpbigpIGZpcnN0Jyk7XG4gICAgICAgIGNvbnN0IF9wcm9jZXNzb3IgPSB0aGlzLnByb2Nlc3NvcjtcbiAgICAgICAgdGhpcy5sb2coJ1N0b3BwaW5nIC4uLicpO1xuICAgICAgICBhd2FpdCB0aGlzLl9ldmVudCgnc3RvcCcpO1xuICAgICAgICB0aGlzLnJlY29yZGluZyA9IGZhbHNlO1xuICAgICAgICBjb25zdCB0cmFja3MgPSB0aGlzLnN0cmVhbS5nZXRUcmFja3MoKTtcbiAgICAgICAgdHJhY2tzLmZvckVhY2goKHRyYWNrKT0+dHJhY2suc3RvcCgpKTtcbiAgICAgICAgdGhpcy5sb2coJ0V4cG9ydGluZyAuLi4nKTtcbiAgICAgICAgY29uc3QgZXhwb3J0RGF0YSA9IGF3YWl0IHRoaXMuX2V2ZW50KCdleHBvcnQnLCB7fSwgX3Byb2Nlc3Nvcik7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5zb3VyY2UuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLm5vZGUuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLmFuYWx5c2VyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBudWxsO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IG51bGw7XG4gICAgICAgIHRoaXMuc291cmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5ub2RlID0gbnVsbDtcbiAgICAgICAgY29uc3QgcGFja2VyID0gbmV3ICgwLCAkNmQ0Yjc0NDlhMWUxNTQ0YSRleHBvcnQkMTNhZmRhMjM3YjFjOTg0NikoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFja2VyLnBhY2sodGhpcy5zYW1wbGVSYXRlLCBleHBvcnREYXRhLmF1ZGlvKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGEgZnVsbCBjbGVhbnVwIG9mIFdhdlJlY29yZGVyIGluc3RhbmNlXG4gICAqIFN0b3BzIGFjdGl2ZWx5IGxpc3RlbmluZyB2aWEgbWljcm9waG9uZSBhbmQgcmVtb3ZlcyBleGlzdGluZyBsaXN0ZW5lcnNcbiAgICogQHJldHVybnMge1Byb21pc2U8dHJ1ZT59XG4gICAqLyBhc3luYyBxdWl0KCkge1xuICAgICAgICB0aGlzLmxpc3RlbkZvckRldmljZUNoYW5nZShudWxsKTtcbiAgICAgICAgLy8gd2UgZG8gbm90IHJlc2V0IHRoaXMgb24gZW5kIHNvIHRoYXQgc2VsZWN0aW9ucyBwZXJzaXN0IGFjcm9zcyBzdGFydHNcbiAgICAgICAgdGhpcy5kZXZpY2VTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzb3IpIGF3YWl0IHRoaXMuZW5kKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmdsb2JhbFRoaXMuV2F2UmVjb3JkZXIgPSAkNjJiYzM3NjA0NGEwNTUxMyRleHBvcnQkNDM5YjIxN2NhNjU5YTg3NztcblxuXG5cblxuXG5jbGFzcyAkNWZjMTFkN2JjMGQyMDcyNCRleHBvcnQkMjkzNGNmMmQyNWM2N2E0OCB7XG4gICAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBNZWRpYVN0cmVhbVJlY29yZGVyIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7e3NhbXBsZVJhdGU/OiBudW1iZXIsIG91dHB1dFRvU3BlYWtlcnM/OiBib29sZWFuLCBkZWJ1Zz86IGJvb2xlYW59fSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge01lZGlhU3RyZWFtUmVjb3JkZXJ9XG4gICAqLyBjb25zdHJ1Y3Rvcih7IHNhbXBsZVJhdGU6IHNhbXBsZVJhdGUgPSA0NDEwMCwgb3V0cHV0VG9TcGVha2Vyczogb3V0cHV0VG9TcGVha2VycyA9IGZhbHNlLCBkZWJ1ZzogZGVidWcgPSBmYWxzZSB9ID0ge30pe1xuICAgICAgICAvLyBTY3JpcHQgc291cmNlXG4gICAgICAgIHRoaXMuc2NyaXB0U3JjID0gKDAsICQ4ZTFkMWU2ZmYwOGY2ZmI1JGV4cG9ydCQxZjY1ZjUwYThjYmZmNDNjKTtcbiAgICAgICAgLy8gQ29uZmlnXG4gICAgICAgIHRoaXMuc2FtcGxlUmF0ZSA9IHNhbXBsZVJhdGU7XG4gICAgICAgIHRoaXMub3V0cHV0VG9TcGVha2VycyA9IG91dHB1dFRvU3BlYWtlcnM7XG4gICAgICAgIHRoaXMuZGVidWcgPSAhIWRlYnVnO1xuICAgICAgICAvLyBTdGF0ZSB2YXJpYWJsZXNcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBudWxsO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IG51bGw7XG4gICAgICAgIHRoaXMuc291cmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5ub2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gRXZlbnQgaGFuZGxpbmcgd2l0aCBBdWRpb1dvcmtsZXRcbiAgICAgICAgdGhpcy5fbGFzdEV2ZW50SWQgPSAwO1xuICAgICAgICB0aGlzLmV2ZW50UmVjZWlwdHMgPSB7fTtcbiAgICAgICAgdGhpcy5ldmVudFRpbWVvdXQgPSA1MDAwO1xuICAgICAgICAvLyBQcm9jZXNzIGNodW5rcyBvZiBhdWRpb1xuICAgICAgICB0aGlzLl9jaHVua1Byb2Nlc3NvciA9ICgpPT57fTtcbiAgICAgICAgdGhpcy5fY2h1bmtQcm9jZXNzb3JTaXplID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl9jaHVua1Byb2Nlc3NvckJ1ZmZlciA9IHtcbiAgICAgICAgICAgIHJhdzogbmV3IEFycmF5QnVmZmVyKDApLFxuICAgICAgICAgICAgbW9ubzogbmV3IEFycmF5QnVmZmVyKDApXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgKiBMb2dzIGRhdGEgaW4gZGVidWcgbW9kZVxuICAgKiBAcGFyYW0gey4uLmFueX0gYXJndW1lbnRzXG4gICAqIEByZXR1cm5zIHt0cnVlfVxuICAgKi8gbG9nKCkge1xuICAgICAgICBpZiAodGhpcy5kZWJ1ZykgdGhpcy5sb2coLi4uYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgc2FtcGxlUmF0ZSBmb3IgdGhlIHJlY29yZGVyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqLyBnZXRTYW1wbGVSYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zYW1wbGVSYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgcmVjb3JkaW5nXG4gICAqIEByZXR1cm5zIHtcImVuZGVkXCJ8XCJwYXVzZWRcInxcInJlY29yZGluZ1wifVxuICAgKi8gZ2V0U3RhdHVzKCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvY2Vzc29yKSByZXR1cm4gXCJlbmRlZFwiO1xuICAgICAgICBlbHNlIGlmICghdGhpcy5yZWNvcmRpbmcpIHJldHVybiBcInBhdXNlZFwiO1xuICAgICAgICBlbHNlIHJldHVybiBcInJlY29yZGluZ1wiO1xuICAgIH1cbiAgICAvKipcbiAgICogU2VuZHMgYW4gZXZlbnQgdG8gdGhlIEF1ZGlvV29ya2xldFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge3tba2V5OiBzdHJpbmddOiBhbnl9fSBkYXRhXG4gICAqIEBwYXJhbSB7QXVkaW9Xb3JrbGV0Tm9kZX0gW19wcm9jZXNzb3JdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHtba2V5OiBzdHJpbmddOiBhbnl9Pn1cbiAgICovIGFzeW5jIF9ldmVudChuYW1lLCBkYXRhID0ge30sIF9wcm9jZXNzb3IgPSBudWxsKSB7XG4gICAgICAgIF9wcm9jZXNzb3IgPSBfcHJvY2Vzc29yIHx8IHRoaXMucHJvY2Vzc29yO1xuICAgICAgICBpZiAoIV9wcm9jZXNzb3IpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3Qgc2VuZCBldmVudHMgd2l0aG91dCByZWNvcmRpbmcgZmlyc3RcIik7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBldmVudDogbmFtZSxcbiAgICAgICAgICAgIGlkOiB0aGlzLl9sYXN0RXZlbnRJZCsrLFxuICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICB9O1xuICAgICAgICBfcHJvY2Vzc29yLnBvcnQucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHQwID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgIHdoaWxlKCF0aGlzLmV2ZW50UmVjZWlwdHNbbWVzc2FnZS5pZF0pe1xuICAgICAgICAgICAgaWYgKG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdDAgPiB0aGlzLmV2ZW50VGltZW91dCkgdGhyb3cgbmV3IEVycm9yKGBUaW1lb3V0IHdhaXRpbmcgZm9yIFwiJHtuYW1lfVwiIGV2ZW50YCk7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzKT0+c2V0VGltZW91dCgoKT0+cmVzKHRydWUpLCAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuZXZlbnRSZWNlaXB0c1ttZXNzYWdlLmlkXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZXZlbnRSZWNlaXB0c1ttZXNzYWdlLmlkXTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBCZWdpbnMgYSByZWNvcmRpbmcgc2Vzc2lvbiBmb3IgdGhlIGdpdmVuIGF1ZGlvVHJhY2tcbiAgICogTWljcm9waG9uZSByZWNvcmRpbmcgaW5kaWNhdG9yIHdpbGwgYXBwZWFyIG9uIGJyb3dzZXIgdGFiIGJ1dCBzdGF0dXMgd2lsbCBiZSBcInBhdXNlZFwiXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gW2F1ZGlvVHJhY2tdIGlmIG5vIGRldmljZSBwcm92aWRlZCwgZGVmYXVsdCBkZXZpY2Ugd2lsbCBiZSB1c2VkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHRydWU+fVxuICAgKi8gYXN5bmMgYmVnaW4oYXVkaW9UcmFjaykge1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzb3IpIHRocm93IG5ldyBFcnJvcihgQWxyZWFkeSBjb25uZWN0ZWQ6IHBsZWFzZSBjYWxsIC5lbmQoKSB0byBzdGFydCBhIG5ldyBzZXNzaW9uYCk7XG4gICAgICAgIGlmICghYXVkaW9UcmFjayB8fCBhdWRpb1RyYWNrLmtpbmQgIT09IFwiYXVkaW9cIikgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXVkaW8gdHJhY2sgcHJvdmlkZWRcIik7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKFtcbiAgICAgICAgICAgIGF1ZGlvVHJhY2tcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KHtcbiAgICAgICAgICAgIHNhbXBsZVJhdGU6IHRoaXMuc2FtcGxlUmF0ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gY29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZSh0aGlzLnN0cmVhbSk7XG4gICAgICAgIC8vIExvYWQgYW5kIGV4ZWN1dGUgdGhlIG1vZHVsZSBzY3JpcHQuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBjb250ZXh0LmF1ZGlvV29ya2xldC5hZGRNb2R1bGUodGhpcy5zY3JpcHRTcmMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgYWRkIGF1ZGlvV29ya2xldCBtb2R1bGU6ICR7dGhpcy5zY3JpcHRTcmN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvY2Vzc29yID0gbmV3IEF1ZGlvV29ya2xldE5vZGUoY29udGV4dCwgXCJhdWRpb19wcm9jZXNzb3JcIik7XG4gICAgICAgIHByb2Nlc3Nvci5wb3J0Lm9ubWVzc2FnZSA9IChlKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBldmVudDogZXZlbnQsIGlkOiBpZCwgZGF0YTogZGF0YSB9ID0gZS5kYXRhO1xuICAgICAgICAgICAgaWYgKGV2ZW50ID09PSBcInJlY2VpcHRcIikgdGhpcy5ldmVudFJlY2VpcHRzW2lkXSA9IGRhdGE7XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudCA9PT0gXCJjaHVua1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NodW5rUHJvY2Vzc29yU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9jaHVua1Byb2Nlc3NvckJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2h1bmtQcm9jZXNzb3JCdWZmZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYXc6ICgwLCAkNmQ0Yjc0NDlhMWUxNTQ0YSRleHBvcnQkMTNhZmRhMjM3YjFjOTg0NikubWVyZ2VCdWZmZXJzKGJ1ZmZlci5yYXcsIGRhdGEucmF3KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbm86ICgwLCAkNmQ0Yjc0NDlhMWUxNTQ0YSRleHBvcnQkMTNhZmRhMjM3YjFjOTg0NikubWVyZ2VCdWZmZXJzKGJ1ZmZlci5tb25vLCBkYXRhLm1vbm8pXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaHVua1Byb2Nlc3NvckJ1ZmZlci5tb25vLmJ5dGVMZW5ndGggPj0gdGhpcy5fY2h1bmtQcm9jZXNzb3JTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaHVua1Byb2Nlc3Nvcih0aGlzLl9jaHVua1Byb2Nlc3NvckJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaHVua1Byb2Nlc3NvckJ1ZmZlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXc6IG5ldyBBcnJheUJ1ZmZlcigwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb25vOiBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgdGhpcy5fY2h1bmtQcm9jZXNzb3IoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG5vZGUgPSBzb3VyY2UuY29ubmVjdChwcm9jZXNzb3IpO1xuICAgICAgICBjb25zdCBhbmFseXNlciA9IGNvbnRleHQuY3JlYXRlQW5hbHlzZXIoKTtcbiAgICAgICAgYW5hbHlzZXIuZmZ0U2l6ZSA9IDgxOTI7XG4gICAgICAgIGFuYWx5c2VyLnNtb290aGluZ1RpbWVDb25zdGFudCA9IDAuMTtcbiAgICAgICAgbm9kZS5jb25uZWN0KGFuYWx5c2VyKTtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0VG9TcGVha2Vycykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IE91dHB1dCB0byBzcGVha2VycyBtYXkgYWZmZWN0IHNvdW5kIHF1YWxpdHksXFxuZXNwZWNpYWxseSBkdWUgdG8gc3lzdGVtIGF1ZGlvIGZlZWRiYWNrIHByZXZlbnRhdGl2ZSBtZWFzdXJlcy5cXG51c2Ugb25seSBmb3IgZGVidWdnaW5nXCIpO1xuICAgICAgICAgICAgYW5hbHlzZXIuY29ubmVjdChjb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5hbmFseXNlciA9IGFuYWx5c2VyO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IGZyZXF1ZW5jeSBkb21haW4gZGF0YSBmcm9tIHRoZSByZWNvcmRpbmcgdHJhY2tcbiAgICogQHBhcmFtIHtcImZyZXF1ZW5jeVwifFwibXVzaWNcInxcInZvaWNlXCJ9IFthbmFseXNpc1R5cGVdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluRGVjaWJlbHNdIGRlZmF1bHQgLTEwMFxuICAgKiBAcGFyYW0ge251bWJlcn0gW21heERlY2liZWxzXSBkZWZhdWx0IC0zMFxuICAgKiBAcmV0dXJucyB7aW1wb3J0KCcuL2FuYWx5c2lzL2F1ZGlvX2FuYWx5c2lzLmpzJykuQXVkaW9BbmFseXNpc091dHB1dFR5cGV9XG4gICAqLyBnZXRGcmVxdWVuY2llcyhhbmFseXNpc1R5cGUgPSBcImZyZXF1ZW5jeVwiLCBtaW5EZWNpYmVscyA9IC0xMDAsIG1heERlY2liZWxzID0gLTMwKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9jZXNzb3IpIHRocm93IG5ldyBFcnJvcihcIlNlc3Npb24gZW5kZWQ6IHBsZWFzZSBjYWxsIC5iZWdpbigpIGZpcnN0XCIpO1xuICAgICAgICByZXR1cm4gKDAsICRmMzJmMDY0NTY0ZWU2MmY2JGV4cG9ydCQyYzMxMzZkYTBiZjEzMGY5KS5nZXRGcmVxdWVuY2llcyh0aGlzLmFuYWx5c2VyLCB0aGlzLnNhbXBsZVJhdGUsIG51bGwsIGFuYWx5c2lzVHlwZSwgbWluRGVjaWJlbHMsIG1heERlY2liZWxzKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBhdXNlcyB0aGUgcmVjb3JkaW5nXG4gICAqIEtlZXBzIG1pY3JvcGhvbmUgc3RyZWFtIG9wZW4gYnV0IGhhbHRzIHN0b3JhZ2Ugb2YgYXVkaW9cbiAgICogQHJldHVybnMge1Byb21pc2U8dHJ1ZT59XG4gICAqLyBhc3luYyBwYXVzZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb2Nlc3NvcikgdGhyb3cgbmV3IEVycm9yKFwiU2Vzc2lvbiBlbmRlZDogcGxlYXNlIGNhbGwgLmJlZ2luKCkgZmlyc3RcIik7XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLnJlY29yZGluZykgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBwYXVzZWQ6IHBsZWFzZSBjYWxsIC5yZWNvcmQoKSBmaXJzdFwiKTtcbiAgICAgICAgaWYgKHRoaXMuX2NodW5rUHJvY2Vzc29yQnVmZmVyLnJhdy5ieXRlTGVuZ3RoKSB0aGlzLl9jaHVua1Byb2Nlc3Nvcih0aGlzLl9jaHVua1Byb2Nlc3NvckJ1ZmZlcik7XG4gICAgICAgIHRoaXMubG9nKFwiUGF1c2luZyAuLi5cIik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2V2ZW50KFwic3RvcFwiKTtcbiAgICAgICAgdGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTdGFydCByZWNvcmRpbmcgc3RyZWFtIGFuZCBzdG9yaW5nIHRvIG1lbW9yeSBmcm9tIHRoZSBjb25uZWN0ZWQgYXVkaW8gc291cmNlXG4gICAqIEBwYXJhbSB7KGRhdGE6IHsgbW9ubzogSW50MTZBcnJheTsgcmF3OiBJbnQxNkFycmF5IH0pID0+IGFueX0gW2NodW5rUHJvY2Vzc29yXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2NodW5rU2l6ZV0gY2h1bmtQcm9jZXNzb3Igd2lsbCBub3QgYmUgdHJpZ2dlcmVkIHVudGlsIHRoaXMgc2l6ZSB0aHJlc2hvbGQgbWV0IGluIG1vbm8gYXVkaW9cbiAgICogQHJldHVybnMge1Byb21pc2U8dHJ1ZT59XG4gICAqLyBhc3luYyByZWNvcmQoY2h1bmtQcm9jZXNzb3IgPSAoKT0+e30sIGNodW5rU2l6ZSA9IDgxOTIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb2Nlc3NvcikgdGhyb3cgbmV3IEVycm9yKFwiU2Vzc2lvbiBlbmRlZDogcGxlYXNlIGNhbGwgLmJlZ2luKCkgZmlyc3RcIik7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucmVjb3JkaW5nKSB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHJlY29yZGluZzogSEVMTE8gcGxlYXNlIGNhbGwgLnBhdXNlKCkgZmlyc3RcIik7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaHVua1Byb2Nlc3NvciAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoYGNodW5rUHJvY2Vzc29yIG11c3QgYmUgYSBmdW5jdGlvbmApO1xuICAgICAgICB0aGlzLl9jaHVua1Byb2Nlc3NvciA9IGNodW5rUHJvY2Vzc29yO1xuICAgICAgICB0aGlzLl9jaHVua1Byb2Nlc3NvclNpemUgPSBjaHVua1NpemU7XG4gICAgICAgIHRoaXMuX2NodW5rUHJvY2Vzc29yQnVmZmVyID0ge1xuICAgICAgICAgICAgcmF3OiBuZXcgQXJyYXlCdWZmZXIoMCksXG4gICAgICAgICAgICBtb25vOiBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2coXCJSZWNvcmRpbmcgLi4uXCIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9ldmVudChcInN0YXJ0XCIpO1xuICAgICAgICB0aGlzLnJlY29yZGluZyA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICogQ2xlYXJzIHRoZSBhdWRpbyBidWZmZXIsIGVtcHRpZXMgc3RvcmVkIHJlY29yZGluZ1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx0cnVlPn1cbiAgICovIGFzeW5jIGNsZWFyKCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvY2Vzc29yKSB0aHJvdyBuZXcgRXJyb3IoXCJTZXNzaW9uIGVuZGVkOiBwbGVhc2UgY2FsbCAuYmVnaW4oKSBmaXJzdFwiKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZXZlbnQoXCJjbGVhclwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZWFkcyB0aGUgY3VycmVudCBhdWRpbyBzdHJlYW0gZGF0YVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7bWVhblZhbHVlczogRmxvYXQzMkFycmF5LCBjaGFubmVsczogQXJyYXk8RmxvYXQzMkFycmF5Pn0+fVxuICAgKi8gYXN5bmMgcmVhZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb2Nlc3NvcikgdGhyb3cgbmV3IEVycm9yKFwiU2Vzc2lvbiBlbmRlZDogcGxlYXNlIGNhbGwgLmJlZ2luKCkgZmlyc3RcIik7XG4gICAgICAgIHRoaXMubG9nKFwiUmVhZGluZyAuLi5cIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2V2ZW50KFwicmVhZFwiKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFNhdmVzIHRoZSBjdXJyZW50IGF1ZGlvIHN0cmVhbSB0byBhIGZpbGVcbiAgICogQHBhcmFtIHtib29sZWFufSBbZm9yY2VdIEZvcmNlIHNhdmluZyB3aGlsZSBzdGlsbCByZWNvcmRpbmdcbiAgICogQHJldHVybnMge1Byb21pc2U8aW1wb3J0KCcuL3dhdl9wYWNrZXIuanMnKS5XYXZQYWNrZXJBdWRpb1R5cGU+fVxuICAgKi8gYXN5bmMgc2F2ZShmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9jZXNzb3IpIHRocm93IG5ldyBFcnJvcihcIlNlc3Npb24gZW5kZWQ6IHBsZWFzZSBjYWxsIC5iZWdpbigpIGZpcnN0XCIpO1xuICAgICAgICBpZiAoIWZvcmNlICYmIHRoaXMucmVjb3JkaW5nKSB0aHJvdyBuZXcgRXJyb3IoXCJDdXJyZW50bHkgcmVjb3JkaW5nOiBwbGVhc2UgY2FsbCAucGF1c2UoKSBmaXJzdCwgb3IgY2FsbCAuc2F2ZSh0cnVlKSB0byBmb3JjZVwiKTtcbiAgICAgICAgdGhpcy5sb2coXCJFeHBvcnRpbmcgLi4uXCIpO1xuICAgICAgICBjb25zdCBleHBvcnREYXRhID0gYXdhaXQgdGhpcy5fZXZlbnQoXCJleHBvcnRcIik7XG4gICAgICAgIGNvbnN0IHBhY2tlciA9IG5ldyAoMCwgJDZkNGI3NDQ5YTFlMTU0NGEkZXhwb3J0JDEzYWZkYTIzN2IxYzk4NDYpKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhY2tlci5wYWNrKHRoaXMuc2FtcGxlUmF0ZSwgZXhwb3J0RGF0YS5hdWRpbyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBFbmRzIHRoZSBjdXJyZW50IHJlY29yZGluZyBzZXNzaW9uIGFuZCBzYXZlcyB0aGUgcmVzdWx0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGltcG9ydCgnLi93YXZfcGFja2VyLmpzJykuV2F2UGFja2VyQXVkaW9UeXBlPn1cbiAgICovIGFzeW5jIGVuZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb2Nlc3NvcikgdGhyb3cgbmV3IEVycm9yKFwiU2Vzc2lvbiBlbmRlZDogcGxlYXNlIGNhbGwgLmJlZ2luKCkgZmlyc3RcIik7XG4gICAgICAgIGNvbnN0IF9wcm9jZXNzb3IgPSB0aGlzLnByb2Nlc3NvcjtcbiAgICAgICAgdGhpcy5sb2coXCJTdG9wcGluZyAuLi5cIik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2V2ZW50KFwic3RvcFwiKTtcbiAgICAgICAgdGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2coXCJFeHBvcnRpbmcgLi4uXCIpO1xuICAgICAgICBjb25zdCBleHBvcnREYXRhID0gYXdhaXQgdGhpcy5fZXZlbnQoXCJleHBvcnRcIiwge30sIF9wcm9jZXNzb3IpO1xuICAgICAgICB0aGlzLnByb2Nlc3Nvci5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5ub2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5hbmFseXNlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3IgPSBudWxsO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gICAgICAgIHRoaXMubm9kZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IHBhY2tlciA9IG5ldyAoMCwgJDZkNGI3NDQ5YTFlMTU0NGEkZXhwb3J0JDEzYWZkYTIzN2IxYzk4NDYpKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhY2tlci5wYWNrKHRoaXMuc2FtcGxlUmF0ZSwgZXhwb3J0RGF0YS5hdWRpbyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQZXJmb3JtcyBhIGZ1bGwgY2xlYW51cCBvZiBXYXZSZWNvcmRlciBpbnN0YW5jZVxuICAgKiBTdG9wcyBhY3RpdmVseSBsaXN0ZW5pbmcgdmlhIG1pY3JvcGhvbmUgYW5kIHJlbW92ZXMgZXhpc3RpbmcgbGlzdGVuZXJzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHRydWU+fVxuICAgKi8gYXN5bmMgcXVpdCgpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5Gb3JEZXZpY2VDaGFuZ2UobnVsbCk7XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NvcikgYXdhaXQgdGhpcy5lbmQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZ2xvYmFsVGhpcy5XYXZSZWNvcmRlciA9IFdhdlJlY29yZGVyO1xuXG5cblxuXG52YXIgJGZjNDlhNTZjZDg3MzkxMjckdmFyJF9fZXh0ZW5kcyA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19leHRlbmRzIHx8IGZ1bmN0aW9uKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICh7XG4gICAgICAgICAgICBfX3Byb3RvX186IFtdXG4gICAgICAgIH0pIGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24oZCwgYikge1xuICAgICAgICAgICAgZC5fX3Byb3RvX18gPSBiO1xuICAgICAgICB9IHx8IGZ1bmN0aW9uKGQsIGIpIHtcbiAgICAgICAgICAgIGZvcih2YXIgcCBpbiBiKWlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbihkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgICAgICAgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0oKTtcbnZhciAkZmM0OWE1NmNkODczOTEyNyR2YXIkX19hd2FpdGVyID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2F3YWl0ZXIgfHwgZnVuY3Rpb24odGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyICRmYzQ5YTU2Y2Q4NzM5MTI3JHZhciRfX2dlbmVyYXRvciA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19nZW5lcmF0b3IgfHwgZnVuY3Rpb24odGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0ge1xuICAgICAgICBsYWJlbDogMCxcbiAgICAgICAgc2VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodFswXSAmIDEpIHRocm93IHRbMV07XG4gICAgICAgICAgICByZXR1cm4gdFsxXTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJ5czogW10sXG4gICAgICAgIG9wczogW11cbiAgICB9LCBmLCB5LCB0LCBnID0gT2JqZWN0LmNyZWF0ZSgodHlwZW9mIEl0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKTtcbiAgICByZXR1cm4gZy5uZXh0ID0gdmVyYigwKSwgZ1tcInRocm93XCJdID0gdmVyYigxKSwgZ1tcInJldHVyblwiXSA9IHZlcmIoMiksIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXAoW1xuICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgdlxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZShnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbXG4gICAgICAgICAgICAgICAgb3BbMF0gJiAyLFxuICAgICAgICAgICAgICAgIHQudmFsdWVcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBzd2l0Y2gob3BbMF0pe1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3BbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgICAgICB5ID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICAgIG9wID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIG9wID0gXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCBvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IG9wWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ub3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9wID0gW1xuICAgICAgICAgICAgICAgIDYsXG4gICAgICAgICAgICAgICAgZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICBmID0gdCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCxcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG59O1xudmFyICRmYzQ5YTU2Y2Q4NzM5MTI3JGV4cG9ydCQ0YTBjNDZkYmJlMmRkYjY3ID0gLyoqIEBjbGFzcyAqLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBNZWRpYU1hbmFnZXIoKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgICAgICB0aGlzLl9taWNFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY2FtRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBNZWRpYU1hbmFnZXIucHJvdG90eXBlLnNldFVzZXJBdWRpb0NhbGxiYWNrID0gZnVuY3Rpb24odXNlckF1ZGlvQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fdXNlckF1ZGlvQ2FsbGJhY2sgPSB1c2VyQXVkaW9DYWxsYmFjaztcbiAgICB9O1xuICAgIE1lZGlhTWFuYWdlci5wcm90b3R5cGUuc2V0UlRWSU9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zLCBvdmVycmlkZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKG92ZXJyaWRlID09PSB2b2lkIDApIG92ZXJyaWRlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zICYmICFvdmVycmlkZSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gKF9hID0gb3B0aW9ucy5jYWxsYmFja3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgICAgICB0aGlzLl9taWNFbmFibGVkID0gKF9iID0gb3B0aW9ucy5lbmFibGVNaWMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWU7XG4gICAgICAgIHRoaXMuX2NhbUVuYWJsZWQgPSAoX2MgPSBvcHRpb25zLmVuYWJsZUNhbSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gTWVkaWFNYW5hZ2VyO1xufSgpO1xudmFyICRmYzQ5YTU2Y2Q4NzM5MTI3JGV4cG9ydCQ0NWM1YjliZmJhMmY2MzA0ID0gLyoqIEBjbGFzcyAqLyBmdW5jdGlvbihfc3VwZXIpIHtcbiAgICAkZmM0OWE1NmNkODczOTEyNyR2YXIkX19leHRlbmRzKFdhdk1lZGlhTWFuYWdlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXYXZNZWRpYU1hbmFnZXIocmVjb3JkZXJDaHVua1NpemUsIHJlY29yZGVyU2FtcGxlUmF0ZSkge1xuICAgICAgICBpZiAocmVjb3JkZXJDaHVua1NpemUgPT09IHZvaWQgMCkgcmVjb3JkZXJDaHVua1NpemUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChyZWNvcmRlclNhbXBsZVJhdGUgPT09IHZvaWQgMCkgcmVjb3JkZXJTYW1wbGVSYXRlID0gMjQwMDA7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5fcmVjb3JkZXJDaHVua1NpemUgPSB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLl9yZWNvcmRlckNodW5rU2l6ZSA9IHJlY29yZGVyQ2h1bmtTaXplO1xuICAgICAgICBfdGhpcy5fd2F2UmVjb3JkZXIgPSBuZXcgKDAsICQ2MmJjMzc2MDQ0YTA1NTEzJGV4cG9ydCQ0MzliMjE3Y2E2NTlhODc3KSh7XG4gICAgICAgICAgICBzYW1wbGVSYXRlOiByZWNvcmRlclNhbXBsZVJhdGVcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLl93YXZTdHJlYW1QbGF5ZXIgPSBuZXcgKDAsICRkMGE5Njk4MzM5NThkOWU3JGV4cG9ydCQ5Njk4ZDYyYzc4YjhmMzY2KSh7XG4gICAgICAgICAgICBzYW1wbGVSYXRlOiAyNDAwMFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBXYXZNZWRpYU1hbmFnZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRmYzQ5YTU2Y2Q4NzM5MTI3JHZhciRfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCBQcm9taXNlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAkZmM0OWE1NmNkODczOTEyNyR2YXIkX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24oX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2goX2EubGFiZWwpe1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQgLyp5aWVsZCovICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl93YXZSZWNvcmRlci5iZWdpbigpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl93YXZSZWNvcmRlci5saXN0ZW5Gb3JEZXZpY2VDaGFuZ2UobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl93YXZSZWNvcmRlci5saXN0ZW5Gb3JEZXZpY2VDaGFuZ2UodGhpcy5faGFuZGxlQXZhaWxhYmxlRGV2aWNlc1VwZGF0ZWQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQgLyp5aWVsZCovICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl93YXZTdHJlYW1QbGF5ZXIuY29ubmVjdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIgLypyZXR1cm4qLyBcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgV2F2TWVkaWFNYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkZmM0OWE1NmNkODczOTEyNyR2YXIkX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgUHJvbWlzZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaXNBbHJlYWR5UmVjb3JkaW5nO1xuICAgICAgICAgICAgcmV0dXJuICRmYzQ5YTU2Y2Q4NzM5MTI3JHZhciRfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaChfYS5sYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIXRoaXMuX2luaXRpYWxpemVkKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMgLypicmVhayovICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0IC8qeWllbGQqLyAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplKClcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBbHJlYWR5UmVjb3JkaW5nID0gdGhpcy5fd2F2UmVjb3JkZXIuZ2V0U3RhdHVzKCkgPT0gXCJyZWNvcmRpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMuX21pY0VuYWJsZWQgJiYgIWlzQWxyZWFkeVJlY29yZGluZykpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyAvKmJyZWFrKi8gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDRcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQgLyp5aWVsZCovICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFJlY29yZGluZygpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMiAvKnJldHVybiovIFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBXYXZNZWRpYU1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRmYzQ5YTU2Y2Q4NzM5MTI3JHZhciRfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCBQcm9taXNlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAkZmM0OWE1NmNkODczOTEyNyR2YXIkX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24oX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2goX2EubGFiZWwpe1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIgLypyZXR1cm4qLyBcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQgLyp5aWVsZCovICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl93YXZSZWNvcmRlci5lbmQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0IC8qeWllbGQqLyAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2F2U3RyZWFtUGxheWVyLmludGVycnVwdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyIC8qcmV0dXJuKi8gXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFdhdk1lZGlhTWFuYWdlci5wcm90b3R5cGUudXNlclN0YXJ0ZWRTcGVha2luZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJGZjNDlhNTZjZDg3MzkxMjckdmFyJF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIFByb21pc2UsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICRmYzQ5YTU2Y2Q4NzM5MTI3JHZhciRfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIDIgLypyZXR1cm4qLyAsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dhdlN0cmVhbVBsYXllci5pbnRlcnJ1cHQoKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBXYXZNZWRpYU1hbmFnZXIucHJvdG90eXBlLmJ1ZmZlckJvdEF1ZGlvID0gZnVuY3Rpb24oZGF0YSwgaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dhdlN0cmVhbVBsYXllci5hZGQxNkJpdFBDTShkYXRhLCBpZCk7XG4gICAgfTtcbiAgICBXYXZNZWRpYU1hbmFnZXIucHJvdG90eXBlLmdldEFsbE1pY3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dhdlJlY29yZGVyLmxpc3REZXZpY2VzKCk7XG4gICAgfTtcbiAgICBXYXZNZWRpYU1hbmFnZXIucHJvdG90eXBlLmdldEFsbENhbXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gVE9ETzogVmlkZW8gbm90IHN1cHBvcnRlZCB5ZXRcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfTtcbiAgICBXYXZNZWRpYU1hbmFnZXIucHJvdG90eXBlLmdldEFsbFNwZWFrZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFRPRE86IEltcGxlbWVudCBzcGVha2VyIHN1cHBvcnRcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfTtcbiAgICBXYXZNZWRpYU1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZU1pYyA9IGZ1bmN0aW9uKG1pY0lkKSB7XG4gICAgICAgIHJldHVybiAkZmM0OWE1NmNkODczOTEyNyR2YXIkX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgUHJvbWlzZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcHJldk1pYywgY3VyTWljO1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHJldHVybiAkZmM0OWE1NmNkODczOTEyNyR2YXIkX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24oX2MpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2goX2MubGFiZWwpe1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2TWljID0gdGhpcy5fd2F2UmVjb3JkZXIuZGV2aWNlU2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0IC8qeWllbGQqLyAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2F2UmVjb3JkZXIuZW5kKClcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCAvKnlpZWxkKi8gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3dhdlJlY29yZGVyLmJlZ2luKG1pY0lkKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9taWNFbmFibGVkKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMgLypicmVhayovICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0IC8qeWllbGQqLyAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRSZWNvcmRpbmcoKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJNaWMgPSB0aGlzLl93YXZSZWNvcmRlci5kZXZpY2VTZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyTWljICYmIHByZXZNaWMgJiYgcHJldk1pYy5sYWJlbCAhPT0gY3VyTWljLmxhYmVsKSAoX2IgPSAoX2EgPSB0aGlzLl9jYWxsYmFja3MpLm9uTWljVXBkYXRlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCB8fCBfYi5jYWxsKF9hLCBjdXJNaWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyIC8qcmV0dXJuKi8gXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFdhdk1lZGlhTWFuYWdlci5wcm90b3R5cGUudXBkYXRlQ2FtID0gZnVuY3Rpb24oY2FtSWQpIHtcbiAgICAvLyBUT0RPOiBWaWRlbyBub3Qgc3VwcG9ydGVkIHlldFxuICAgIH07XG4gICAgV2F2TWVkaWFNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVTcGVha2VyID0gZnVuY3Rpb24oc3BlYWtlcklkKSB7XG4gICAgLy8gVE9ETzogSW1wbGVtZW50IHNwZWFrZXIgc3VwcG9ydFxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdhdk1lZGlhTWFuYWdlci5wcm90b3R5cGUsIFwic2VsZWN0ZWRNaWNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuX3dhdlJlY29yZGVyLmRldmljZVNlbGVjdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2F2TWVkaWFNYW5hZ2VyLnByb3RvdHlwZSwgXCJzZWxlY3RlZENhbVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBWaWRlbyBub3Qgc3VwcG9ydGVkIHlldFxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdhdk1lZGlhTWFuYWdlci5wcm90b3R5cGUsIFwic2VsZWN0ZWRTcGVha2VyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IEltcGxlbWVudCBzcGVha2VyIHN1cHBvcnRcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFdhdk1lZGlhTWFuYWdlci5wcm90b3R5cGUuZW5hYmxlTWljID0gZnVuY3Rpb24oZW5hYmxlKSB7XG4gICAgICAgIHJldHVybiAkZmM0OWE1NmNkODczOTEyNyR2YXIkX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgUHJvbWlzZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuICRmYzQ5YTU2Y2Q4NzM5MTI3JHZhciRfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaChfYS5sYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21pY0VuYWJsZWQgPSBlbmFibGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3dhdlJlY29yZGVyLnN0cmVhbSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyIC8qcmV0dXJuKi8gXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2F2UmVjb3JkZXIuc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbih0cmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2suZW5hYmxlZCA9IGVuYWJsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVuYWJsZSkgKF9iID0gKF9hID0gX3RoaXMuX2NhbGxiYWNrcykub25UcmFja1N0b3BwZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgfHwgX2IuY2FsbChfYSwgdHJhY2ssICRmYzQ5YTU2Y2Q4NzM5MTI3JHZhciRsb2NhbFBhcnRpY2lwYW50KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVuYWJsZSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzIC8qYnJlYWsqLyAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCAvKnlpZWxkKi8gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0UmVjb3JkaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyAvKmJyZWFrKi8gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDRcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCAvKnlpZWxkKi8gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3dhdlJlY29yZGVyLnBhdXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyIC8qcmV0dXJuKi8gXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFdhdk1lZGlhTWFuYWdlci5wcm90b3R5cGUuZW5hYmxlQ2FtID0gZnVuY3Rpb24oZW5hYmxlKSB7XG4gICAgLy8gVE9ETzogVmlkZW8gbm90IHN1cHBvcnRlZCB5ZXRcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXYXZNZWRpYU1hbmFnZXIucHJvdG90eXBlLCBcImlzQ2FtRW5hYmxlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBWaWRlbyBub3Qgc3VwcG9ydGVkIHlldFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdhdk1lZGlhTWFuYWdlci5wcm90b3R5cGUsIFwiaXNNaWNFbmFibGVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9taWNFbmFibGVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgV2F2TWVkaWFNYW5hZ2VyLnByb3RvdHlwZS50cmFja3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgdHJhY2tzID0gKF9hID0gdGhpcy5fd2F2UmVjb3JkZXIuc3RyZWFtKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0VHJhY2tzKClbMF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhbDogdHJhY2tzID8ge1xuICAgICAgICAgICAgICAgIGF1ZGlvOiB0cmFja3NcbiAgICAgICAgICAgIH0gOiB7fVxuICAgICAgICB9O1xuICAgIH07XG4gICAgV2F2TWVkaWFNYW5hZ2VyLnByb3RvdHlwZS5fc3RhcnRSZWNvcmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRmYzQ5YTU2Y2Q4NzM5MTI3JHZhciRfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHRyYWNrO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgcmV0dXJuICRmYzQ5YTU2Y2Q4NzM5MTI3JHZhciRfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfZCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaChfZC5sYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCAvKnlpZWxkKi8gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3dhdlJlY29yZGVyLnJlY29yZChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl91c2VyQXVkaW9DYWxsYmFjayhkYXRhLm1vbm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMuX3JlY29yZGVyQ2h1bmtTaXplKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Quc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2sgPSAoX2EgPSB0aGlzLl93YXZSZWNvcmRlci5zdHJlYW0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRBdWRpb1RyYWNrcygpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrKSAoX2MgPSAoX2IgPSB0aGlzLl9jYWxsYmFja3MpLm9uVHJhY2tTdGFydGVkKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwIHx8IF9jLmNhbGwoX2IsIHRyYWNrLCAkZmM0OWE1NmNkODczOTEyNyR2YXIkbG9jYWxQYXJ0aWNpcGFudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMiAvKnJldHVybiovIFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBXYXZNZWRpYU1hbmFnZXIucHJvdG90eXBlLl9oYW5kbGVBdmFpbGFibGVEZXZpY2VzVXBkYXRlZCA9IGZ1bmN0aW9uKGRldmljZXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLl9jYWxsYmFja3MpLm9uQXZhaWxhYmxlQ2Ftc1VwZGF0ZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgfHwgX2IuY2FsbChfYSwgZGV2aWNlcy5maWx0ZXIoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQua2luZCA9PT0gXCJ2aWRlb2lucHV0XCI7XG4gICAgICAgIH0pKTtcbiAgICAgICAgKF9kID0gKF9jID0gdGhpcy5fY2FsbGJhY2tzKS5vbkF2YWlsYWJsZU1pY3NVcGRhdGVkKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwIHx8IF9kLmNhbGwoX2MsIGRldmljZXMuZmlsdGVyKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLmtpbmQgPT09IFwiYXVkaW9pbnB1dFwiO1xuICAgICAgICB9KSk7XG4gICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IGRldmljZSB3ZW50IGF3YXkgb3Igd2UncmUgdXNpbmcgdGhlIGRlZmF1bHQgYW5kXG4gICAgICAgIC8vIHRoZSBkZWZhdWx0IGNoYW5nZWQsIHJlc2V0IHRoZSBtaWMuXG4gICAgICAgIHZhciBkZWZhdWx0RGV2aWNlID0gZGV2aWNlcy5maW5kKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLmRldmljZUlkID09PSBcImRlZmF1bHRcIjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjdXJyZW50RGV2aWNlID0gdGhpcy5fd2F2UmVjb3JkZXIuZGV2aWNlU2VsZWN0aW9uO1xuICAgICAgICBpZiAoY3VycmVudERldmljZSAmJiAoIWRldmljZXMuc29tZShmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5kZXZpY2VJZCA9PT0gY3VycmVudERldmljZS5kZXZpY2VJZDtcbiAgICAgICAgfSkgfHwgY3VycmVudERldmljZS5kZXZpY2VJZCA9PT0gXCJkZWZhdWx0XCIgJiYgY3VycmVudERldmljZS5sYWJlbCAhPT0gKGRlZmF1bHREZXZpY2UgPT09IG51bGwgfHwgZGVmYXVsdERldmljZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmYXVsdERldmljZS5sYWJlbCkpKSB0aGlzLnVwZGF0ZU1pYyhcIlwiKTtcbiAgICB9O1xuICAgIHJldHVybiBXYXZNZWRpYU1hbmFnZXI7XG59KCRmYzQ5YTU2Y2Q4NzM5MTI3JGV4cG9ydCQ0YTBjNDZkYmJlMmRkYjY3KTtcbnZhciAkZmM0OWE1NmNkODczOTEyNyR2YXIkbG9jYWxQYXJ0aWNpcGFudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBcImxvY2FsXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIGxvY2FsOiB0cnVlXG4gICAgfTtcbn07XG5cblxuXG5cblxudmFyICQyMmVjZTA0NTI5MGM5OTZhJHZhciRfX2V4dGVuZHMgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoe1xuICAgICAgICAgICAgX19wcm90b19fOiBbXVxuICAgICAgICB9KSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKGQsIGIpIHtcbiAgICAgICAgICAgIGQuX19wcm90b19fID0gYjtcbiAgICAgICAgfSB8fCBmdW5jdGlvbihkLCBiKSB7XG4gICAgICAgICAgICBmb3IodmFyIHAgaW4gYilpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkge1xuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gICAgICAgIH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KCk7XG52YXIgJDIyZWNlMDQ1MjkwYzk5NmEkdmFyJF9fYXdhaXRlciA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyIHx8IGZ1bmN0aW9uKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciAkMjJlY2UwNDUyOTBjOTk2YSR2YXIkX19nZW5lcmF0b3IgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZ2VuZXJhdG9yIHx8IGZ1bmN0aW9uKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHtcbiAgICAgICAgbGFiZWw6IDAsXG4gICAgICAgIHNlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIHRbMV07XG4gICAgICAgIH0sXG4gICAgICAgIHRyeXM6IFtdLFxuICAgICAgICBvcHM6IFtdXG4gICAgfSwgZiwgeSwgdCwgZyA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBJdGVyYXRvciA9PT0gXCJmdW5jdGlvblwiID8gSXRlcmF0b3IgOiBPYmplY3QpLnByb3RvdHlwZSk7XG4gICAgcmV0dXJuIGcubmV4dCA9IHZlcmIoMCksIGdbXCJ0aHJvd1wiXSA9IHZlcmIoMSksIGdbXCJyZXR1cm5cIl0gPSB2ZXJiKDIpLCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwKFtcbiAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgIHZcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKXRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW1xuICAgICAgICAgICAgICAgIG9wWzBdICYgMixcbiAgICAgICAgICAgICAgICB0LnZhbHVlXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgc3dpdGNoKG9wWzBdKXtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9wWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICAgICAgeSA9IG9wWzFdO1xuICAgICAgICAgICAgICAgICAgICBvcCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBvcCA9IF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgb3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBfLm9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvcCA9IFtcbiAgICAgICAgICAgICAgICA2LFxuICAgICAgICAgICAgICAgIGVcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgZiA9IHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsXG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxufTtcbnZhciAkMjJlY2UwNDUyOTBjOTk2YSRleHBvcnQkYzk1YzY1YWJjNWY0NzEyNSA9IC8qKiBAY2xhc3MgKi8gZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgJDIyZWNlMDQ1MjkwYzk5NmEkdmFyJF9fZXh0ZW5kcyhEYWlseU1lZGlhTWFuYWdlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYWlseU1lZGlhTWFuYWdlcihlbmFibGVQbGF5ZXIsIGVuYWJsZVJlY29yZGluZywgb25UcmFja1N0YXJ0ZWRDYWxsYmFjaywgb25UcmFja1N0b3BwZWRDYWxsYmFjaywgcmVjb3JkZXJDaHVua1NpemUsIHJlY29yZGVyU2FtcGxlUmF0ZSwgcGxheWVyU2FtcGxlUmF0ZSkge1xuICAgICAgICBpZiAoZW5hYmxlUGxheWVyID09PSB2b2lkIDApIGVuYWJsZVBsYXllciA9IHRydWU7XG4gICAgICAgIGlmIChlbmFibGVSZWNvcmRpbmcgPT09IHZvaWQgMCkgZW5hYmxlUmVjb3JkaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHJlY29yZGVyQ2h1bmtTaXplID09PSB2b2lkIDApIHJlY29yZGVyQ2h1bmtTaXplID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAocmVjb3JkZXJTYW1wbGVSYXRlID09PSB2b2lkIDApIHJlY29yZGVyU2FtcGxlUmF0ZSA9IDI0MDAwO1xuICAgICAgICBpZiAocGxheWVyU2FtcGxlUmF0ZSA9PT0gdm9pZCAwKSBwbGF5ZXJTYW1wbGVSYXRlID0gMjQwMDA7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3NlbGVjdGVkQ2FtID0ge307XG4gICAgICAgIF90aGlzLl9zZWxlY3RlZE1pYyA9IHt9O1xuICAgICAgICBfdGhpcy5fc2VsZWN0ZWRTcGVha2VyID0ge307XG4gICAgICAgIF90aGlzLl9yZW1vdGVBdWRpb0xldmVsSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICBfdGhpcy5fcmVjb3JkZXJDaHVua1NpemUgPSB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9jdXJyZW50QXVkaW9UcmFjayA9IG51bGw7XG4gICAgICAgIF90aGlzLl9jb25uZWN0UmVzb2x2ZSA9IG51bGw7XG4gICAgICAgIF90aGlzLm9uVHJhY2tTdGFydGVkQ2FsbGJhY2sgPSBvblRyYWNrU3RhcnRlZENhbGxiYWNrO1xuICAgICAgICBfdGhpcy5vblRyYWNrU3RvcHBlZENhbGxiYWNrID0gb25UcmFja1N0b3BwZWRDYWxsYmFjaztcbiAgICAgICAgX3RoaXMuX3JlY29yZGVyQ2h1bmtTaXplID0gcmVjb3JkZXJDaHVua1NpemU7XG4gICAgICAgIF90aGlzLl9kYWlseSA9IChfYSA9ICgwLCAka1I2dEckZGFpbHljb2RhaWx5anMpLmdldENhbGxJbnN0YW5jZSgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoMCwgJGtSNnRHJGRhaWx5Y29kYWlseWpzKS5jcmVhdGVDYWxsT2JqZWN0KCk7XG4gICAgICAgIGlmIChlbmFibGVSZWNvcmRpbmcpIF90aGlzLl9tZWRpYVN0cmVhbVJlY29yZGVyID0gbmV3ICgwLCAkNWZjMTFkN2JjMGQyMDcyNCRleHBvcnQkMjkzNGNmMmQyNWM2N2E0OCkoe1xuICAgICAgICAgICAgc2FtcGxlUmF0ZTogcmVjb3JkZXJTYW1wbGVSYXRlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZW5hYmxlUGxheWVyKSBfdGhpcy5fd2F2U3RyZWFtUGxheWVyID0gbmV3ICgwLCAkZDBhOTY5ODMzOTU4ZDllNyRleHBvcnQkOTY5OGQ2MmM3OGI4ZjM2Nikoe1xuICAgICAgICAgICAgc2FtcGxlUmF0ZTogcGxheWVyU2FtcGxlUmF0ZVxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuX2RhaWx5Lm9uKFwidHJhY2stc3RhcnRlZFwiLCBfdGhpcy5oYW5kbGVUcmFja1N0YXJ0ZWQuYmluZChfdGhpcykpO1xuICAgICAgICBfdGhpcy5fZGFpbHkub24oXCJ0cmFjay1zdG9wcGVkXCIsIF90aGlzLmhhbmRsZVRyYWNrU3RvcHBlZC5iaW5kKF90aGlzKSk7XG4gICAgICAgIF90aGlzLl9kYWlseS5vbihcImF2YWlsYWJsZS1kZXZpY2VzLXVwZGF0ZWRcIiwgX3RoaXMuX2hhbmRsZUF2YWlsYWJsZURldmljZXNVcGRhdGVkLmJpbmQoX3RoaXMpKTtcbiAgICAgICAgX3RoaXMuX2RhaWx5Lm9uKFwic2VsZWN0ZWQtZGV2aWNlcy11cGRhdGVkXCIsIF90aGlzLl9oYW5kbGVTZWxlY3RlZERldmljZXNVcGRhdGVkLmJpbmQoX3RoaXMpKTtcbiAgICAgICAgX3RoaXMuX2RhaWx5Lm9uKFwibG9jYWwtYXVkaW8tbGV2ZWxcIiwgX3RoaXMuX2hhbmRsZUxvY2FsQXVkaW9MZXZlbC5iaW5kKF90aGlzKSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRGFpbHlNZWRpYU1hbmFnZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICQyMmVjZTA0NTI5MGM5OTZhJHZhciRfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCBQcm9taXNlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbmZvcywgZGV2aWNlcywgY2FtcywgbWljcywgc3BlYWtlcnM7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX207XG4gICAgICAgICAgICByZXR1cm4gJDIyZWNlMDQ1MjkwYzk5NmEkdmFyJF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9vKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoKF9vLmxhYmVsKXtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRGFpbHlNZWRpYU1hbmFnZXIgYWxyZWFkeSBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyIC8qcmV0dXJuKi8gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCAvKnlpZWxkKi8gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhaWx5LnN0YXJ0Q2FtZXJhKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRWaWRlb09mZjogIXRoaXMuX2NhbUVuYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QXVkaW9PZmY6ICF0aGlzLl9taWNFbmFibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm9zID0gX28uc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0IC8qeWllbGQqLyAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGFpbHkuZW51bWVyYXRlRGV2aWNlcygpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VzID0gX28uc2VudCgpLmRldmljZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW1zID0gZGV2aWNlcy5maWx0ZXIoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmtpbmQgPT09IFwidmlkZW9pbnB1dFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaWNzID0gZGV2aWNlcy5maWx0ZXIoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmtpbmQgPT09IFwiYXVkaW9pbnB1dFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVha2VycyA9IGRldmljZXMuZmlsdGVyKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5raW5kID09PSBcImF1ZGlvb3V0cHV0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuX2NhbGxiYWNrcykub25BdmFpbGFibGVDYW1zVXBkYXRlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCB8fCBfYi5jYWxsKF9hLCBjYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfZCA9IChfYyA9IHRoaXMuX2NhbGxiYWNrcykub25BdmFpbGFibGVNaWNzVXBkYXRlZCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCB8fCBfZC5jYWxsKF9jLCBtaWNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfZiA9IChfZSA9IHRoaXMuX2NhbGxiYWNrcykub25BdmFpbGFibGVTcGVha2Vyc1VwZGF0ZWQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgfHwgX2YuY2FsbChfZSwgc3BlYWtlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRDYW0gPSBpbmZvcy5jYW1lcmE7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2ggPSAoX2cgPSB0aGlzLl9jYWxsYmFja3MpLm9uQ2FtVXBkYXRlZCkgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCB8fCBfaC5jYWxsKF9nLCBpbmZvcy5jYW1lcmEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRNaWMgPSBpbmZvcy5taWM7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2sgPSAoX2ogPSB0aGlzLl9jYWxsYmFja3MpLm9uTWljVXBkYXRlZCkgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCB8fCBfay5jYWxsKF9qLCBpbmZvcy5taWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRTcGVha2VyID0gaW5mb3Muc3BlYWtlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfbSA9IChfbCA9IHRoaXMuX2NhbGxiYWNrcykub25TcGVha2VyVXBkYXRlZCkgPT09IG51bGwgfHwgX20gPT09IHZvaWQgMCB8fCBfbS5jYWxsKF9sLCBpbmZvcy5zcGVha2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIXRoaXMuX2RhaWx5LmlzTG9jYWxBdWRpb0xldmVsT2JzZXJ2ZXJSdW5uaW5nKCkpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyAvKmJyZWFrKi8gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDRcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQgLyp5aWVsZCovICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYWlseS5zdGFydExvY2FsQXVkaW9MZXZlbE9ic2VydmVyKDEwMClcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9vLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9vLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl93YXZTdHJlYW1QbGF5ZXIpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyAvKmJyZWFrKi8gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDZcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQgLyp5aWVsZCovICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl93YXZTdHJlYW1QbGF5ZXIuY29ubmVjdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBfby5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3JlbW90ZUF1ZGlvTGV2ZWxJbnRlcnZhbCkgdGhpcy5fcmVtb3RlQXVkaW9MZXZlbEludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmVxdWVuY2llcyA9IF90aGlzLl93YXZTdHJlYW1QbGF5ZXIuZ2V0RnJlcXVlbmNpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXZlVmFsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9hID0gZnJlcXVlbmNpZXMudmFsdWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSBhdmVWYWwgPSBmcmVxdWVuY2llcy52YWx1ZXMucmVkdWNlKGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgKyBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApIC8gZnJlcXVlbmNpZXMudmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlUmVtb3RlQXVkaW9MZXZlbChhdmVWYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9vLmxhYmVsID0gNjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyIC8qcmV0dXJuKi8gXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERhaWx5TWVkaWFNYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkMjJlY2UwNDUyOTBjOTk2YSR2YXIkX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgUHJvbWlzZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuICQyMmVjZTA0NTI5MGM5OTZhJHZhciRfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfYSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRGFpbHlNZWRpYU1hbmFnZXIgYWxyZWFkeSBjb25uZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAyIC8qcmV0dXJuKi8gXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgMiAvKnJldHVybiovICxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkMjJlY2UwNDUyOTBjOTk2YSR2YXIkX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkMjJlY2UwNDUyOTBjOTk2YSR2YXIkX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24oX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaChfYS5sYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0UmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0IC8qeWllbGQqLyAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMiAvKnJldHVybiovIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWljRW5hYmxlZCkgdGhpcy5fc3RhcnRSZWNvcmRpbmcoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAyIC8qcmV0dXJuKi8gXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERhaWx5TWVkaWFNYW5hZ2VyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkMjJlY2UwNDUyOTBjOTk2YSR2YXIkX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgUHJvbWlzZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgcmV0dXJuICQyMmVjZTA0NTI5MGM5OTZhJHZhciRfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfYykge1xuICAgICAgICAgICAgICAgIHN3aXRjaChfYy5sYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZW1vdGVBdWRpb0xldmVsSW50ZXJ2YWwpIGNsZWFySW50ZXJ2YWwodGhpcy5fcmVtb3RlQXVkaW9MZXZlbEludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW90ZUF1ZGlvTGV2ZWxJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYWlseS5sZWF2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEF1ZGlvVHJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0IC8qeWllbGQqLyAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5fbWVkaWFTdHJlYW1SZWNvcmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVuZCgpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLl93YXZTdHJlYW1QbGF5ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgfHwgX2IuaW50ZXJydXB0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIgLypyZXR1cm4qLyBcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRGFpbHlNZWRpYU1hbmFnZXIucHJvdG90eXBlLnVzZXJTdGFydGVkU3BlYWtpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICQyMmVjZTA0NTI5MGM5OTZhJHZhciRfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCBQcm9taXNlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiAkMjJlY2UwNDUyOTBjOTk2YSR2YXIkX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24oX2IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAyIC8qcmV0dXJuKi8gLFxuICAgICAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLl93YXZTdHJlYW1QbGF5ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbnRlcnJ1cHQoKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEYWlseU1lZGlhTWFuYWdlci5wcm90b3R5cGUuYnVmZmVyQm90QXVkaW8gPSBmdW5jdGlvbihkYXRhLCBpZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLl93YXZTdHJlYW1QbGF5ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGQxNkJpdFBDTShkYXRhLCBpZCk7XG4gICAgfTtcbiAgICBEYWlseU1lZGlhTWFuYWdlci5wcm90b3R5cGUuZ2V0QWxsTWljcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJDIyZWNlMDQ1MjkwYzk5NmEkdmFyJF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIFByb21pc2UsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGRldmljZXM7XG4gICAgICAgICAgICByZXR1cm4gJDIyZWNlMDQ1MjkwYzk5NmEkdmFyJF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoKF9hLmxhYmVsKXtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0IC8qeWllbGQqLyAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGFpbHkuZW51bWVyYXRlRGV2aWNlcygpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VzID0gX2Euc2VudCgpLmRldmljZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIgLypyZXR1cm4qLyAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlcy5maWx0ZXIoZnVuY3Rpb24oZGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXZpY2Uua2luZCA9PT0gXCJhdWRpb2lucHV0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRGFpbHlNZWRpYU1hbmFnZXIucHJvdG90eXBlLmdldEFsbENhbXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICQyMmVjZTA0NTI5MGM5OTZhJHZhciRfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCBQcm9taXNlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkZXZpY2VzO1xuICAgICAgICAgICAgcmV0dXJuICQyMmVjZTA0NTI5MGM5OTZhJHZhciRfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaChfYS5sYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCAvKnlpZWxkKi8gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhaWx5LmVudW1lcmF0ZURldmljZXMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlcyA9IF9hLnNlbnQoKS5kZXZpY2VzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyIC8qcmV0dXJuKi8gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZXMuZmlsdGVyKGZ1bmN0aW9uKGRldmljZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGV2aWNlLmtpbmQgPT09IFwidmlkZW9pbnB1dFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERhaWx5TWVkaWFNYW5hZ2VyLnByb3RvdHlwZS5nZXRBbGxTcGVha2VycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJDIyZWNlMDQ1MjkwYzk5NmEkdmFyJF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIFByb21pc2UsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGRldmljZXM7XG4gICAgICAgICAgICByZXR1cm4gJDIyZWNlMDQ1MjkwYzk5NmEkdmFyJF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoKF9hLmxhYmVsKXtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0IC8qeWllbGQqLyAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGFpbHkuZW51bWVyYXRlRGV2aWNlcygpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VzID0gX2Euc2VudCgpLmRldmljZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIgLypyZXR1cm4qLyAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlcy5maWx0ZXIoZnVuY3Rpb24oZGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXZpY2Uua2luZCA9PT0gXCJhdWRpb291dHB1dFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERhaWx5TWVkaWFNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVNaWMgPSBmdW5jdGlvbihtaWNJZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9kYWlseS5zZXRJbnB1dERldmljZXNBc3luYyh7XG4gICAgICAgICAgICBhdWRpb0RldmljZUlkOiBtaWNJZFxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGRldmljZUluZm8pIHtcbiAgICAgICAgICAgIF90aGlzLl9zZWxlY3RlZE1pYyA9IGRldmljZUluZm8ubWljO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERhaWx5TWVkaWFNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVDYW0gPSBmdW5jdGlvbihjYW1JZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9kYWlseS5zZXRJbnB1dERldmljZXNBc3luYyh7XG4gICAgICAgICAgICB2aWRlb0RldmljZUlkOiBjYW1JZFxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGRldmljZUluZm8pIHtcbiAgICAgICAgICAgIF90aGlzLl9zZWxlY3RlZENhbSA9IGRldmljZUluZm8uY2FtZXJhO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERhaWx5TWVkaWFNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVTcGVha2VyID0gZnVuY3Rpb24oc3BlYWtlcklkKSB7XG4gICAgICAgIHJldHVybiAkMjJlY2UwNDUyOTBjOTk2YSR2YXIkX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgUHJvbWlzZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc0lELCBzcGVha2VycywgZGVmYXVsdFNwZWFrZXJfMSwgZGVmYXVsdFNwZWFrZXJDcDtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgcmV0dXJuICQyMmVjZTA0NTI5MGM5OTZhJHZhciRfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfYykge1xuICAgICAgICAgICAgICAgIHN3aXRjaChfYy5sYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGVha2VySWQgIT09IFwiZGVmYXVsdFwiICYmIHRoaXMuX3NlbGVjdGVkU3BlYWtlci5kZXZpY2VJZCA9PT0gc3BlYWtlcklkKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIgLypyZXR1cm4qLyBcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBzSUQgPSBzcGVha2VySWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzSUQgPT09IFwiZGVmYXVsdFwiKSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzIC8qYnJlYWsqLyAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCAvKnlpZWxkKi8gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0QWxsU3BlYWtlcnMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3BlYWtlcnMgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3BlYWtlcl8xID0gc3BlYWtlcnMuZmluZChmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMuZGV2aWNlSWQgPT09IFwiZGVmYXVsdFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRlZmF1bHRTcGVha2VyXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJObyBkZWZhdWx0IHNwZWFrZXIgZm91bmRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMiAvKnJldHVybiovIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVha2Vycy5zcGxpY2Uoc3BlYWtlcnMuaW5kZXhPZihkZWZhdWx0U3BlYWtlcl8xKSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3BlYWtlckNwID0gc3BlYWtlcnMuZmluZChmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTcGVha2VyXzEubGFiZWwuaW5jbHVkZXMocy5sYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNJRCA9IChfYSA9IGRlZmF1bHRTcGVha2VyQ3AgPT09IG51bGwgfHwgZGVmYXVsdFNwZWFrZXJDcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmYXVsdFNwZWFrZXJDcC5kZXZpY2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc3BlYWtlcklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLl93YXZTdHJlYW1QbGF5ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgfHwgX2IudXBkYXRlU3BlYWtlcihzSUQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2VsZWN0ZWRTcGVha2VyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VJZDogc3BlYWtlcklkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5fY2FsbGJhY2tzKS5vblNwZWFrZXJVcGRhdGVkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwIHx8IF9iLmNhbGwoX2EsIF90aGlzLl9zZWxlY3RlZFNwZWFrZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIgLypyZXR1cm4qLyBcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhaWx5TWVkaWFNYW5hZ2VyLnByb3RvdHlwZSwgXCJzZWxlY3RlZE1pY1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRNaWM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGFpbHlNZWRpYU1hbmFnZXIucHJvdG90eXBlLCBcInNlbGVjdGVkQ2FtXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZENhbTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYWlseU1lZGlhTWFuYWdlci5wcm90b3R5cGUsIFwic2VsZWN0ZWRTcGVha2VyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZFNwZWFrZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBEYWlseU1lZGlhTWFuYWdlci5wcm90b3R5cGUuZW5hYmxlTWljID0gZnVuY3Rpb24oZW5hYmxlKSB7XG4gICAgICAgIHJldHVybiAkMjJlY2UwNDUyOTBjOTk2YSR2YXIkX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgUHJvbWlzZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gJDIyZWNlMDQ1MjkwYzk5NmEkdmFyJF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9iKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWljRW5hYmxlZCA9IGVuYWJsZTtcbiAgICAgICAgICAgICAgICBpZiAoISgoX2EgPSB0aGlzLl9kYWlseS5wYXJ0aWNpcGFudHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsKSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgMiAvKnJldHVybiovIFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgdGhpcy5fZGFpbHkuc2V0TG9jYWxBdWRpbyhlbmFibGUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tZWRpYVN0cmVhbVJlY29yZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tZWRpYVN0cmVhbVJlY29yZGVyLmdldFN0YXR1cygpID09PSBcInBhdXNlZFwiKSB0aGlzLl9zdGFydFJlY29yZGluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UsIHdlJ2xsIHJlY29yZCBvbiB0aGUgdHJhY2stc3RhcnRlZCBldmVudFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX21lZGlhU3RyZWFtUmVjb3JkZXIuZ2V0U3RhdHVzKCkgPT09IFwicmVjb3JkaW5nXCIpIHRoaXMuX21lZGlhU3RyZWFtUmVjb3JkZXIucGF1c2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgMiAvKnJldHVybiovIFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEYWlseU1lZGlhTWFuYWdlci5wcm90b3R5cGUuZW5hYmxlQ2FtID0gZnVuY3Rpb24oZW5hYmxlKSB7XG4gICAgICAgIHRoaXMuX2NhbUVuYWJsZWQgPSBlbmFibGU7XG4gICAgICAgIHRoaXMuX2RhaWx5LnNldExvY2FsVmlkZW8oZW5hYmxlKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYWlseU1lZGlhTWFuYWdlci5wcm90b3R5cGUsIFwiaXNDYW1FbmFibGVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYWlseS5sb2NhbFZpZGVvKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGFpbHlNZWRpYU1hbmFnZXIucHJvdG90eXBlLCBcImlzTWljRW5hYmxlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGFpbHkubG9jYWxBdWRpbygpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRGFpbHlNZWRpYU1hbmFnZXIucHJvdG90eXBlLnRyYWNrcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgdmFyIHBhcnRpY2lwYW50cyA9IHRoaXMuX2RhaWx5LnBhcnRpY2lwYW50cygpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYWw6IHtcbiAgICAgICAgICAgICAgICBhdWRpbzogKF9jID0gKF9iID0gKF9hID0gcGFydGljaXBhbnRzID09PSBudWxsIHx8IHBhcnRpY2lwYW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFydGljaXBhbnRzLmxvY2FsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHJhY2tzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYXVkaW8pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5wZXJzaXN0ZW50VHJhY2ssXG4gICAgICAgICAgICAgICAgdmlkZW86IChfZiA9IChfZSA9IChfZCA9IHBhcnRpY2lwYW50cyA9PT0gbnVsbCB8fCBwYXJ0aWNpcGFudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcnRpY2lwYW50cy5sb2NhbCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnRyYWNrcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnZpZGVvKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YucGVyc2lzdGVudFRyYWNrXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBEYWlseU1lZGlhTWFuYWdlci5wcm90b3R5cGUuX3N0YXJ0UmVjb3JkaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkIHx8ICF0aGlzLl9tZWRpYVN0cmVhbVJlY29yZGVyKSByZXR1cm47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVJlY29yZGVyLnJlY29yZChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3VzZXJBdWRpb0NhbGxiYWNrKGRhdGEubW9ubyk7XG4gICAgICAgICAgICB9LCB0aGlzLl9yZWNvcmRlckNodW5rU2l6ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBlO1xuICAgICAgICAgICAgaWYgKCFlcnIubWVzc2FnZS5pbmNsdWRlcyhcIkFscmVhZHkgcmVjb3JkaW5nXCIpKSBjb25zb2xlLmVycm9yKFwiRXJyb3Igc3RhcnRpbmcgcmVjb3JkaW5nXCIsIGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEYWlseU1lZGlhTWFuYWdlci5wcm90b3R5cGUuX2hhbmRsZUF2YWlsYWJsZURldmljZXNVcGRhdGVkID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuX2NhbGxiYWNrcykub25BdmFpbGFibGVDYW1zVXBkYXRlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCB8fCBfYi5jYWxsKF9hLCBldmVudC5hdmFpbGFibGVEZXZpY2VzLmZpbHRlcihmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5raW5kID09PSBcInZpZGVvaW5wdXRcIjtcbiAgICAgICAgfSkpO1xuICAgICAgICAoX2QgPSAoX2MgPSB0aGlzLl9jYWxsYmFja3MpLm9uQXZhaWxhYmxlTWljc1VwZGF0ZWQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgfHwgX2QuY2FsbChfYywgZXZlbnQuYXZhaWxhYmxlRGV2aWNlcy5maWx0ZXIoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQua2luZCA9PT0gXCJhdWRpb2lucHV0XCI7XG4gICAgICAgIH0pKTtcbiAgICAgICAgKF9mID0gKF9lID0gdGhpcy5fY2FsbGJhY2tzKS5vbkF2YWlsYWJsZVNwZWFrZXJzVXBkYXRlZCkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCB8fCBfZi5jYWxsKF9lLCBldmVudC5hdmFpbGFibGVEZXZpY2VzLmZpbHRlcihmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5raW5kID09PSBcImF1ZGlvb3V0cHV0XCI7XG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkU3BlYWtlci5kZXZpY2VJZCA9PT0gXCJkZWZhdWx0XCIpIHRoaXMudXBkYXRlU3BlYWtlcihcImRlZmF1bHRcIik7XG4gICAgfTtcbiAgICBEYWlseU1lZGlhTWFuYWdlci5wcm90b3R5cGUuX2hhbmRsZVNlbGVjdGVkRGV2aWNlc1VwZGF0ZWQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLl9zZWxlY3RlZENhbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRldmljZUlkKSAhPT0gZXZlbnQuZGV2aWNlcy5jYW1lcmEpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkQ2FtID0gZXZlbnQuZGV2aWNlcy5jYW1lcmE7XG4gICAgICAgICAgICAoX2MgPSAoX2IgPSB0aGlzLl9jYWxsYmFja3MpLm9uQ2FtVXBkYXRlZCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCB8fCBfYy5jYWxsKF9iLCBldmVudC5kZXZpY2VzLmNhbWVyYSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgoX2QgPSB0aGlzLl9zZWxlY3RlZE1pYykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmRldmljZUlkKSAhPT0gZXZlbnQuZGV2aWNlcy5taWMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkTWljID0gZXZlbnQuZGV2aWNlcy5taWM7XG4gICAgICAgICAgICAoX2YgPSAoX2UgPSB0aGlzLl9jYWxsYmFja3MpLm9uTWljVXBkYXRlZCkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCB8fCBfZi5jYWxsKF9lLCBldmVudC5kZXZpY2VzLm1pYyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhaWx5TWVkaWFNYW5hZ2VyLnByb3RvdHlwZS5faGFuZGxlTG9jYWxBdWRpb0xldmVsID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5fY2FsbGJhY2tzKS5vbkxvY2FsQXVkaW9MZXZlbCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCB8fCBfYi5jYWxsKF9hLCBldi5hdWRpb0xldmVsKTtcbiAgICB9O1xuICAgIERhaWx5TWVkaWFNYW5hZ2VyLnByb3RvdHlwZS5faGFuZGxlUmVtb3RlQXVkaW9MZXZlbCA9IGZ1bmN0aW9uKGF1ZGlvTGV2ZWwpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5fY2FsbGJhY2tzKS5vblJlbW90ZUF1ZGlvTGV2ZWwpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgfHwgX2IuY2FsbChfYSwgYXVkaW9MZXZlbCwgJDIyZWNlMDQ1MjkwYzk5NmEkdmFyJGJvdFBhcnRpY2lwYW50KCkpO1xuICAgIH07XG4gICAgRGFpbHlNZWRpYU1hbmFnZXIucHJvdG90eXBlLmhhbmRsZVRyYWNrU3RhcnRlZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiAkMjJlY2UwNDUyOTBjOTk2YSR2YXIkX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzdGF0dXMsIF9hO1xuICAgICAgICAgICAgdmFyIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICAgICAgcmV0dXJuICQyMmVjZTA0NTI5MGM5OTZhJHZhciRfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfZikge1xuICAgICAgICAgICAgICAgIHN3aXRjaChfZi5sYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKChfYiA9IGV2ZW50LnBhcnRpY2lwYW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubG9jYWwpKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIgLypyZXR1cm4qLyBcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShldmVudC50cmFjay5raW5kID09PSBcImF1ZGlvXCIpKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMgLypicmVhayovICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbWVkaWFTdHJlYW1SZWNvcmRlcikgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzIC8qYnJlYWsqLyAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IHRoaXMuX21lZGlhU3RyZWFtUmVjb3JkZXIuZ2V0U3RhdHVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaChfYSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZGVkXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzIC8qYnJlYWsqLyAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBhdXNlZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMyAvKmJyZWFrKi8gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWNvcmRpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMgLypicmVhayovICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyAvKmJyZWFrKi8gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDRcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCAvKnlpZWxkKi8gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhU3RyZWFtUmVjb3JkZXIuYmVnaW4oZXZlbnQudHJhY2spXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRSZWNvcmRpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29ubmVjdFJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdFJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdFJlc29sdmUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyAvKmJyZWFrKi8gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDlcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0UmVjb3JkaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMgLypicmVhayovICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA5XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLl9jdXJyZW50QXVkaW9UcmFjayAhPT0gZXZlbnQudHJhY2spKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMgLypicmVhayovICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA3XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0IC8qeWllbGQqLyAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1SZWNvcmRlci5lbmQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0IC8qeWllbGQqLyAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1SZWNvcmRlci5iZWdpbihldmVudC50cmFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0UmVjb3JkaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMgLypicmVhayovICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA4XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJ0cmFjay1zdGFydGVkIGV2ZW50IHJlY2VpdmVkIGZvciBjdXJyZW50IHRyYWNrIGFuZCBhbHJlYWR5IHJlY29yZGluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mLmxhYmVsID0gODtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzIC8qYnJlYWsqLyAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEF1ZGlvVHJhY2sgPSBldmVudC50cmFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mLmxhYmVsID0gMTA7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2QgPSAoX2MgPSB0aGlzLl9jYWxsYmFja3MpLm9uVHJhY2tTdGFydGVkKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwIHx8IF9kLmNhbGwoX2MsIGV2ZW50LnRyYWNrLCBldmVudC5wYXJ0aWNpcGFudCA/ICQyMmVjZTA0NTI5MGM5OTZhJHZhciRkYWlseVBhcnRpY2lwYW50VG9QYXJ0aWNpcGFudChldmVudC5wYXJ0aWNpcGFudCkgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9lID0gdGhpcy5vblRyYWNrU3RhcnRlZENhbGxiYWNrKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwIHx8IF9lLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyIC8qcmV0dXJuKi8gXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERhaWx5TWVkaWFNYW5hZ2VyLnByb3RvdHlwZS5oYW5kbGVUcmFja1N0b3BwZWQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGlmICghKChfYSA9IGV2ZW50LnBhcnRpY2lwYW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWwpKSByZXR1cm47XG4gICAgICAgIGlmIChldmVudC50cmFjay5raW5kID09PSBcImF1ZGlvXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tZWRpYVN0cmVhbVJlY29yZGVyICYmIHRoaXMuX21lZGlhU3RyZWFtUmVjb3JkZXIuZ2V0U3RhdHVzKCkgPT09IFwicmVjb3JkaW5nXCIpIHRoaXMuX21lZGlhU3RyZWFtUmVjb3JkZXIucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICAoX2MgPSAoX2IgPSB0aGlzLl9jYWxsYmFja3MpLm9uVHJhY2tTdG9wcGVkKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwIHx8IF9jLmNhbGwoX2IsIGV2ZW50LnRyYWNrLCBldmVudC5wYXJ0aWNpcGFudCA/ICQyMmVjZTA0NTI5MGM5OTZhJHZhciRkYWlseVBhcnRpY2lwYW50VG9QYXJ0aWNpcGFudChldmVudC5wYXJ0aWNpcGFudCkgOiB1bmRlZmluZWQpO1xuICAgICAgICAoX2QgPSB0aGlzLm9uVHJhY2tTdG9wcGVkQ2FsbGJhY2spID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgfHwgX2QuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGFpbHlNZWRpYU1hbmFnZXI7XG59KCgwLCAkZmM0OWE1NmNkODczOTEyNyRleHBvcnQkNGEwYzQ2ZGJiZTJkZGI2NykpO1xudmFyICQyMmVjZTA0NTI5MGM5OTZhJHZhciRkYWlseVBhcnRpY2lwYW50VG9QYXJ0aWNpcGFudCA9IGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogcC51c2VyX2lkLFxuICAgICAgICBsb2NhbDogcC5sb2NhbCxcbiAgICAgICAgbmFtZTogcC51c2VyX25hbWVcbiAgICB9O1xufTtcbnZhciAkMjJlY2UwNDUyOTBjOTk2YSR2YXIkYm90UGFydGljaXBhbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogXCJib3RcIixcbiAgICAgICAgbG9jYWw6IGZhbHNlLFxuICAgICAgICBuYW1lOiBcIkJvdFwiXG4gICAgfTtcbn07XG5cblxuXG5cbnZhciAkMDMyMzgwZGJjZjNmNGUxMyR2YXIkX19leHRlbmRzID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2V4dGVuZHMgfHwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKHtcbiAgICAgICAgICAgIF9fcHJvdG9fXzogW11cbiAgICAgICAgfSkgaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihkLCBiKSB7XG4gICAgICAgICAgICBkLl9fcHJvdG9fXyA9IGI7XG4gICAgICAgIH0gfHwgZnVuY3Rpb24oZCwgYikge1xuICAgICAgICAgICAgZm9yKHZhciBwIGluIGIpaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICAgICAgICB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSgpO1xudmFyICQwMzIzODBkYmNmM2Y0ZTEzJHZhciRfX2F3YWl0ZXIgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXdhaXRlciB8fCBmdW5jdGlvbih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgJDAzMjM4MGRiY2YzZjRlMTMkdmFyJF9fZ2VuZXJhdG9yID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2dlbmVyYXRvciB8fCBmdW5jdGlvbih0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7XG4gICAgICAgIGxhYmVsOiAwLFxuICAgICAgICBzZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTtcbiAgICAgICAgICAgIHJldHVybiB0WzFdO1xuICAgICAgICB9LFxuICAgICAgICB0cnlzOiBbXSxcbiAgICAgICAgb3BzOiBbXVxuICAgIH0sIGYsIHksIHQsIGcgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgSXRlcmF0b3IgPT09IFwiZnVuY3Rpb25cIiA/IEl0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpO1xuICAgIHJldHVybiBnLm5leHQgPSB2ZXJiKDApLCBnW1widGhyb3dcIl0gPSB2ZXJiKDEpLCBnW1wicmV0dXJuXCJdID0gdmVyYigyKSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcChbXG4gICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICB2XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXyl0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtcbiAgICAgICAgICAgICAgICBvcFswXSAmIDIsXG4gICAgICAgICAgICAgICAgdC52YWx1ZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHN3aXRjaChvcFswXSl7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgb3AgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgb3AgPSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5vcHMucHVzaChvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb3AgPSBbXG4gICAgICAgICAgICAgICAgNixcbiAgICAgICAgICAgICAgICBlXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIGYgPSB0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLFxuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cbn07XG52YXIgJDAzMjM4MGRiY2YzZjRlMTMkdmFyJF9fc3ByZWFkQXJyYXkgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fc3ByZWFkQXJyYXkgfHwgZnVuY3Rpb24odG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG52YXIgJDAzMjM4MGRiY2YzZjRlMTMkdmFyJHJlYWR5U3RhdGVzID0gW1xuICAgIFwiQ09OTkVDVElOR1wiLFxuICAgIFwiT1BFTlwiLFxuICAgIFwiQ0xPU0lOR1wiLFxuICAgIFwiQ0xPU0VEXCJcbl07XG52YXIgJDAzMjM4MGRiY2YzZjRlMTMkdmFyJEtFRVBfQUxJVkVfSU5URVJWQUwgPSA1MDAwO1xudmFyICQwMzIzODBkYmNmM2Y0ZTEzJHZhciRLRUVQX0FMSVZFX1RJTUVPVVQgPSAxNTAwMDtcbi8vIGNsaWVudCBzaWRlIGNvZGUgaW4gc291cFNGVSBoYXMgYSB0aW1lb3V0IG9mIDE1IHNlY29uZHMgZm9yIGNvbW1hbmQgcmVzcG9uc2Vcbi8vIDUgc2Vjb25kcyBzZWVtcyByZWFzb25hYmxlIHRoYXQgaXQgcHJvdmlkZXMgcm91Z2hseSAzIHJldHJ5IGF0dGVtcHRzXG52YXIgJDAzMjM4MGRiY2YzZjRlMTMkdmFyJFdFQlNPQ0tFVF9DT05ORUNUSU9OX1RJTUVPVVQgPSAxNTAwMDA7XG52YXIgJDAzMjM4MGRiY2YzZjRlMTMkdmFyJERFRkFVTFRfUkVDT05ORUNUX0FUVEVNUFRTID0gMjtcbnZhciAkMDMyMzgwZGJjZjNmNGUxMyR2YXIkTUFYX1JFQ09OTkVDVF9BVFRFTVBUUyA9IDEwO1xudmFyICQwMzIzODBkYmNmM2Y0ZTEzJHZhciRERUZBVUxUX1JFQ09OTkVDVF9JTlRFUlZBTCA9IDEwMDA7XG52YXIgJDAzMjM4MGRiY2YzZjRlMTMkdmFyJE1BWF9SRUNPTk5FQ1RfSU5URVJWQUwgPSAzMDAwMDtcbnZhciAkMDMyMzgwZGJjZjNmNGUxMyR2YXIkREVGQVVMVF9SRUNPTk5FQ1RfREVDQVkgPSAxLjU7XG52YXIgJDAzMjM4MGRiY2YzZjRlMTMkdmFyJFdFQlNPQ0tFVF9USU1FT1VUX0NPREUgPSA0MTAwO1xudmFyICQwMzIzODBkYmNmM2Y0ZTEzJHZhciRTSUdfQ09OTkVDVElPTl9DQU5DRUxFRCA9IFwiU0lHX0NPTk5FQ1RJT05fQ0FOQ0VMRURcIjtcbnZhciAkMDMyMzgwZGJjZjNmNGUxMyR2YXIkV0VCU09DS0VUX0VSUk9SID0gXCJXRUJTT0NLRVRfRVJST1JcIjtcbnZhciAkMDMyMzgwZGJjZjNmNGUxMyR2YXIkTE9HX0xFVkVMO1xuKGZ1bmN0aW9uKExPR19MRVZFTCkge1xuICAgIExPR19MRVZFTFtMT0dfTEVWRUxbXCJERUJVR1wiXSA9IDBdID0gXCJERUJVR1wiO1xuICAgIExPR19MRVZFTFtMT0dfTEVWRUxbXCJFUlJPUlwiXSA9IDFdID0gXCJFUlJPUlwiO1xuICAgIExPR19MRVZFTFtMT0dfTEVWRUxbXCJJTkZPXCJdID0gMl0gPSBcIklORk9cIjtcbiAgICBMT0dfTEVWRUxbTE9HX0xFVkVMW1wiV0FSTlwiXSA9IDNdID0gXCJXQVJOXCI7XG59KSgkMDMyMzgwZGJjZjNmNGUxMyR2YXIkTE9HX0xFVkVMIHx8ICgkMDMyMzgwZGJjZjNmNGUxMyR2YXIkTE9HX0xFVkVMID0ge30pKTtcbnZhciAkMDMyMzgwZGJjZjNmNGUxMyR2YXIkcldlYlNvY2tldCA9IC8qKiBAY2xhc3MgKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gcldlYlNvY2tldCh1cmwsIHByb3RvY29scykge1xuICAgICAgICB0aGlzLl9jbG9zZWRNYW51YWxseSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9lcnJvcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JlamVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RpbWVkX291dCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbml0aWFsQ29ubmVjdGlvbk9rID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3dzID0gbmV3IFdlYlNvY2tldCh1cmwsIHByb3RvY29scyk7XG4gICAgfVxuICAgIHJXZWJTb2NrZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl93cy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIC8vIEFkZCBvdGhlciBXZWJTb2NrZXQgbWV0aG9kcyBhcyBuZWVkZWRcbiAgICByV2ViU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgICAgICB0aGlzLl93cy5jbG9zZShjb2RlLCByZWFzb24pO1xuICAgIH07XG4gICAgcldlYlNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fd3Muc2VuZChkYXRhKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyV2ViU29ja2V0LnByb3RvdHlwZSwgXCJ1cmxcIiwge1xuICAgICAgICAvLyBBZGQgZ2V0dGVycyBmb3IgV2ViU29ja2V0IHByb3BlcnRpZXNcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93cy51cmw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocldlYlNvY2tldC5wcm90b3R5cGUsIFwicmVhZHlTdGF0ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd3MucmVhZHlTdGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiByV2ViU29ja2V0O1xufSgpO1xuLyoqXG4gKiBCdWlsZHMgb24gdG9wIG9mIEphdmFzY3JpcHQgV2Vic29ja2V0c1xuICpcbiAqIFRoaXMgYmVoYXZlcyBsaWtlIHRoZSBXZWJzb2NrZXQgbGlicmFyeSBpbiBldmVyeSB3YXksIGV4Y2VwdCBpZiBpdCBmYWlscyB0b1xuICogY29ubmVjdCBvciBpZiBpdCBnZXRzIGRpc2Nvbm5lY3RlZCwgaXQgd2lsbCB0cnkgdG8gcmVjb25uZWN0IGRlcGVuZGluZyBvblxuICogdGhlIG1heGltdW0gbnVtYmVyIG9mIHJlY29ubmVjdCBhdHRlbXB0cyBzZXQuIHJldHJ5IGlzIG5vdCBlbmFibGVkIGZvciBpbml0aWFsXG4gKiBjb25uZWN0aW9uLiBXaGVuIGluaXRpYWwgY29ubmVjdGlvbiBmYWlscyBpdCBpcyBiZXN0IHRvIGNoZWNrIHlvdXJzZWxmIGJlZm9yZVxuICogeW91IGtlZXAgd3JlY2tpbicgeW91cnNlbGYuXG4gKlxuICogSXQgaXMgQVBJIGNvbXBhdGlibGUsIHNvIHdoZW4geW91IGhhdmU6XG4gKiAgIHdzID0gbmV3IFdlYlNvY2tldCgnd3M6Ly8uLi4uJyk7XG4gKiB5b3UgY2FuIHJlcGxhY2Ugd2l0aDpcbiAqICAgd3MgPSBuZXcgUmVjb25uZWN0aW5nV2ViU29ja2V0KCd3czovLy4uLi4nKTtcbiAqXG4gKiBXaGlsZSBpdCBpcyBBUEkgY29tcGF0aWJsZSB3aXRoIHRoZSBOb2RlSlMgd3MgbGlicmFyeSwgd2UgcHJvdmlkZSB0aGVcbiAqIGZvbGxvd2luZyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgYW5kIGV2ZW50cyBvbiB0aGUgUmVjb25uZWN0aW5nV2ViU29ja2V0LlxuICpcbiAqIEV2ZW50czpcbiAqXG4gKiBjb25uZWN0aW9uLXRpbWVvdXRcbiAqIC0gRW1pdHRlZCB3aGVuIHRoZSB3ZWIgc29ja2V0IGNvbm5lY3Rpb24gdGltZXMgb3V0LlxuICpcbiAqIHJlY29ubmVjdGluZ1xuICogLSBFbWl0dGVkIGFmdGVyIGEgbWFudWFsIGNsb3NlIG9mIHRoZSB3ZWIgc29ja2V0IGlzIGRvbmUgYW5kIGJlZm9yZSByZXRyeWluZ1xuICogICB0aGUgY29ubmVjdGlvbi5cbiAqXG4gKiByZWNvbm5lY3QtZmFpbGVkXG4gKiAtIEVtaXR0ZWQgd2hlbiB0aGUgbnVtYmVyIG9mIGNvbm5lY3Rpb24gYXR0ZW1wdHMgZXhjZWVkcyB0aGUgc2V0IG51bWJlciBvZlxuICogICByZWNvbm5lY3Rpb24gYXR0ZW1wdHMuXG4gKlxuICoga2VlcC1hbGl2ZVxuICogLSBFbWl0dGVkIHdoZW4gdGhlIHNldCBrZWVwIGFsaXZlIGludGVydmFsIGVsYXBzZXMuIFRoaXMgZXZlbnQgbWF5IGJlIHVzZWRcbiAqICAgdG8gaGF2ZSBwaW5nIHBvbmcga2VlcC1hbGl2ZSBtZWNoYW5pc20gZm9yIHdlYiBzb2NrZXQgaGVhbHRoLlxuICpcbiAqIFByb3BlcnRpZXM6XG4gKlxuICoga2VlcEFsaXZlVGltZW91dFxuICogLSBUaGUgdGltZW91dCBmb3Iga2VlcC1hbGl2ZS4gRGVmYXVsdDogMTUwMDBcbiAqXG4gKiBrZWVwQWxpdmVJbnRlcnZhbFxuICogLSBUaGUgaW50ZXJ2YWwgYXQgd2hpY2ggdG8gZW1pdCBrZWVwLWFsaXZlIGV2ZW50LiBEZWZhdWx0OiA1MDAwXG4gKlxuICogc2hvdWxkUmV0cnlGblxuICogLSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIHNob3VsZCByZXR1cm4gYm9vbGVhbiB0byBkZXRlcm1pbmUgaWYgYSB3ZWJcbiAqICAgc29ja2V0IHJlY29ubmVjdGlvbiBhdHRlbXB0IHNob3VsZCBiZSBtYWRlLiBXaGVuIG5vdCBzZXQsIGNvbm5lY3Rpb24gaXNcbiAqICAgYWx3YXlzIHJldHJpZWQuXG4gKlxuICogY29ubmVjdGlvblRpbWVvdXRcbiAqIC0gVGhlIHRpbWVvdXQgaW50ZXJ2YWwgZm9yIGNvbnNpZGVyaW5nIHdoZXRoZXIgdGhlIGNvbm5lY3Rpb24gdGltZWQgb3V0LlxuICogICBEZWZhdWx0OiAyMDAwMCBtc1xuICpcbiAqIG1heFJlY29ubmVjdEF0dGVtcHRzXG4gKiAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhdHRlbXB0cyB0byBiZSBtYWRlIGZvciByZWNvbm5lY3Rpb24uIERlZmF1bHQ6IDJcbiAqXG4gKiByZWNvbm5lY3RJbnRlcnZhbFxuICogLSBUaGUgaW50ZXJ2YWwgdG8gd2FpdCBiZWZvcmUgYXR0ZW1wdGluZyBhIHJlY29ubmVjdGlvbi4gRGVmYXVsdDogMTAwMCBtc1xuICovIHZhciAkMDMyMzgwZGJjZjNmNGUxMyRleHBvcnQkNGYzZDBmZmQ5NDFlYmVmYiA9IC8qKiBAY2xhc3MgKi8gZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgJDAzMjM4MGRiY2YzZjRlMTMkdmFyJF9fZXh0ZW5kcyhSZWNvbm5lY3RpbmdXZWJTb2NrZXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVjb25uZWN0aW5nV2ViU29ja2V0KGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgaWYgKCFhZGRyZXNzKSB0aHJvdyBuZXcgRXJyb3IoXCJOZWVkIGEgdmFsaWQgV2ViU29ja2V0IFVSTFwiKTtcbiAgICAgICAgX3RoaXMuX3dzID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX3VybCA9IGFkZHJlc3M7XG4gICAgICAgIF90aGlzLl9wcm90b2NvbHMgPSBwcm90b2NvbHM7XG4gICAgICAgIF90aGlzLl9wYXJzZUJsb2JUb0pzb24gPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyc2VCbG9iVG9Kc29uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlO1xuICAgICAgICBfdGhpcy5pbml0KCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVjb25uZWN0aW5nV2ViU29ja2V0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2tlZXBBbGl2ZVRpbWVvdXQgPSAkMDMyMzgwZGJjZjNmNGUxMyR2YXIkS0VFUF9BTElWRV9USU1FT1VUO1xuICAgICAgICB0aGlzLl9rZWVwQWxpdmVJbnRlcnZhbCA9ICQwMzIzODBkYmNmM2Y0ZTEzJHZhciRLRUVQX0FMSVZFX0lOVEVSVkFMO1xuICAgICAgICB0aGlzLl9kaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fa2VlcEludGVydmFsSUQgPSBudWxsO1xuICAgICAgICB0aGlzLl9zaG91bGRSZXRyeUZuID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblRpbWVvdXQgPSAkMDMyMzgwZGJjZjNmNGUxMyR2YXIkV0VCU09DS0VUX0NPTk5FQ1RJT05fVElNRU9VVDtcbiAgICAgICAgdGhpcy5fcmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICAgICAgICB0aGlzLl9hbGxvd2VkUmVjb25uZWN0QXR0ZW1wdHMgPSAkMDMyMzgwZGJjZjNmNGUxMyR2YXIkREVGQVVMVF9SRUNPTk5FQ1RfQVRURU1QVFM7XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdEludGVydmFsID0gJDAzMjM4MGRiY2YzZjRlMTMkdmFyJERFRkFVTFRfUkVDT05ORUNUX0lOVEVSVkFMO1xuICAgICAgICB0aGlzLl9tYXhSZWNvbm5lY3RJbnRlcnZhbCA9ICQwMzIzODBkYmNmM2Y0ZTEzJHZhciRNQVhfUkVDT05ORUNUX0lOVEVSVkFMO1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3REZWNheSA9ICQwMzIzODBkYmNmM2Y0ZTEzJHZhciRERUZBVUxUX1JFQ09OTkVDVF9ERUNBWTtcbiAgICB9O1xuICAgIFJlY29ubmVjdGluZ1dlYlNvY2tldC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJDAzMjM4MGRiY2YzZjRlMTMkdmFyJF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuICQwMzIzODBkYmNmM2Y0ZTEzJHZhciRfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIDIgLypyZXR1cm4qLyAsXG4gICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Rpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xlYXJSZWNvbm5lY3RUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd3MgPSBuZXcgJDAzMjM4MGRiY2YzZjRlMTMkdmFyJHJXZWJTb2NrZXQoX3RoaXMuX3VybCwgX3RoaXMuX3Byb3RvY29scyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRDb25uZWN0aW9uVGltZW91dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3MuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbG9zZUV2ZW50ID0gZXZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2RlID0gd3MuX3RpbWVkX291dCA/ICQwMzIzODBkYmNmM2Y0ZTEzJHZhciRXRUJTT0NLRVRfVElNRU9VVF9DT0RFIDogY2xvc2VFdmVudC5jb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWFzb24gPSB3cy5fdGltZWRfb3V0ID8gXCJ3ZWJzb2NrZXQgY29ubmVjdGlvbiB0aW1lZCBvdXRcIiA6IGNsb3NlRXZlbnQucmVhc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdzLl90aW1lZF9vdXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdzLl9jbG9zZWRNYW51YWxseSAmJiB3cy5faW5pdGlhbENvbm5lY3Rpb25Paykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJzaWduYWxpbmcgc29ja2V0IGNsb3NlZCB1bmV4cGVjdGVkbHk6IFwiLmNvbmNhdChjb2RlKS5jb25jYXQocmVhc29uID8gXCIgXCIgKyByZWFzb24gOiBcIlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9jbG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiY2xvc2VcIiwgY29kZSwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgX3RoaXMubG9nKFwic2lnbmFsaW5nIHNvY2tldCBjbG9zZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3cy5fY2xvc2VkTWFudWFsbHkgJiYgKHdzLl9lcnJvcmVkIHx8IHdzLl90aW1lZF9vdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInNpZ25hbGluZyBzb2NrZXQgY2xvc2VkIG9uIGVycm9yOiBcIi5jb25jYXQoY29kZSkuY29uY2F0KHJlYXNvbiA/IFwiIFwiICsgcmVhc29uIDogXCJcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdzLl9yZWplY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3MuX3JlamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXCJXZWJTb2NrZXQgY29ubmVjdGlvbiBlcnJvciAoXCIuY29uY2F0KGNvZGUsIFwiKTogXCIpLmNvbmNhdChyZWFzb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5uYW1lID0gJDAzMjM4MGRiY2YzZjRlMTMkdmFyJFdFQlNPQ0tFVF9FUlJPUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cy5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2coXCJ3c3MgY29ubmVjdGlvbiBvcGVuZWQgdG9cIiwgJDAzMjM4MGRiY2YzZjRlMTMkdmFyJExPR19MRVZFTC5ERUJVRywgX3RoaXMuX3VybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xlYXJDb25uZWN0aW9uVGltZW91dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdyB0aGF0IHRoZSB0aW1lb3V0IGNsb3NlcyB0aGUgc29ja2V0LCBpbiB0aGVvcnkgdGhpcyBvbm9wZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxsYmFjayBzaG91bGQgbmV2ZXIgaGFwcGVuIGluIHRoZSBmaXJzdCBwbGFjZSwgYnV0IHNlZW1zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFybWxlc3MgdG8gbGVhdmUgdGhlc2Ugc2FmZWd1YXJkcyBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3cy5fcmVqZWN0ZWQgfHwgd3MuX3RpbWVkX291dCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3cy5fY2xvc2VkTWFudWFsbHkgfHwgX3RoaXMuX3dzICYmIF90aGlzLl93cyAhPT0gd3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3MuX3JlamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3MuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFwid3NzIGNvbm5lY3Rpb24gaW50ZXJydXB0ZWQgYnkgZGlzY29ubmVjdCBvciBuZXdlciBjb25uZWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIubmFtZSA9ICQwMzIzODBkYmNmM2Y0ZTEzJHZhciRTSUdfQ09OTkVDVElPTl9DQU5DRUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3MuX2luaXRpYWxDb25uZWN0aW9uT2sgPSBfdGhpcy5fdXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sYXN0TXNnUmVjdlRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fa2VlcEFsaXZlSW50ZXJ2YWwpIF90aGlzLl9rZWVwSW50ZXJ2YWxJRCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY2hlY2tTb2NrZXRIZWFsdGhBbmRTZW5kS2VlcEFsaXZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgX3RoaXMuX2tlZXBBbGl2ZUludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fd3MgPSB3cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwib3BlblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3MuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZ5aTogZXZ0IGlzIGFuIEV2ZW50IGhlcmUsIHdpdGggMCBhbW91bnQgb2YgaGVscGZ1bCBpbmZvLiBJZiB0aGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgaGFwcGVucyB0byBiZSBpbmZvIGFib3V0IHRoZSBlcnJvciwgaXQncyBpbmNsdWRlZCBpbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGFjY29tcGFueWluZyBjbG9zZSBldmVudCAoYmVjYXVzZSB0aGF0IG1ha2Ugc2Vuc2UuIHNoYWtlcyBoZWFkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgU08uIFdlIGRvIG5vdCByZWplY3QgaGVyZS4gSW5zdGVhZCwgd2UganVzdCBzZXQgdGhlIF9lcnJvcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBmbGFnIG9uIHRoZSBzb2NrZXQgc28gd2hlbiB0aGUgY2xvc2UgZXZlbnQgb2NjdXJzLCBpdCBrbm93cyB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgcmVqZWN0IHRoZSBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3cy5fY2xvc2VkTWFudWFsbHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdzVGFyZ2V0ID0gZXZ0LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZyhcIndlYnNvY2tldCBlcnJvciBldmVudDogXCIuY29uY2F0KHdzVGFyZ2V0ID09PSBudWxsIHx8IHdzVGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3c1RhcmdldC51cmwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3MuX2Vycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlTWVzc2FnZShtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlY29ubmVjdGluZ1dlYlNvY2tldC5wcm90b3R5cGUuc2V0Q29ubmVjdGlvblRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblRpbWVvdXRJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJDAzMjM4MGRiY2YzZjRlMTMkdmFyJF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkMDMyMzgwZGJjZjNmNGUxMyR2YXIkX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24oX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKF9hLmxhYmVsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhcIkNvbm5lY3Rpb24gcmVjb25uZWN0IGF0dGVtcHQgdGltZWQgb3V0LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uLXRpbWVvdXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb25UaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNCAvKnlpZWxkKi8gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVNvY2tldCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMiAvKnJldHVybiovIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0aGlzLl9jb25uZWN0aW9uVGltZW91dCk7XG4gICAgfTtcbiAgICBSZWNvbm5lY3RpbmdXZWJTb2NrZXQucHJvdG90eXBlLmNsZWFyQ29ubmVjdGlvblRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Nvbm5lY3Rpb25UaW1lb3V0SUQpO1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uVGltZW91dElEID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgUmVjb25uZWN0aW5nV2ViU29ja2V0LnByb3RvdHlwZS5jbGVhclJlY29ubmVjdFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JlY29ubmVjdFRpbWVvdXRJRCk7XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdFRpbWVvdXRJRCA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIFJlY29ubmVjdGluZ1dlYlNvY2tldC5wcm90b3R5cGUuY2xlYXJLZWVwQWxpdmVJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fa2VlcEludGVydmFsSUQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fa2VlcEludGVydmFsSUQpO1xuICAgICAgICAgICAgdGhpcy5fa2VlcEludGVydmFsSUQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWNvbm5lY3RpbmdXZWJTb2NrZXQucHJvdG90eXBlLmNoZWNrU29ja2V0SGVhbHRoQW5kU2VuZEtlZXBBbGl2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJDAzMjM4MGRiY2YzZjRlMTMkdmFyJF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJDAzMjM4MGRiY2YzZjRlMTMkdmFyJF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoKF9hLmxhYmVsKXtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcy5fd3MgJiYgdGhpcy5fd3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIgLypyZXR1cm4qLyBcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2tlZXBBbGl2ZVRpbWVvdXQgfHwgIXRoaXMuX2tlZXBBbGl2ZUludGVydmFsKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIgLypyZXR1cm4qLyBcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShEYXRlLm5vdygpIC0gdGhpcy5fbGFzdE1zZ1JlY3ZUaW1lID4gdGhpcy5fa2VlcEFsaXZlVGltZW91dCkpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyAvKmJyZWFrKi8gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhcIkNvbm5lY3Rpb24gaXMgc3RhbGUsIG5lZWQgdG8gcmVjb25uZWN0XCIsICQwMzIzODBkYmNmM2Y0ZTEzJHZhciRMT0dfTEVWRUwuV0FSTik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQgLyp5aWVsZCovICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVNvY2tldCgpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIgLypyZXR1cm4qLyBcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgZW1pdCB0aGUga2VlcC1hbGl2ZSBldmVudCBpZiB3ZSBoYXZlbid0IHNlbnQgYW55dGhpbmcgZWxzZSByZWNlbnRseVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKERhdGUubm93KCkgLSB0aGlzLl9sYXN0TXNnU2VuZFRpbWUgPCB0aGlzLl9rZWVwQWxpdmVJbnRlcnZhbCkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyIC8qcmV0dXJuKi8gXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coXCJFbWl0dGluZyBrZWVwLWFsaXZlXCIsICQwMzIzODBkYmNmM2Y0ZTEzJHZhciRMT0dfTEVWRUwuREVCVUcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwia2VlcC1hbGl2ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMiAvKnJldHVybiovIFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBXZSB1c2UgdGhlIHdvcmQgbWFudWFsbHkgaGVyZSB0byBpbXBseSB0aGUgYXBwbGljYXRpb24gdXNpbmcgdGhpcyBjb2RlXG4gICAgLy8gb3IgdGhpcyBjb2RlIGl0c2VsZiB3aWxsIGRlY2lkZSB0byBjbG9zZSB0aGUgc29ja2V0LlxuICAgIFJlY29ubmVjdGluZ1dlYlNvY2tldC5wcm90b3R5cGUuX2Nsb3NlU29ja2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkMDMyMzgwZGJjZjNmNGUxMyR2YXIkX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzaG91bGRSZXRyeSwgZXJyb3JfMTtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiAkMDMyMzgwZGJjZjNmNGUxMyR2YXIkX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24oX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2goX2IubGFiZWwpe1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhcIkNsb3NpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA1XG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJLZWVwQWxpdmVJbnRlcnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdE1zZ1JlY3ZUaW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl93cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3dzLl9jbG9zZWRNYW51YWxseSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fd3MuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFJldHJ5ID0gKChfYSA9IHRoaXMuX3dzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX2luaXRpYWxDb25uZWN0aW9uT2spICYmIHRoaXMuX3Nob3VsZFJldHJ5Rm4gJiYgdGhpcy5fc2hvdWxkUmV0cnlGbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fd3MgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG91bGRSZXRyeSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzIC8qYnJlYWsqLyAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgM1xuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiRW1pdHRpbmcgcmVjb25uZWN0XCIsICQwMzIzODBkYmNmM2Y0ZTEzJHZhciRMT0dfTEVWRUwuREVCVUcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwicmVjb25uZWN0aW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0IC8qeWllbGQqLyAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXRyeUZhaWxlZENvbm5lY3Rpb24oKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMgLypicmVhayovICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA1XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coXCJFcnJvciB3aGlsZSBjbG9zaW5nIGFuZCByZXRyeWluZzogXCIuY29uY2F0KGVycm9yXzEpLCAkMDMyMzgwZGJjZjNmNGUxMyR2YXIkTE9HX0xFVkVMLkVSUk9SKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyAvKmJyZWFrKi8gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDVcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMiAvKnJldHVybiovIFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWNvbm5lY3RpbmdXZWJTb2NrZXQucHJvdG90eXBlLnJldHJ5RmFpbGVkQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJDAzMjM4MGRiY2YzZjRlMTMkdmFyJF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdGltZW91dDtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gJDAzMjM4MGRiY2YzZjRlMTMkdmFyJF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9hKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlY29ubmVjdEF0dGVtcHRzIDwgdGhpcy5fYWxsb3dlZFJlY29ubmVjdEF0dGVtcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZWNvbm5lY3RUaW1lb3V0SUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiUmV0cnkgYWxyZWFkeSBzY2hlZHVsZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIgLypyZXR1cm4qLyBcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coXCJSZXRyeWluZyBmYWlsZWQgY29ubmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IC8vIFRoZSB0aW1lb3V0IGxvZ2ljIGlzIHRha2VuIGZyb21cbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy9yZWNvbm5lY3Rpbmctd2Vic29ja2V0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdEludGVydmFsICogTWF0aC5wb3codGhpcy5fcmVjb25uZWN0RGVjYXksIHRoaXMuX3JlY29ubmVjdEF0dGVtcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHRpbWVvdXQgPiB0aGlzLl9tYXhSZWNvbm5lY3RJbnRlcnZhbCA/IHRoaXMuX21heFJlY29ubmVjdEludGVydmFsIDogdGltZW91dDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coXCJSZWNvbm5lY3RpbmcgaW4gXCIuY29uY2F0KHRpbWVvdXQgLyAxMDAwLCBcIiBzZWNvbmRzXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVjb25uZWN0QXR0ZW1wdHMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVjb25uZWN0VGltZW91dElEID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiTWF4aW11bSBjb25uZWN0aW9uIHJldHJ5IGF0dGVtcHRzIGV4Y2VlZGVkXCIsICQwMzIzODBkYmNmM2Y0ZTEzJHZhciRMT0dfTEVWRUwuRVJST1IpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJyZWNvbm5lY3QtZmFpbGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAyIC8qcmV0dXJuKi8gXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlY29ubmVjdGluZ1dlYlNvY2tldC5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24obXNnLCBsb2dfbGV2ZWwpIHtcbiAgICAgICAgaWYgKGxvZ19sZXZlbCA9PT0gdm9pZCAwKSBsb2dfbGV2ZWwgPSAkMDMyMzgwZGJjZjNmNGUxMyR2YXIkTE9HX0xFVkVMLkRFQlVHO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKWFyZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIHN3aXRjaChsb2dfbGV2ZWwpe1xuICAgICAgICAgICAgY2FzZSAkMDMyMzgwZGJjZjNmNGUxMyR2YXIkTE9HX0xFVkVMLkRFQlVHOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcuYXBwbHkoY29uc29sZSwgJDAzMjM4MGRiY2YzZjRlMTMkdmFyJF9fc3ByZWFkQXJyYXkoW1xuICAgICAgICAgICAgICAgICAgICBcIndlYnNvY2tldDogXCIuY29uY2F0KG1zZylcbiAgICAgICAgICAgICAgICBdLCBhcmdzLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAkMDMyMzgwZGJjZjNmNGUxMyR2YXIkTE9HX0xFVkVMLkVSUk9SOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgJDAzMjM4MGRiY2YzZjRlMTMkdmFyJF9fc3ByZWFkQXJyYXkoW1xuICAgICAgICAgICAgICAgICAgICBcIndlYnNvY2tldDogXCIuY29uY2F0KG1zZylcbiAgICAgICAgICAgICAgICBdLCBhcmdzLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAkMDMyMzgwZGJjZjNmNGUxMyR2YXIkTE9HX0xFVkVMLldBUk46XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsICQwMzIzODBkYmNmM2Y0ZTEzJHZhciRfX3NwcmVhZEFycmF5KFtcbiAgICAgICAgICAgICAgICAgICAgXCJ3ZWJzb2NrZXQ6IFwiLmNvbmNhdChtc2cpXG4gICAgICAgICAgICAgICAgXSwgYXJncywgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJDAzMjM4MGRiY2YzZjRlMTMkdmFyJExPR19MRVZFTC5JTkZPOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCAkMDMyMzgwZGJjZjNmNGUxMyR2YXIkX19zcHJlYWRBcnJheShbXG4gICAgICAgICAgICAgICAgICAgIFwid2Vic29ja2V0OiBcIi5jb25jYXQobXNnKVxuICAgICAgICAgICAgICAgIF0sIGFyZ3MsIGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlY29ubmVjdGluZ1dlYlNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuICQwMzIzODBkYmNmM2Y0ZTEzJHZhciRfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICQwMzIzODBkYmNmM2Y0ZTEzJHZhciRfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfYSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl93cyAmJiB0aGlzLl93cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdE1zZ1NlbmRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3dzLnNlbmQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB0aGlzLmxvZyhcIkZhaWxlZCB0byBzZW5kIGRhdGEsIHdlYiBzb2NrZXQgbm90IG9wZW4uXCIsICQwMzIzODBkYmNmM2Y0ZTEzJHZhciRMT0dfTEVWRUwuRVJST1IpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiRmFpbGVkIHRvIHNlbmQgZGF0YS4gXCIuY29uY2F0KGVycm9yKSwgJDAzMjM4MGRiY2YzZjRlMTMkdmFyJExPR19MRVZFTC5FUlJPUik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIDIgLypyZXR1cm4qLyBcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVjb25uZWN0aW5nV2ViU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJDAzMjM4MGRiY2YzZjRlMTMkdmFyJF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJDAzMjM4MGRiY2YzZjRlMTMkdmFyJF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9hKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coXCJDbG9zaW5nIHdlYnNvY2tldFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhclJlY29ubmVjdFRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhcIkZhaWxlZCB0byBjbG9zZSB3ZWJzb2NrZXQuIFwiLmNvbmNhdChlcnJvcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAyIC8qcmV0dXJuKi8gXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWNvbm5lY3RpbmdXZWJTb2NrZXQucHJvdG90eXBlLCBcInJlYWR5U3RhdGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl93cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYWR5U3RhdGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVjb25uZWN0aW5nV2ViU29ja2V0LnByb3RvdHlwZSwgXCJ1cmxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWNvbm5lY3RpbmdXZWJTb2NrZXQucHJvdG90eXBlLCBcImtlZXBBbGl2ZVRpbWVvdXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tlZXBBbGl2ZVRpbWVvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oa2VlcEFsaXZlVGltZW91dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZWVwQWxpdmVUaW1lb3V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coXCJTZXR0aW5nIEFDSyBmcmVzaG5lc3MgdGltZW91dCB0byBcIi5jb25jYXQoa2VlcEFsaXZlVGltZW91dCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2tlZXBBbGl2ZVRpbWVvdXQgPSBrZWVwQWxpdmVUaW1lb3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlY29ubmVjdGluZ1dlYlNvY2tldC5wcm90b3R5cGUsIFwia2VlcEFsaXZlSW50ZXJ2YWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tlZXBBbGl2ZUludGVydmFsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGtlZXBBbGl2ZUludGVydmFsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlZXBBbGl2ZUludGVydmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coXCJTZXR0aW5nIGtlZXAtYWxpdmUgaW50ZXJ2YWwgdG8gXCIuY29uY2F0KGtlZXBBbGl2ZUludGVydmFsKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fa2VlcEFsaXZlSW50ZXJ2YWwgPSBrZWVwQWxpdmVJbnRlcnZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWNvbm5lY3RpbmdXZWJTb2NrZXQucHJvdG90eXBlLCBcInNob3VsZFJldHJ5Rm5cIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSBcImZ1bmN0aW9uXCIpIHRoaXMuX3Nob3VsZFJldHJ5Rm4gPSBjYjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWNvbm5lY3RpbmdXZWJTb2NrZXQucHJvdG90eXBlLCBcImNvbm5lY3Rpb25UaW1lb3V0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uVGltZW91dDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih0aW1lb3V0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRpbWVvdXQgPT09IFwibnVtYmVyXCIpIHRoaXMuX2Nvbm5lY3Rpb25UaW1lb3V0ID0gdGltZW91dDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWNvbm5lY3RpbmdXZWJTb2NrZXQucHJvdG90eXBlLCBcIm1heFJlY29ubmVjdEF0dGVtcHRzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbGxvd2VkUmVjb25uZWN0QXR0ZW1wdHM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oYXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIGlmIChhdHRlbXB0cyA+IDAgJiYgYXR0ZW1wdHMgPCAkMDMyMzgwZGJjZjNmNGUxMyR2YXIkTUFYX1JFQ09OTkVDVF9BVFRFTVBUUykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiU2V0dGluZyBtYXhpbXVtIGNvbm5lY3Rpb24gcmV0cnkgYXR0ZW1wdHMgdG8gXCIuY29uY2F0KGF0dGVtcHRzKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsb3dlZFJlY29ubmVjdEF0dGVtcHRzID0gYXR0ZW1wdHM7XG4gICAgICAgICAgICB9IGVsc2UgdGhpcy5fYWxsb3dlZFJlY29ubmVjdEF0dGVtcHRzID0gJDAzMjM4MGRiY2YzZjRlMTMkdmFyJERFRkFVTFRfUkVDT05ORUNUX0FUVEVNUFRTO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlY29ubmVjdGluZ1dlYlNvY2tldC5wcm90b3R5cGUsIFwicmVjb25uZWN0SW50ZXJ2YWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29ubmVjdEludGVydmFsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGludGVydmFsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGludGVydmFsID09PSBcIm51bWJlclwiKSB0aGlzLl9yZWNvbm5lY3RJbnRlcnZhbCA9IGludGVydmFsIDwgdGhpcy5fbWF4UmVjb25uZWN0SW50ZXJ2YWwgPyBpbnRlcnZhbCA6IHRoaXMuX21heFJlY29ubmVjdEludGVydmFsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgUmVjb25uZWN0aW5nV2ViU29ja2V0LnByb3RvdHlwZS5faGFuZGxlTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiAkMDMyMzgwZGJjZjNmNGUxMyR2YXIkX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkYXRhLCBfcGFyc2VQcm9taXNlLCBtc2c7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuICQwMzIzODBkYmNmM2Y0ZTEzJHZhciRfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaChfYS5sYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RNc2dSZWN2VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9wYXJzZVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIC8vIEhhbmRsZSB0ZXh0IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYmluYXJ5IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5QnVmZmVyID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIEFycmF5QnVmZmVyIGFzIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeGFtcGxlOiBDb252ZXJ0IEFycmF5QnVmZmVyIHRvIFVpbnQ4QXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIFVpbnQ4QXJyYXkgYXMgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl9wYXJzZUJsb2JUb0pzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIEJsb2IgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmxvYiA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgQmxvYiB0byBBcnJheUJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZGVyXzEgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXJfMS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gcmVhZGVyXzEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIganNvbiA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShqc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIEpTT04gZnJvbSBCbG9iOlwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyXzEucmVhZEFzVGV4dChibG9iKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCAvKnlpZWxkKi8gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wYXJzZVByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm1lc3NhZ2VcIiwgbXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMiAvKnJldHVybiovIFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVjb25uZWN0aW5nV2ViU29ja2V0O1xufSgoMCwgJGtSNnRHJEV2ZW50RW1pdHRlcikpO1xuW1xuICAgIFwiYmluYXJ5VHlwZVwiLFxuICAgIFwiYnVmZmVyZWRBbW91bnRcIixcbiAgICBcImV4dGVuc2lvbnNcIixcbiAgICBcInByb3RvY29sXCIsXG4gICAgXCJyZWFkeVN0YXRlXCIsXG4gICAgXCJ1cmxcIixcbiAgICBcImtlZXBBbGl2ZVRpbWVvdXRcIixcbiAgICBcImtlZXBBbGl2ZUludGVydmFsXCIsXG4gICAgXCJzaG91bGRSZXRyeUZuXCIsXG4gICAgXCJjb25uZWN0aW9uVGltZW91dFwiLFxuICAgIFwibWF4UmVjb25uZWN0QXR0ZW1wdHNcIixcbiAgICBcInJlY29ubmVjdEludGVydmFsXCJcbl0uZm9yRWFjaChmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgkMDMyMzgwZGJjZjNmNGUxMyRleHBvcnQkNGYzZDBmZmQ5NDFlYmVmYi5wcm90b3R5cGUsIHByb3BlcnR5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbn0pO1xuW1xuICAgIFwiQ09OTkVDVElOR1wiLFxuICAgIFwiT1BFTlwiLFxuICAgIFwiQ0xPU0lOR1wiLFxuICAgIFwiQ0xPU0VEXCJcbl0uZm9yRWFjaChmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgkMDMyMzgwZGJjZjNmNGUxMyRleHBvcnQkNGYzZDBmZmQ5NDFlYmVmYi5wcm90b3R5cGUsIHByb3BlcnR5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiAkMDMyMzgwZGJjZjNmNGUxMyR2YXIkcmVhZHlTdGF0ZXMuaW5kZXhPZihwcm9wZXJ0eSlcbiAgICB9KTtcbn0pO1xuW1xuICAgIFwiQ09OTkVDVElOR1wiLFxuICAgIFwiT1BFTlwiLFxuICAgIFwiQ0xPU0lOR1wiLFxuICAgIFwiQ0xPU0VEXCJcbl0uZm9yRWFjaChmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgkMDMyMzgwZGJjZjNmNGUxMyRleHBvcnQkNGYzZDBmZmQ5NDFlYmVmYiwgcHJvcGVydHksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6ICQwMzIzODBkYmNmM2Y0ZTEzJHZhciRyZWFkeVN0YXRlcy5pbmRleE9mKHByb3BlcnR5KVxuICAgIH0pO1xufSk7XG5cblxuXG5cbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzICQ1MTc3ZDU2YmQwYzk5NWUwJHZhciRUZXh0RnJhbWUkVHlwZSBleHRlbmRzICgwLCAka1I2dEckTWVzc2FnZVR5cGUpIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcihcInBpcGVjYXQuVGV4dEZyYW1lXCIsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiBcImlkXCIsXG4gICAgICAgICAgICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgICAgICAgICAgICBUOiA0IC8qU2NhbGFyVHlwZS5VSU5UNjQqLyAsXG4gICAgICAgICAgICAgICAgTDogMCAvKkxvbmdUeXBlLkJJR0lOVCovIFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMixcbiAgICAgICAgICAgICAgICBuYW1lOiBcIm5hbWVcIixcbiAgICAgICAgICAgICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMyxcbiAgICAgICAgICAgICAgICBuYW1lOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIFxuICAgICAgICAgICAgfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5pZCA9IDBuO1xuICAgICAgICBtZXNzYWdlLm5hbWUgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLnRleHQgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkgKDAsICRrUjZ0RyRyZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKSh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZShyZWFkZXIucG9zIDwgZW5kKXtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoKGZpZWxkTm8pe1xuICAgICAgICAgICAgICAgIGNhc2UgLyogdWludDY0IGlkICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWQgPSByZWFkZXIudWludDY0KCkudG9CaWdJbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgbmFtZSAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHRleHQgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50ZXh0ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIikgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKSAodSA9PT0gdHJ1ZSA/ICgwLCAka1I2dEckVW5rbm93bkZpZWxkSGFuZGxlcikub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiB1aW50NjQgaWQgPSAxOyAqLyBpZiAobWVzc2FnZS5pZCAhPT0gMG4pIHdyaXRlci50YWcoMSwgKDAsICRrUjZ0RyRXaXJlVHlwZSkuVmFyaW50KS51aW50NjQobWVzc2FnZS5pZCk7XG4gICAgICAgIC8qIHN0cmluZyBuYW1lID0gMjsgKi8gaWYgKG1lc3NhZ2UubmFtZSAhPT0gXCJcIikgd3JpdGVyLnRhZygyLCAoMCwgJGtSNnRHJFdpcmVUeXBlKS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgICAvKiBzdHJpbmcgdGV4dCA9IDM7ICovIGlmIChtZXNzYWdlLnRleHQgIT09IFwiXCIpIHdyaXRlci50YWcoMywgKDAsICRrUjZ0RyRXaXJlVHlwZSkuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50ZXh0KTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKSAodSA9PSB0cnVlID8gKDAsICRrUjZ0RyRVbmtub3duRmllbGRIYW5kbGVyKS5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG5jb25zdCAkNTE3N2Q1NmJkMGM5OTVlMCRleHBvcnQkNzg0MTBhZGEwM2Y2OTMxYiA9IG5ldyAkNTE3N2Q1NmJkMGM5OTVlMCR2YXIkVGV4dEZyYW1lJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzICQ1MTc3ZDU2YmQwYzk5NWUwJHZhciRBdWRpb1Jhd0ZyYW1lJFR5cGUgZXh0ZW5kcyAoMCwgJGtSNnRHJE1lc3NhZ2VUeXBlKSB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoXCJwaXBlY2F0LkF1ZGlvUmF3RnJhbWVcIiwgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiaWRcIixcbiAgICAgICAgICAgICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgICAgICAgICAgIFQ6IDQgLypTY2FsYXJUeXBlLlVJTlQ2NCovICxcbiAgICAgICAgICAgICAgICBMOiAwIC8qTG9uZ1R5cGUuQklHSU5UKi8gXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAyLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwibmFtZVwiLFxuICAgICAgICAgICAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICAgICAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiYXVkaW9cIixcbiAgICAgICAgICAgICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgICAgICAgICAgIFQ6IDEyIC8qU2NhbGFyVHlwZS5CWVRFUyovIFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNCxcbiAgICAgICAgICAgICAgICBuYW1lOiBcInNhbXBsZV9yYXRlXCIsXG4gICAgICAgICAgICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgICAgICAgICAgICBUOiAxMyAvKlNjYWxhclR5cGUuVUlOVDMyKi8gXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA1LFxuICAgICAgICAgICAgICAgIG5hbWU6IFwibnVtX2NoYW5uZWxzXCIsXG4gICAgICAgICAgICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgICAgICAgICAgICBUOiAxMyAvKlNjYWxhclR5cGUuVUlOVDMyKi8gXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA2LFxuICAgICAgICAgICAgICAgIG5hbWU6IFwicHRzXCIsXG4gICAgICAgICAgICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgICAgICAgICAgICBvcHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgVDogNCAvKlNjYWxhclR5cGUuVUlOVDY0Ki8gLFxuICAgICAgICAgICAgICAgIEw6IDAgLypMb25nVHlwZS5CSUdJTlQqLyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UuaWQgPSAwbjtcbiAgICAgICAgbWVzc2FnZS5uYW1lID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5hdWRpbyA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICBtZXNzYWdlLnNhbXBsZVJhdGUgPSAwO1xuICAgICAgICBtZXNzYWdlLm51bUNoYW5uZWxzID0gMDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpICgwLCAka1I2dEckcmVmbGVjdGlvbk1lcmdlUGFydGlhbCkodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUocmVhZGVyLnBvcyA8IGVuZCl7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaChmaWVsZE5vKXtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHVpbnQ2NCBpZCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlkID0gcmVhZGVyLnVpbnQ2NCgpLnRvQmlnSW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIG5hbWUgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJ5dGVzIGF1ZGlvICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXVkaW8gPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiB1aW50MzIgc2FtcGxlX3JhdGUgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zYW1wbGVSYXRlID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHVpbnQzMiBudW1fY2hhbm5lbHMgKi8gNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5udW1DaGFubmVscyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBvcHRpb25hbCB1aW50NjQgcHRzICovIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHRzID0gcmVhZGVyLnVpbnQ2NCgpLnRvQmlnSW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKSB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpICh1ID09PSB0cnVlID8gKDAsICRrUjZ0RyRVbmtub3duRmllbGRIYW5kbGVyKS5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHVpbnQ2NCBpZCA9IDE7ICovIGlmIChtZXNzYWdlLmlkICE9PSAwbikgd3JpdGVyLnRhZygxLCAoMCwgJGtSNnRHJFdpcmVUeXBlKS5WYXJpbnQpLnVpbnQ2NChtZXNzYWdlLmlkKTtcbiAgICAgICAgLyogc3RyaW5nIG5hbWUgPSAyOyAqLyBpZiAobWVzc2FnZS5uYW1lICE9PSBcIlwiKSB3cml0ZXIudGFnKDIsICgwLCAka1I2dEckV2lyZVR5cGUpLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UubmFtZSk7XG4gICAgICAgIC8qIGJ5dGVzIGF1ZGlvID0gMzsgKi8gaWYgKG1lc3NhZ2UuYXVkaW8ubGVuZ3RoKSB3cml0ZXIudGFnKDMsICgwLCAka1I2dEckV2lyZVR5cGUpLkxlbmd0aERlbGltaXRlZCkuYnl0ZXMobWVzc2FnZS5hdWRpbyk7XG4gICAgICAgIC8qIHVpbnQzMiBzYW1wbGVfcmF0ZSA9IDQ7ICovIGlmIChtZXNzYWdlLnNhbXBsZVJhdGUgIT09IDApIHdyaXRlci50YWcoNCwgKDAsICRrUjZ0RyRXaXJlVHlwZSkuVmFyaW50KS51aW50MzIobWVzc2FnZS5zYW1wbGVSYXRlKTtcbiAgICAgICAgLyogdWludDMyIG51bV9jaGFubmVscyA9IDU7ICovIGlmIChtZXNzYWdlLm51bUNoYW5uZWxzICE9PSAwKSB3cml0ZXIudGFnKDUsICgwLCAka1I2dEckV2lyZVR5cGUpLlZhcmludCkudWludDMyKG1lc3NhZ2UubnVtQ2hhbm5lbHMpO1xuICAgICAgICAvKiBvcHRpb25hbCB1aW50NjQgcHRzID0gNjsgKi8gaWYgKG1lc3NhZ2UucHRzICE9PSB1bmRlZmluZWQpIHdyaXRlci50YWcoNiwgKDAsICRrUjZ0RyRXaXJlVHlwZSkuVmFyaW50KS51aW50NjQobWVzc2FnZS5wdHMpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpICh1ID09IHRydWUgPyAoMCwgJGtSNnRHJFVua25vd25GaWVsZEhhbmRsZXIpLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbmNvbnN0ICQ1MTc3ZDU2YmQwYzk5NWUwJGV4cG9ydCQ1MWQ4NzIxZGUzY2JmZjhmID0gbmV3ICQ1MTc3ZDU2YmQwYzk5NWUwJHZhciRBdWRpb1Jhd0ZyYW1lJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzICQ1MTc3ZDU2YmQwYzk5NWUwJHZhciRUcmFuc2NyaXB0aW9uRnJhbWUkVHlwZSBleHRlbmRzICgwLCAka1I2dEckTWVzc2FnZVR5cGUpIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcihcInBpcGVjYXQuVHJhbnNjcmlwdGlvbkZyYW1lXCIsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiBcImlkXCIsXG4gICAgICAgICAgICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgICAgICAgICAgICBUOiA0IC8qU2NhbGFyVHlwZS5VSU5UNjQqLyAsXG4gICAgICAgICAgICAgICAgTDogMCAvKkxvbmdUeXBlLkJJR0lOVCovIFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMixcbiAgICAgICAgICAgICAgICBuYW1lOiBcIm5hbWVcIixcbiAgICAgICAgICAgICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMyxcbiAgICAgICAgICAgICAgICBuYW1lOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNCxcbiAgICAgICAgICAgICAgICBuYW1lOiBcInVzZXJfaWRcIixcbiAgICAgICAgICAgICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNSxcbiAgICAgICAgICAgICAgICBuYW1lOiBcInRpbWVzdGFtcFwiLFxuICAgICAgICAgICAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICAgICAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gXG4gICAgICAgICAgICB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLmlkID0gMG47XG4gICAgICAgIG1lc3NhZ2UubmFtZSA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudGV4dCA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudXNlcklkID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS50aW1lc3RhbXAgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkgKDAsICRrUjZ0RyRyZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKSh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZShyZWFkZXIucG9zIDwgZW5kKXtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoKGZpZWxkTm8pe1xuICAgICAgICAgICAgICAgIGNhc2UgLyogdWludDY0IGlkICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWQgPSByZWFkZXIudWludDY0KCkudG9CaWdJbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgbmFtZSAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHRleHQgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50ZXh0ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB1c2VyX2lkICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudXNlcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0aW1lc3RhbXAgKi8gNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50aW1lc3RhbXAgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKSB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpICh1ID09PSB0cnVlID8gKDAsICRrUjZ0RyRVbmtub3duRmllbGRIYW5kbGVyKS5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHVpbnQ2NCBpZCA9IDE7ICovIGlmIChtZXNzYWdlLmlkICE9PSAwbikgd3JpdGVyLnRhZygxLCAoMCwgJGtSNnRHJFdpcmVUeXBlKS5WYXJpbnQpLnVpbnQ2NChtZXNzYWdlLmlkKTtcbiAgICAgICAgLyogc3RyaW5nIG5hbWUgPSAyOyAqLyBpZiAobWVzc2FnZS5uYW1lICE9PSBcIlwiKSB3cml0ZXIudGFnKDIsICgwLCAka1I2dEckV2lyZVR5cGUpLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UubmFtZSk7XG4gICAgICAgIC8qIHN0cmluZyB0ZXh0ID0gMzsgKi8gaWYgKG1lc3NhZ2UudGV4dCAhPT0gXCJcIikgd3JpdGVyLnRhZygzLCAoMCwgJGtSNnRHJFdpcmVUeXBlKS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnRleHQpO1xuICAgICAgICAvKiBzdHJpbmcgdXNlcl9pZCA9IDQ7ICovIGlmIChtZXNzYWdlLnVzZXJJZCAhPT0gXCJcIikgd3JpdGVyLnRhZyg0LCAoMCwgJGtSNnRHJFdpcmVUeXBlKS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnVzZXJJZCk7XG4gICAgICAgIC8qIHN0cmluZyB0aW1lc3RhbXAgPSA1OyAqLyBpZiAobWVzc2FnZS50aW1lc3RhbXAgIT09IFwiXCIpIHdyaXRlci50YWcoNSwgKDAsICRrUjZ0RyRXaXJlVHlwZSkuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50aW1lc3RhbXApO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpICh1ID09IHRydWUgPyAoMCwgJGtSNnRHJFVua25vd25GaWVsZEhhbmRsZXIpLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbmNvbnN0ICQ1MTc3ZDU2YmQwYzk5NWUwJGV4cG9ydCQxMGIzODhjMTVhNWNkYzhhID0gbmV3ICQ1MTc3ZDU2YmQwYzk5NWUwJHZhciRUcmFuc2NyaXB0aW9uRnJhbWUkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgJDUxNzdkNTZiZDBjOTk1ZTAkdmFyJE1lc3NhZ2VGcmFtZSRUeXBlIGV4dGVuZHMgKDAsICRrUjZ0RyRNZXNzYWdlVHlwZSkge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKFwicGlwZWNhdC5NZXNzYWdlRnJhbWVcIiwgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiZGF0YVwiLFxuICAgICAgICAgICAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICAgICAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gXG4gICAgICAgICAgICB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLmRhdGEgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkgKDAsICRrUjZ0RyRyZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKSh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZShyZWFkZXIucG9zIDwgZW5kKXtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoKGZpZWxkTm8pe1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIGRhdGEgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIikgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKSAodSA9PT0gdHJ1ZSA/ICgwLCAka1I2dEckVW5rbm93bkZpZWxkSGFuZGxlcikub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgZGF0YSA9IDE7ICovIGlmIChtZXNzYWdlLmRhdGEgIT09IFwiXCIpIHdyaXRlci50YWcoMSwgKDAsICRrUjZ0RyRXaXJlVHlwZSkuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5kYXRhKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKSAodSA9PSB0cnVlID8gKDAsICRrUjZ0RyRVbmtub3duRmllbGRIYW5kbGVyKS5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG5jb25zdCAkNTE3N2Q1NmJkMGM5OTVlMCRleHBvcnQkYmMzZjQ1YTZkNDM0ZjE0YSA9IG5ldyAkNTE3N2Q1NmJkMGM5OTVlMCR2YXIkTWVzc2FnZUZyYW1lJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzICQ1MTc3ZDU2YmQwYzk5NWUwJHZhciRGcmFtZSRUeXBlIGV4dGVuZHMgKDAsICRrUjZ0RyRNZXNzYWdlVHlwZSkge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKFwicGlwZWNhdC5GcmFtZVwiLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAga2luZDogXCJtZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgb25lb2Y6IFwiZnJhbWVcIixcbiAgICAgICAgICAgICAgICBUOiAoKT0+JDUxNzdkNTZiZDBjOTk1ZTAkZXhwb3J0JDc4NDEwYWRhMDNmNjkzMWJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJhdWRpb1wiLFxuICAgICAgICAgICAgICAgIGtpbmQ6IFwibWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgIG9uZW9mOiBcImZyYW1lXCIsXG4gICAgICAgICAgICAgICAgVDogKCk9PiQ1MTc3ZDU2YmQwYzk5NWUwJGV4cG9ydCQ1MWQ4NzIxZGUzY2JmZjhmXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwidHJhbnNjcmlwdGlvblwiLFxuICAgICAgICAgICAgICAgIGtpbmQ6IFwibWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgIG9uZW9mOiBcImZyYW1lXCIsXG4gICAgICAgICAgICAgICAgVDogKCk9PiQ1MTc3ZDU2YmQwYzk5NWUwJGV4cG9ydCQxMGIzODhjMTVhNWNkYzhhXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA0LFxuICAgICAgICAgICAgICAgIG5hbWU6IFwibWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgIGtpbmQ6IFwibWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgIG9uZW9mOiBcImZyYW1lXCIsXG4gICAgICAgICAgICAgICAgVDogKCk9PiQ1MTc3ZDU2YmQwYzk5NWUwJGV4cG9ydCRiYzNmNDVhNmQ0MzRmMTRhXG4gICAgICAgICAgICB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLmZyYW1lID0ge1xuICAgICAgICAgICAgb25lb2ZLaW5kOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpICgwLCAka1I2dEckcmVmbGVjdGlvbk1lcmdlUGFydGlhbCkodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUocmVhZGVyLnBvcyA8IGVuZCl7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaChmaWVsZE5vKXtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHBpcGVjYXQuVGV4dEZyYW1lIHRleHQgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mcmFtZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAkNTE3N2Q1NmJkMGM5OTVlMCRleHBvcnQkNzg0MTBhZGEwM2Y2OTMxYi5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZnJhbWUudGV4dClcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBwaXBlY2F0LkF1ZGlvUmF3RnJhbWUgYXVkaW8gKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mcmFtZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogXCJhdWRpb1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW86ICQ1MTc3ZDU2YmQwYzk5NWUwJGV4cG9ydCQ1MWQ4NzIxZGUzY2JmZjhmLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5mcmFtZS5hdWRpbylcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBwaXBlY2F0LlRyYW5zY3JpcHRpb25GcmFtZSB0cmFuc2NyaXB0aW9uICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnJhbWUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6IFwidHJhbnNjcmlwdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNjcmlwdGlvbjogJDUxNzdkNTZiZDBjOTk1ZTAkZXhwb3J0JDEwYjM4OGMxNWE1Y2RjOGEuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmZyYW1lLnRyYW5zY3JpcHRpb24pXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogcGlwZWNhdC5NZXNzYWdlRnJhbWUgbWVzc2FnZSAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZyYW1lID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiBcIm1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICQ1MTc3ZDU2YmQwYzk5NWUwJGV4cG9ydCRiYzNmNDVhNmQ0MzRmMTRhLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5mcmFtZS5tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIikgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKSAodSA9PT0gdHJ1ZSA/ICgwLCAka1I2dEckVW5rbm93bkZpZWxkSGFuZGxlcikub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBwaXBlY2F0LlRleHRGcmFtZSB0ZXh0ID0gMTsgKi8gaWYgKG1lc3NhZ2UuZnJhbWUub25lb2ZLaW5kID09PSBcInRleHRcIikgJDUxNzdkNTZiZDBjOTk1ZTAkZXhwb3J0JDc4NDEwYWRhMDNmNjkzMWIuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmZyYW1lLnRleHQsIHdyaXRlci50YWcoMSwgKDAsICRrUjZ0RyRXaXJlVHlwZSkuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogcGlwZWNhdC5BdWRpb1Jhd0ZyYW1lIGF1ZGlvID0gMjsgKi8gaWYgKG1lc3NhZ2UuZnJhbWUub25lb2ZLaW5kID09PSBcImF1ZGlvXCIpICQ1MTc3ZDU2YmQwYzk5NWUwJGV4cG9ydCQ1MWQ4NzIxZGUzY2JmZjhmLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5mcmFtZS5hdWRpbywgd3JpdGVyLnRhZygyLCAoMCwgJGtSNnRHJFdpcmVUeXBlKS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBwaXBlY2F0LlRyYW5zY3JpcHRpb25GcmFtZSB0cmFuc2NyaXB0aW9uID0gMzsgKi8gaWYgKG1lc3NhZ2UuZnJhbWUub25lb2ZLaW5kID09PSBcInRyYW5zY3JpcHRpb25cIikgJDUxNzdkNTZiZDBjOTk1ZTAkZXhwb3J0JDEwYjM4OGMxNWE1Y2RjOGEuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmZyYW1lLnRyYW5zY3JpcHRpb24sIHdyaXRlci50YWcoMywgKDAsICRrUjZ0RyRXaXJlVHlwZSkuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogcGlwZWNhdC5NZXNzYWdlRnJhbWUgbWVzc2FnZSA9IDQ7ICovIGlmIChtZXNzYWdlLmZyYW1lLm9uZW9mS2luZCA9PT0gXCJtZXNzYWdlXCIpICQ1MTc3ZDU2YmQwYzk5NWUwJGV4cG9ydCRiYzNmNDVhNmQ0MzRmMTRhLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5mcmFtZS5tZXNzYWdlLCB3cml0ZXIudGFnKDQsICgwLCAka1I2dEckV2lyZVR5cGUpLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSkgKHUgPT0gdHJ1ZSA/ICgwLCAka1I2dEckVW5rbm93bkZpZWxkSGFuZGxlcikub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuY29uc3QgJDUxNzdkNTZiZDBjOTk1ZTAkZXhwb3J0JGI4OWE4MjdlOTI1NDIxMWEgPSBuZXcgJDUxNzdkNTZiZDBjOTk1ZTAkdmFyJEZyYW1lJFR5cGUoKTtcblxuXG5jbGFzcyAkYTZjMDgwZGM1MWM5Njg3ZiRleHBvcnQkNGIyMDI2ZjhlMTFiMTQ4YSB7XG4gICAgc2VyaWFsaXplKGRhdGEpIHt9XG4gICAgc2VyaWFsaXplQXVkaW8oZGF0YSwgc2FtcGxlUmF0ZSwgbnVtQ2hhbm5lbHMpIHtcbiAgICAgICAgY29uc3QgcGNtQnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gKDAsICQ1MTc3ZDU2YmQwYzk5NWUwJGV4cG9ydCRiODlhODI3ZTkyNTQyMTFhKS5jcmVhdGUoe1xuICAgICAgICAgICAgZnJhbWU6IHtcbiAgICAgICAgICAgICAgICBvbmVvZktpbmQ6IFwiYXVkaW9cIixcbiAgICAgICAgICAgICAgICBhdWRpbzoge1xuICAgICAgICAgICAgICAgICAgICBpZDogMG4sXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiYXVkaW9cIixcbiAgICAgICAgICAgICAgICAgICAgYXVkaW86IHBjbUJ5dGVBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlUmF0ZTogc2FtcGxlUmF0ZSxcbiAgICAgICAgICAgICAgICAgICAgbnVtQ2hhbm5lbHM6IG51bUNoYW5uZWxzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCgwLCAkNTE3N2Q1NmJkMGM5OTVlMCRleHBvcnQkYjg5YTgyN2U5MjU0MjExYSkudG9CaW5hcnkoZnJhbWUpKTtcbiAgICB9XG4gICAgc2VyaWFsaXplTWVzc2FnZShtc2cpIHtcbiAgICAgICAgY29uc3QgZnJhbWUgPSAoMCwgJDUxNzdkNTZiZDBjOTk1ZTAkZXhwb3J0JGI4OWE4MjdlOTI1NDIxMWEpLmNyZWF0ZSh7XG4gICAgICAgICAgICBmcmFtZToge1xuICAgICAgICAgICAgICAgIG9uZW9mS2luZDogXCJtZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeShtc2cpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCgwLCAkNTE3N2Q1NmJkMGM5OTVlMCRleHBvcnQkYjg5YTgyN2U5MjU0MjExYSkudG9CaW5hcnkoZnJhbWUpKTtcbiAgICB9XG4gICAgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSkge1xuICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgQmxvYikpIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlXCIpO1xuICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IGRhdGEuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gKDAsICQ1MTc3ZDU2YmQwYzk5NWUwJGV4cG9ydCRiODlhODI3ZTkyNTQyMTFhKS5mcm9tQmluYXJ5KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSkuZnJhbWU7XG4gICAgICAgIGlmIChwYXJzZWQub25lb2ZLaW5kID09PSBcImF1ZGlvXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvVmVjdG9yID0gQXJyYXkuZnJvbShwYXJzZWQuYXVkaW8uYXVkaW8pO1xuICAgICAgICAgICAgY29uc3QgdWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGF1ZGlvVmVjdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IGludDE2QXJyYXkgPSBuZXcgSW50MTZBcnJheSh1aW50OEFycmF5LmJ1ZmZlcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXVkaW9cIixcbiAgICAgICAgICAgICAgICBhdWRpbzogaW50MTZBcnJheVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJzZWQub25lb2ZLaW5kID09PSBcIm1lc3NhZ2VcIikge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gSlNPTi5wYXJzZShwYXJzZWQubWVzc2FnZS5kYXRhKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJtZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBmcmFtZSBraW5kXCIpO1xuICAgIH1cbn1cblxuXG5jbGFzcyAkN2Y0MmVkYTc0ZjFiMTYzMiRleHBvcnQkZGUyMTgzNmZjNDJjNmY5YyBleHRlbmRzICgwLCAka1I2dEckVHJhbnNwb3J0KSB7XG4gICAgY29uc3RydWN0b3IoeyBzZXJpYWxpemVyOiBzZXJpYWxpemVyLCByZWNvcmRlclNhbXBsZVJhdGU6IHJlY29yZGVyU2FtcGxlUmF0ZSwgcGxheWVyU2FtcGxlUmF0ZTogcGxheWVyU2FtcGxlUmF0ZSB9ID0ge1xuICAgICAgICBzZXJpYWxpemVyOiBuZXcgKDAsICRhNmMwODBkYzUxYzk2ODdmJGV4cG9ydCQ0YjIwMjZmOGUxMWIxNDhhKSgpLFxuICAgICAgICByZWNvcmRlclNhbXBsZVJhdGU6ICQ3ZjQyZWRhNzRmMWIxNjMyJGV4cG9ydCRkZTIxODM2ZmM0MmM2ZjljLlJFQ09SREVSX1NBTVBMRV9SQVRFLFxuICAgICAgICBwbGF5ZXJTYW1wbGVSYXRlOiAkN2Y0MmVkYTc0ZjFiMTYzMiRleHBvcnQkZGUyMTgzNmZjNDJjNmY5Yy5QTEFZRVJfU0FNUExFX1JBVEVcbiAgICB9KXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hdWRpb1F1ZXVlID0gW107XG4gICAgICAgIHRoaXMuX21lZGlhTWFuYWdlciA9IG5ldyAoMCwgJDIyZWNlMDQ1MjkwYzk5NmEkZXhwb3J0JGM5NWM2NWFiYzVmNDcxMjUpKHRydWUsIHRydWUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCA1MTIsIHJlY29yZGVyU2FtcGxlUmF0ZSwgcGxheWVyU2FtcGxlUmF0ZSk7XG4gICAgICAgIHRoaXMuX21lZGlhTWFuYWdlci5zZXRVc2VyQXVkaW9DYWxsYmFjayh0aGlzLmhhbmRsZVVzZXJBdWRpb1N0cmVhbS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fd3MgPSBudWxsO1xuICAgICAgICB0aGlzLl9zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZShvcHRpb25zLCBtZXNzYWdlSGFuZGxlcikge1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gb3B0aW9ucy5jYWxsYmFja3MgPz8ge307XG4gICAgICAgIHRoaXMuX29uTWVzc2FnZSA9IG1lc3NhZ2VIYW5kbGVyO1xuICAgICAgICB0aGlzLl9tZWRpYU1hbmFnZXIuc2V0UlRWSU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBcImRpc2Nvbm5lY3RlZFwiO1xuICAgIH1cbiAgICBhc3luYyBpbml0RGV2aWNlcygpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFwiaW5pdGlhbGl6aW5nXCI7XG4gICAgICAgIGF3YWl0IHRoaXMuX21lZGlhTWFuYWdlci5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBcImluaXRpYWxpemVkXCI7XG4gICAgfVxuICAgIGFzeW5jIGNvbm5lY3QoYXV0aEJ1bmRsZSwgYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBcImNvbm5lY3RpbmdcIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX3dzID0gdGhpcy5pbml0aWFsaXplV2Vic29ja2V0KGF1dGhCdW5kbGUpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fd3MuY29ubmVjdCgpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fbWVkaWFNYW5hZ2VyLmNvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBcImNvbm5lY3RlZFwiO1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLm9uQ29ubmVjdGVkPy4oKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBGYWlsZWQgdG8gY29ubmVjdCB0byB3ZWJzb2NrZXQ6ICR7ZXJyb3J9YDtcbiAgICAgICAgICAgICgwLCAka1I2dEckbG9nZ2VyKS5lcnJvcihtc2cpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFwiZXJyb3JcIjtcbiAgICAgICAgICAgIHRocm93IG5ldyAoMCwgJGtSNnRHJFRyYW5zcG9ydFN0YXJ0RXJyb3IpKG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFwiZGlzY29ubmVjdGluZ1wiO1xuICAgICAgICBhd2FpdCB0aGlzLl9tZWRpYU1hbmFnZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICBhd2FpdCB0aGlzLl93cz8uY2xvc2UoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFwiZGlzY29ubmVjdGVkXCI7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5vbkRpc2Nvbm5lY3RlZD8uKCk7XG4gICAgfVxuICAgIGdldEFsbE1pY3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYU1hbmFnZXIuZ2V0QWxsTWljcygpO1xuICAgIH1cbiAgICBnZXRBbGxDYW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFNYW5hZ2VyLmdldEFsbENhbXMoKTtcbiAgICB9XG4gICAgZ2V0QWxsU3BlYWtlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYU1hbmFnZXIuZ2V0QWxsU3BlYWtlcnMoKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlTWljKG1pY0lkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYU1hbmFnZXIudXBkYXRlTWljKG1pY0lkKTtcbiAgICB9XG4gICAgdXBkYXRlQ2FtKGNhbUlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYU1hbmFnZXIudXBkYXRlQ2FtKGNhbUlkKTtcbiAgICB9XG4gICAgdXBkYXRlU3BlYWtlcihzcGVha2VySWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhTWFuYWdlci51cGRhdGVTcGVha2VyKHNwZWFrZXJJZCk7XG4gICAgfVxuICAgIGdldCBzZWxlY3RlZE1pYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhTWFuYWdlci5zZWxlY3RlZE1pYztcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkU3BlYWtlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhTWFuYWdlci5zZWxlY3RlZFNwZWFrZXI7XG4gICAgfVxuICAgIGVuYWJsZU1pYyhlbmFibGUpIHtcbiAgICAgICAgdGhpcy5fbWVkaWFNYW5hZ2VyLmVuYWJsZU1pYyhlbmFibGUpO1xuICAgIH1cbiAgICBnZXQgaXNNaWNFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFNYW5hZ2VyLmlzTWljRW5hYmxlZDtcbiAgICB9XG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuICAgIHNldCBzdGF0ZShzdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IHN0YXRlKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5vblRyYW5zcG9ydFN0YXRlQ2hhbmdlZD8uKHN0YXRlKTtcbiAgICB9XG4gICAgZ2V0IGV4cGlyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGlyeTtcbiAgICB9XG4gICAgdHJhY2tzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFNYW5hZ2VyLnRyYWNrcygpO1xuICAgIH1cbiAgICBpbml0aWFsaXplV2Vic29ja2V0KGF1dGhCdW5kbGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJJbml0aWFsaXppbmcgd2Vic29ja2V0XCIsIGF1dGhCdW5kbGUpO1xuICAgICAgICBjb25zdCB3cyA9IG5ldyAoMCwgJDAzMjM4MGRiY2YzZjRlMTMkZXhwb3J0JDRmM2QwZmZkOTQxZWJlZmIpKGAke2F1dGhCdW5kbGUud3NfdXJsfWAsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgcGFyc2VCbG9iVG9Kc29uOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZGlzYWJsaW5nIHRoZSBrZWVwIGFsaXZlLCB0aGVyZSBpcyBubyBBUEkgZm9yIGl0IGluc2lkZSBQaXBlY2F0XG4gICAgICAgIHdzLmtlZXBBbGl2ZUludGVydmFsID0gMDtcbiAgICAgICAgd3Mub24oXCJvcGVuXCIsICgpPT57XG4gICAgICAgICAgICAoMCwgJGtSNnRHJGxvZ2dlcikuZGVidWcoXCJXZWJzb2NrZXQgY29ubmVjdGlvbiBvcGVuZWRcIik7XG4gICAgICAgIH0pO1xuICAgICAgICB3cy5vbihcIm1lc3NhZ2VcIiwgYXN5bmMgKGRhdGEpPT57XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IGF3YWl0IHRoaXMuX3NlcmlhbGl6ZXIuZGVzZXJpYWxpemUoZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC50eXBlID09PSBcImF1ZGlvXCIpIHRoaXMuX21lZGlhTWFuYWdlci5idWZmZXJCb3RBdWRpbyhwYXJzZWQuYXVkaW8pO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnNlZC50eXBlID09PSBcIm1lc3NhZ2VcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkLm1lc3NhZ2UubGFiZWwgPT09IFwicnR2aS1haVwiKSB0aGlzLl9vbk1lc3NhZ2UocGFyc2VkLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAoMCwgJGtSNnRHJGxvZ2dlcikuZXJyb3IoXCJGYWlsZWQgdG8gZGVzZXJpYWxpemUgaW5jb21pbmcgbWVzc2FnZVwiLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdzLm9uKFwiZXJyb3JcIiwgKGVycm9yKT0+e1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uRXJyb3IoYHdlYnNvY2tldCBlcnJvcjogJHtlcnJvcn1gKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHdzLm9uKFwiY29ubmVjdGlvbi10aW1lb3V0XCIsICgpPT57XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25FcnJvcihcIndlYnNvY2tldCBjb25uZWN0aW9uIHRpbWVkIG91dFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHdzLm9uKFwiY2xvc2VcIiwgKGNvZGUpPT57XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25FcnJvcihgd2Vic29ja2V0IGNvbm5lY3Rpb24gY2xvc2VkLiBDb2RlOiAke2NvZGV9YCk7XG4gICAgICAgIH0pO1xuICAgICAgICB3cy5vbihcInJlY29ubmVjdC1mYWlsZWRcIiwgKCk9PntcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbkVycm9yKGB3ZWJzb2NrZXQgcmVjb25uZWN0IGZhaWxlZGApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHdzO1xuICAgIH1cbiAgICBzZW5kUmVhZHlNZXNzYWdlKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gXCJyZWFkeVwiO1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKCgwLCAka1I2dEckUlRWSU1lc3NhZ2UpLmNsaWVudFJlYWR5KCkpO1xuICAgIH1cbiAgICBoYW5kbGVVc2VyQXVkaW9TdHJlYW0oZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJyZWFkeVwiKSB0cnkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaEF1ZGlvUXVldWUoKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRBdWRpb0lucHV0KGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgKDAsICRrUjZ0RyRsb2dnZXIpLmVycm9yKFwiRXJyb3Igc2VuZGluZyBhdWRpbyBzdHJlYW0gdG8gd2Vic29ja2V0OlwiLCBlcnJvcik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gXCJlcnJvclwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgdGhpcy5hdWRpb1F1ZXVlLnB1c2goZGF0YSk7XG4gICAgfVxuICAgIGZsdXNoQXVkaW9RdWV1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXVkaW9RdWV1ZS5sZW5ndGggPD0gMCkgcmV0dXJuO1xuICAgICAgICAoMCwgJGtSNnRHJGxvZ2dlcikuaW5mbyhcIldpbGwgZmx1c2ggYXVkaW8gcXVldWVcIiwgdGhpcy5hdWRpb1F1ZXVlLmxlbmd0aCk7XG4gICAgICAgIHdoaWxlKHRoaXMuYXVkaW9RdWV1ZS5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXVlZERhdGEgPSB0aGlzLmF1ZGlvUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChxdWV1ZWREYXRhKSB0aGlzLl9zZW5kQXVkaW9JbnB1dChxdWV1ZWREYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kUmF3TWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICgwLCAka1I2dEckbG9nZ2VyKS5kZWJ1ZyhcIlJlY2VpdmVkIHJhdyBtZXNzYWdlIHRvIHNlbmQgdG8gV2ViIFNvY2tldFwiLCBtZXNzYWdlKTtcbiAgICAgICAgY29uc3QgZW5jb2RlZCA9IHRoaXMuX3NlcmlhbGl6ZXIuc2VyaWFsaXplKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9zZW5kTXNnKGVuY29kZWQpO1xuICAgIH1cbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICgwLCAka1I2dEckbG9nZ2VyKS5kZWJ1ZyhcIlJlY2VpdmVkIG1lc3NhZ2UgdG8gc2VuZCB0byBXZWIgU29ja2V0XCIsIG1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBlbmNvZGVkID0gdGhpcy5fc2VyaWFsaXplci5zZXJpYWxpemVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9zZW5kTXNnKGVuY29kZWQpO1xuICAgIH1cbiAgICBhc3luYyBfc2VuZEF1ZGlvSW5wdXQoZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZCA9IHRoaXMuX3NlcmlhbGl6ZXIuc2VyaWFsaXplQXVkaW8oZGF0YSwgJDdmNDJlZGE3NGYxYjE2MzIkZXhwb3J0JGRlMjE4MzZmYzQyYzZmOWMuUkVDT1JERVJfU0FNUExFX1JBVEUsIDEpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2VuZE1zZyhlbmNvZGVkKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgKDAsICRrUjZ0RyRsb2dnZXIpLmVycm9yKFwiRXJyb3Igc2VuZGluZyBhdWRpbyBmcmFtZVwiLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfc2VuZE1zZyhtc2cpIHtcbiAgICAgICAgaWYgKCF0aGlzLl93cykge1xuICAgICAgICAgICAgKDAsICRrUjZ0RyRsb2dnZXIpLmVycm9yKFwic2VuZE1zZyBjYWxsZWQgYnV0IFdTIGlzIG51bGxcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3dzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICAgICAgICAoMCwgJGtSNnRHJGxvZ2dlcikuZXJyb3IoXCJhdHRlbXB0IHRvIHNlbmQgdG8gY2xvc2VkIHNvY2tldFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1zZykgcmV0dXJuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fd3Muc2VuZChtc2cpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAoMCwgJGtSNnRHJGxvZ2dlcikuZXJyb3IoXCJzZW5kTXNnIGVycm9yXCIsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbm5lY3Rpb25FcnJvcihlcnJvck1zZykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yTXNnKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFwiZXJyb3JcIjtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIC8vIE5vdCBpbXBsZW1lbnRlZFxuICAgIGVuYWJsZVNjcmVlblNoYXJlKGVuYWJsZSkge1xuICAgICAgICAoMCwgJGtSNnRHJGxvZ2dlcikuZXJyb3IoXCJzdGFydFNjcmVlblNoYXJlIG5vdCBpbXBsZW1lbnRlZCBmb3IgV2ViU29ja2V0VHJhbnNwb3J0XCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIGdldCBpc1NoYXJpbmdTY3JlZW4oKSB7XG4gICAgICAgICgwLCAka1I2dEckbG9nZ2VyKS5lcnJvcihcImlzU2hhcmluZ1NjcmVlbiBub3QgaW1wbGVtZW50ZWQgZm9yIFdlYlNvY2tldFRyYW5zcG9ydFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbmFibGVDYW0oZW5hYmxlKSB7XG4gICAgICAgICgwLCAka1I2dEckbG9nZ2VyKS5lcnJvcihcImVuYWJsZUNhbSBub3QgaW1wbGVtZW50ZWQgZm9yIFdlYlNvY2tldFRyYW5zcG9ydFwiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDYW1FbmFibGVkKCkge1xuICAgICAgICAoMCwgJGtSNnRHJGxvZ2dlcikuZXJyb3IoXCJpc0NhbUVuYWJsZWQgbm90IGltcGxlbWVudGVkIGZvciBXZWJTb2NrZXRUcmFuc3BvcnRcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkQ2FtKCkge1xuICAgICAgICAoMCwgJGtSNnRHJGxvZ2dlcikuZXJyb3IoXCJzZWxlY3RlZENhbSBub3QgaW1wbGVtZW50ZWQgZm9yIFdlYlNvY2tldFRyYW5zcG9ydFwiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbn1cbiQ3ZjQyZWRhNzRmMWIxNjMyJGV4cG9ydCRkZTIxODM2ZmM0MmM2ZjljLlJFQ09SREVSX1NBTVBMRV9SQVRFID0gMTYwMDA7XG4kN2Y0MmVkYTc0ZjFiMTYzMiRleHBvcnQkZGUyMTgzNmZjNDJjNmY5Yy5QTEFZRVJfU0FNUExFX1JBVEUgPSAyNDAwMDtcblxuXG5cblxuY2xhc3MgJDViOTI2ZmEzM2UzNWU0NWMkZXhwb3J0JDQ0YThhMDc3NDIwMzM2YWYge1xuICAgIHNlcmlhbGl6ZShkYXRhKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9XG4gICAgc2VyaWFsaXplQXVkaW8oZGF0YSwgc2FtcGxlUmF0ZSwgbnVtQ2hhbm5lbHMpIHtcbiAgICAgICAgY29uc3QgcGNtU2FtcGxlcyA9IG5ldyBJbnQxNkFycmF5KGRhdGEpO1xuICAgICAgICBjb25zdCBtdUxhd1NhbXBsZXMgPSAoMCwgJGtSNnRHJG11bGF3KS5lbmNvZGUocGNtU2FtcGxlcyk7XG4gICAgICAgIGNvbnN0IGJhc2U2NFBheWxvYWQgPSB0aGlzLmFycmF5VG9CYXNlNjQobXVMYXdTYW1wbGVzKTtcbiAgICAgICAgY29uc3QgdHdpbGlvTWVzc2FnZSA9IHtcbiAgICAgICAgICAgIGV2ZW50OiBcIm1lZGlhXCIsXG4gICAgICAgICAgICBtZWRpYToge1xuICAgICAgICAgICAgICAgIHBheWxvYWQ6IGJhc2U2NFBheWxvYWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHR3aWxpb01lc3NhZ2UpO1xuICAgIH1cbiAgICBzZXJpYWxpemVNZXNzYWdlKG1zZykge1xuICAgICAgICAvLyBUd2lsaW8gZG9lcyBub3Qgc3VwcG9ydCBSVFZJIG1lc3NhZ2VzLCBzbyBqdXN0IGlnbm9yZSB0aGVtXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhcnJheVRvQmFzZTY0KGJ5dGVzKSB7XG4gICAgICAgIGxldCBiaW5hcnkgPSBcIlwiO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgYnl0ZXMuYnl0ZUxlbmd0aDsgaSsrKWJpbmFyeSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKTtcbiAgICAgICAgcmV0dXJuIGJ0b2EoYmluYXJ5KTtcbiAgICB9XG4gICAgYmFzZTY0VG9VaW50OEFycmF5KGJhc2U2NCkge1xuICAgICAgICBjb25zdCBiaW5hcnlTdHJpbmcgPSBhdG9iKGJhc2U2NCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGJpbmFyeVN0cmluZy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKWJ5dGVzW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gICAgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSkge1xuICAgICAgICBjb25zdCBqc29uTWVzc2FnZSA9IEpTT04ucGFyc2UoZGF0YSk7IC8vIEFzc3VtaW5nICdkYXRhJyBpcyBhIEpTT04gc3RyaW5nXG4gICAgICAgIGlmIChqc29uTWVzc2FnZS5ldmVudCA9PT0gXCJjbGVhclwiKSByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJyYXdcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGpzb25NZXNzYWdlXG4gICAgICAgIH07XG4gICAgICAgIGVsc2UgaWYgKGpzb25NZXNzYWdlLmV2ZW50ID09PSBcIm1lZGlhXCIpIHtcbiAgICAgICAgICAgIC8vIERlc2VyaWFsaXplICdtZWRpYScgZXZlbnRcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBqc29uTWVzc2FnZS5tZWRpYS5wYXlsb2FkO1xuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZF9kYXRhID0gdGhpcy5iYXNlNjRUb1VpbnQ4QXJyYXkocGF5bG9hZCk7XG4gICAgICAgICAgICAvL2NvbnN0IGRlY29kZWRfYXVkaW8gPSB0aGlzLnVsYXdUb1BjbShzZXJpYWxpemVkX2RhdGEpO1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlZF9hdWRpbyA9ICgwLCAka1I2dEckbXVsYXcpLmRlY29kZShzZXJpYWxpemVkX2RhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImF1ZGlvXCIsXG4gICAgICAgICAgICAgICAgYXVkaW86IGRlY29kZWRfYXVkaW9cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSAvLyBEZXNlcmlhbGl6ZSBvdGhlciBtZXNzYWdlIHR5cGVzIChhc3N1bWluZyAnZnJhbWUnIGhhcyAnbWVzc2FnZScgZmllbGQpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIm1lc3NhZ2VcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGpzb25NZXNzYWdlLm1lc3NhZ2VcbiAgICAgICAgfTtcbiAgICB9XG59XG5cblxuXG5cbmV4cG9ydCB7JGZjNDlhNTZjZDg3MzkxMjckZXhwb3J0JDQ1YzViOWJmYmEyZjYzMDQgYXMgV2F2TWVkaWFNYW5hZ2VyLCAkMjJlY2UwNDUyOTBjOTk2YSRleHBvcnQkYzk1YzY1YWJjNWY0NzEyNSBhcyBEYWlseU1lZGlhTWFuYWdlciwgJDdmNDJlZGE3NGYxYjE2MzIkZXhwb3J0JGRlMjE4MzZmYzQyYzZmOWMgYXMgV2ViU29ja2V0VHJhbnNwb3J0LCAkYTZjMDgwZGM1MWM5Njg3ZiRleHBvcnQkNGIyMDI2ZjhlMTFiMTQ4YSBhcyBQcm90b2J1ZkZyYW1lU2VyaWFsaXplciwgJDViOTI2ZmEzM2UzNWU0NWMkZXhwb3J0JDQ0YThhMDc3NDIwMzM2YWYgYXMgVHdpbGlvU2VyaWFsaXplcn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pipecat-ai/websocket-transport/dist/index.module.js\n");

/***/ })

};
;